<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Maven</title>
    <url>/2020/10/21/20201021-Maven/</url>
    <content><![CDATA[<p>使用 Maven 可以大幅度提升开发效率</p>
<span id="more"></span>

<h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><p>优点</p>
<ul>
<li>节省磁盘空间</li>
<li>可以一键构建</li>
<li>可以跨平台</li>
<li>提高开发效率</li>
</ul>
<p>三种仓库</p>
<ul>
<li>本地仓库</li>
<li>远程仓库（私服）</li>
<li>中央仓库</li>
</ul>
<p>常见命令</p>
<ul>
<li>Compile编译</li>
<li>Test测试</li>
<li>Package打包</li>
<li>Install安装</li>
<li>Deploy部署</li>
<li>Clean清空</li>
</ul>
<p>坐标书写规范</p>
<ul>
<li>groupId公司或组织域名的倒序</li>
<li>artifactId项目名或模块名</li>
<li>version版本号</li>
</ul>
<p>添加坐标</p>
<ul>
<li>在本地仓库搜索</li>
<li>互联网搜索，<a href="http://www.mvnrepository.com/%E4%B8%AD%E5%A4%AE%E4%BB%93%E5%BA%93">http://www.mvnrepository.com/中央仓库</a></li>
</ul>
<p>依赖范围</p>
<ul>
<li>Compile</li>
<li>Test</li>
<li>Runtime</li>
<li>Provided</li>
</ul>
<h2 id="maven构建SSM工程"><a href="#maven构建SSM工程" class="headerlink" title="maven构建SSM工程"></a>maven构建SSM工程</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>1.创建数据库表</p>
<p>2.创建maven工程</p>
<p>2.1使用webapp框架构建</p>
<p><img src="/images/Maven/webapp.png" alt="img"></p>
<p>2.2填写坐标</p>
<p><img src="/images/Maven/groupId.png" alt="img"></p>
<p>2.3查看是否使用私服</p>
<p><img src="/images/Maven/settingsFile.png" alt="img"></p>
<p>3.在main目录下新建Java和resources文件夹</p>
<p><img src="/images/Maven/java_resources.png" alt="img"></p>
<p>4.把Java和resources文件夹转换成对应文件夹类型</p>
<p><img src="/images/Maven/resources_root.png" alt="img"></p>
<p>5.在pom.xml修改编译版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--设置编译版本为1.8--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1&lt;/version &gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="关于依赖的知识点扩充"><a href="#关于依赖的知识点扩充" class="headerlink" title="关于依赖的知识点扩充"></a>关于依赖的知识点扩充</h3><ul>
<li>什么是依赖传递<br>如果添加了一个 springmvc 的核心依赖坐标，则会出现除了 spring-webmvc 以外的其他 jar 包，这种现象称为依赖传递。</li>
<li>什么是依赖冲突<br>当导入多个依赖时，会出现包含了同一个 jar 包的情况，那么究竟要使用哪个依赖包含的 jar 包？这就是依赖冲突。</li>
<li>依赖调解<br>1.第一声明者优先原则：先声明的依赖为准来使用jar包<br>2.路径近者优先原则：可以直接将共有的jar包进行手动导入<br>3.排出依赖：将共有的jar包排出在外，只保留一个使用<br>4.锁定版本：版本锁定后则不考虑依赖的声明顺序或依赖的路径，以锁定的版本的为准添加到工程中。<br>在导入依赖时指定版本<br>提取版本，单独定义全局版本<br>注意：在工程中锁定依赖的版本并不代表在工程中添加了依赖，如果工程需要添加锁定版本的依赖则需要单独添加<dependencies></dependencies>标签，如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="定义pom-xml"><a href="#定义pom-xml" class="headerlink" title="定义pom.xml"></a>定义pom.xml</h3><p>maven 工程首先要识别依赖，web 工程实现 SSM 整合，需要依赖 spring-webmvc5.0.2、spring5.0.2、mybatis3.4.5 等，在 pom.xml 添加工程如下依赖：</p>
<p>（在实际企业开发中会有架构师专门来编写 pom.xml）</p>
<p>分两步：</p>
<p>1）锁定依赖版本</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">springmvc.version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">springmvc.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mybatis.version</span>&gt;</span>3.4.5<span class="tag">&lt;/<span class="name">mybatis.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2）添加依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Mybatis --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mybatis.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- springMVC --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;springmvc.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span>    </span><br></pre></td></tr></table></figure>

<h3 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h3><p>在src/main/java中定义 dao 接口，实现根据 id 查询商品信息：</p>
<p>1.创建pojo模型类</p>
<p><img src="/images/Maven/pojo.png" alt="img"></p>
<p>2.dao层代码</p>
<p><img src="/images/Maven/dao.png" alt="img"></p>
<p>3.配置文件</p>
<ul>
<li>配置dao的实现</li>
</ul>
<p><img src="/images/Maven/mapper.png" alt="img"></p>
<ul>
<li>配置数据库，在 src/main/resources 创建applicationContext.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--数据库连接池--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--驱动--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- url --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/maven&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--用户名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 密码--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mapper配置-- &gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 让spring管理sqlsessionfactory使用mybatis和spring整合包中的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 数据库连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;typeAliasesPackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cn.itcast.ssm.pojo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- mapper扫描器:用来产生代理对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cn.itcast.ssm.dao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>配置日志，在 src/main/resources 配置 log4j.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">### direct log messages to stdout ###</span></span><br><span class="line"><span class="meta">1og4j.appender.stdout</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.Target</span>=<span class="string">System.out</span></span><br><span class="line"><span class="meta">log4j.appender.stdout.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">1og4j.appender.stdout.layout.ConversionPattern</span>=<span class="string">%d&#123;ABSOLUTE&#125; %5 p %c&#123;1&#125;:%L - %m%n</span></span><br><span class="line"><span class="comment">## set log levels - for more verbose logging change &#x27; info&#x27; to</span></span><br><span class="line"><span class="meta">&#x27;debug&#x27;</span> <span class="string">##</span></span><br><span class="line"><span class="comment">#在开发阶段日志级别使用debug</span></span><br><span class="line"><span class="meta">log4j.rootLogger</span>=<span class="string">debug, stdout</span></span><br><span class="line"><span class="comment">##在日志中输出sql的输入参数##</span></span><br><span class="line"><span class="meta">1og4j.logger.org.hibernate.type</span>=<span class="string">TRACE</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>4.单元测试</p>
<p>在 src/test/java 创建单元测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemsMapperTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindItemsById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;classpath:applicationContext.xml&quot;</span>);</span><br><span class="line">        ItemsMapper itemsMapper = applicationContext.getBean(ItemsMapper.class);</span><br><span class="line">        Items items = itemsMapper.findById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(items);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Service层"><a href="#Service层" class="headerlink" title="Service层"></a>Service层</h3><p>1.代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItemsServiceImpl</span> <span class="keyword">implements</span> <span class="title">ItemsService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ItemsMapper itemsMapper;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Items <span class="title">findById</span><span class="params">(<span class="keyword">int</span> itemId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> itemsMapper.findById(itemId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--applicationContext.xml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.itcast.ssm.service&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="web层"><a href="#web层" class="headerlink" title="web层"></a>web层</h3><p>springmvc.xml中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.W3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans-4.2.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://Wwwspringframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/context/spring-context-4.2.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.itcast.ssm.controller&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置视图解析器的前缀和后缀--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/jsp/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>web.xml中</p>
<p>加载spring容器，配置springmvc前端控制器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmIns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee </span></span></span><br><span class="line"><span class="string"><span class="tag">                    http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">id</span>=<span class="string">&quot;webApp.ID&quot;</span> <span class="attr">version</span>=<span class="string">&quot;2.5&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--前端控制器加载springmvc容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.action<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--监听器加载spring容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Jsp页面"><a href="#Jsp页面" class="headerlink" title="Jsp页面"></a>Jsp页面</h3><p>/WEB-INF/jsp/viewItem.jsp 如下：</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ taglib uri=<span class="string">&quot;http://java.sun.com/jsp/jst1/core&quot;</span> prefix=<span class="string">&quot;C&quot;</span> %&gt;</span><br><span class="line">&lt;%@ taglib uri=<span class="string">&quot;http://java.sun.com/jsp/jst1/fmt&quot;</span> prefix=<span class="string">&quot;fmt&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span></span><br><span class="line"><span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;商品信息&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form&gt;</span><br><span class="line">    &lt;table width=<span class="string">&quot;100%&quot;</span>border=<span class="number">1</span>&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;商品名称&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;item.name&#125;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;商品价格&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;item.price&#125;&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;生成日期&lt;/td&gt;</span><br><span class="line">            &lt;td&gt; &lt;fmt:formatDate value=<span class="string">&quot;$&#123;item.createtime&#125;&quot;</span></span><br><span class="line">            pattern=<span class="string">&quot;yy-MM-dd HH:mm:ss&quot;</span>/&gt; &lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;商品简介&lt;/td&gt;</span><br><span class="line">            &lt;td&gt;$&#123;item.detail&#125;&lt;/textarea&gt;</span><br><span class="line">            &lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt; </span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">&lt;/form&gt; </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Maven</category>
      </categories>
  </entry>
  <entry>
    <title>IO流归纳</title>
    <url>/2020/05/14/2020514-IO%E6%B5%81%E5%BD%92%E7%BA%B3/</url>
    <content><![CDATA[<p>因为Java的IO流种类多，名字相似，所以本文针对Java中出现的各种IO流进行了归纳总结</p>
<span id="more"></span>

<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="字节输出流【OutputStream】"><a href="#字节输出流【OutputStream】" class="headerlink" title="字节输出流【OutputStream】"></a>字节输出流【OutputStream】</h3><p>java.io.OutputStream 抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<h5 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h5><p><code>public void close()</code>：关闭此输出流并释放与此流相关联的任何系统资源。</p>
<p><code>public void flush()</code>：刷新此输出流并强制任何缓冲的输出字节被写出。</p>
<p><code>public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流。</p>
<p><code>public void write(byte[] b, int off, int len)</code>：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。</p>
<p><code>public abstract void write(int b)</code>：将指定的字节输出流。</p>
<blockquote>
<p>close方法，当完成流的操作时，必须调用此方法释放系统资源。</p>
</blockquote>
<h4 id="文件输出流【FileOutputStream类】"><a href="#文件输出流【FileOutputStream类】" class="headerlink" title="文件输出流【FileOutputStream类】"></a>文件输出流【FileOutputStream类】</h4><p><code>java.io.FileOutputStream</code> 类文件输出流，是字节输出流<code>OutputStream</code>的子类，用于将数据写出到文件。</p>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p><code>public FileOutputStream(File file)</code>：创建文件输出流以写入由指定的 File对象表示的文件。</p>
<p><code>public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称写入文件。</p>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>写出字节：<code>write(int b)</code></p>
<p>写出字节数组：<code>write(byte[] b)</code></p>
<p>写出指定长度字节数组：<code>write(byte[] b, int off, int len)</code></p>
<p>数据追加续写：<code>public FileOutputStream(File file, boolean append)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public FileOutputStream(String name, boolean append)</span><br></pre></td></tr></table></figure>

<p>写出换行：<code>\r\n</code>(windows) <code>\n</code>(linux) <code>\r</code>(mac)</p>
<h3 id="字节输入流【InputStream】"><a href="#字节输入流【InputStream】" class="headerlink" title="字节输入流【InputStream】"></a>字节输入流【InputStream】</h3><p><code>java.io.InputStream</code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p>
<h5 id="基本方法-1"><a href="#基本方法-1" class="headerlink" title="基本方法"></a>基本方法</h5><p><code>public void close()</code>：关闭此输入流并释放与此流相关联的任何系统资源。</p>
<p><code>public abstract int read()</code>： 从输入流读取数据的下一个字节。</p>
<p><code>public int read(byte[] b)</code> ： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</p>
<blockquote>
<p>close方法，当完成流的操作时，必须调用此方法释放系统资源。</p>
</blockquote>
<h4 id="文件输入流【FileInputStream类】"><a href="#文件输入流【FileInputStream类】" class="headerlink" title="文件输入流【FileInputStream类】"></a>文件输入流【FileInputStream类】</h4><h5 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h5><p><code>FileInputStream(File file)</code> ： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。</p>
<p><code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。</p>
<h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><p>读取字节：<code>read()</code></p>
<p>使用字节数组读取：<code>read(byte[] b)</code></p>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><h3 id="字符输入流【Reader】"><a href="#字符输入流【Reader】" class="headerlink" title="字符输入流【Reader】"></a>字符输入流【Reader】</h3><p><code>java.io.Reader</code>抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p>
<p><code>public void close()</code>：关闭此流并释放与此流相关联的任何系统资源。</p>
<p><code>public int read()</code>： 从输入流读取一个字符。</p>
<p><code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。</p>
<h4 id="文件输入流【FileReader类】"><a href="#文件输入流【FileReader类】" class="headerlink" title="文件输入流【FileReader类】"></a>文件输入流【FileReader类】</h4><h5 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h5><p><code>FileReader(File file)</code> ： 创建一个新的 FileReader ，给定要读取的File对象。</p>
<p><code>FileReader(String fileName)</code> ： 创建一个新的 FileReader ，给定要读取的文件的名称。</p>
<h5 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h5><p>读取字符：<code>read()</code></p>
<p>使用字符数组读取：<code>read(char[] b)</code></p>
<h3 id="字符输出流【Writer】"><a href="#字符输出流【Writer】" class="headerlink" title="字符输出流【Writer】"></a>字符输出流【Writer】</h3><p><code>java.io.Writer</code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节</p>
<p>输出流的基本共性功能方法。</p>
<p><code>void write(int c)</code>写入单个字符。</p>
<p><code>void write(char[] cbuf)</code>写入字符数组。</p>
<p><code>abstract void write(char[] cbuf, int off, int len)</code>写入字符数组的某一部分,off数组的开始索引,len 写的字符个数。</p>
<p><code>void write(String str)</code> 写入字符串。</p>
<p><code>void write(String str, int off, int len)</code>写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</p>
<p><code>void flush()</code> 刷新该流的缓冲。</p>
<p><code>void close()</code>关闭此流，但要先刷新它。</p>
<h4 id="文件输出流【FileWriter类】"><a href="#文件输出流【FileWriter类】" class="headerlink" title="文件输出流【FileWriter类】"></a>文件输出流【FileWriter类】</h4><h5 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h5><p><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。</p>
<p><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。</p>
<h5 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h5><p>写出字符：<code>write(int b)</code></p>
<p>写出字符数组：<code>write(char[] cbuf)</code>和 <code>write(char[] cbuf, int off, int len)</code></p>
<p>写出字符串：<code>write(String str)</code>和<code>write(String str, int off, int len)</code></p>
<p>续写和换行：操作类似于<code>FileOutputStream</code>。</p>
<h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><h3 id="字节缓冲流【BufferedInputStream】"><a href="#字节缓冲流【BufferedInputStream】" class="headerlink" title="字节缓冲流【BufferedInputStream】"></a>字节缓冲流【BufferedInputStream】</h3><h4 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h4><p><code>public BufferedInputStream(InputStream in)</code>：创建一个 新的缓冲输入流。</p>
<p><code>public BufferedOutputStream(OutputStream out)</code>：创建一个新的缓冲输出流。</p>
<h3 id="字符缓冲流-【BufferedReader】"><a href="#字符缓冲流-【BufferedReader】" class="headerlink" title="字符缓冲流 【BufferedReader】"></a>字符缓冲流 【BufferedReader】</h3><h4 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h4><p><code>public BufferedReader(Reader in)</code>：创建一个 新的缓冲输入流。</p>
<p><code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流。</p>
<h4 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h4><p><strong>BufffferedReader</strong>：<code>public String readLine()</code>: 读一行文字。</p>
<p><strong>BufffferedWriter</strong>：<code>public void newLine()</code>: 写一行行分隔符,由系统属性定义符号。</p>
<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><h3 id="InputStreamReader类"><a href="#InputStreamReader类" class="headerlink" title="InputStreamReader类"></a>InputStreamReader类</h3><p><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 <code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集(UTF-8, UTF-16, GBK)的字符流。</p>
<h3 id="OutputStreamWriter类"><a href="#OutputStreamWriter类" class="headerlink" title="OutputStreamWriter类"></a>OutputStreamWriter类</h3><p><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。 <code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集(UTF-8, UTF-16, GBK)的字符流。</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="ObjectOutputStream类"><a href="#ObjectOutputStream类" class="headerlink" title="ObjectOutputStream类"></a>ObjectOutputStream类</h3><p><code>public ObjectOutputStream(OutputStream out)</code>：创建一个指定OutputStream的ObjectOutputStream。</p>
<h4 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h4><p>1.一个对象要想序列化，必须满足两个条件: 该类必须实现<code>java.io.Serializable</code>接口， <code>Serializable</code> 是一个<strong>标记接口</strong>，不实现此接口的类将不会使任 何状态序列化或反序列化，会抛出 <code>NotSerializableException</code>。 该类的所有属性必须是可序列化的。如果有一个<strong>属性不需要可序列化</strong>的，则该属性必须注明是瞬态的，使用 <code>transient</code>关键字修饰。</p>
<p>2.写出对象方法<code>public final void writeObject (Object obj)</code> : 将指定的对象写出。</p>
<h3 id="ObjectInputStream类"><a href="#ObjectInputStream类" class="headerlink" title="ObjectInputStream类"></a>ObjectInputStream类</h3><p><code>public ObjectInputStream(InputStream in)</code> ： 创建一个指定InputStream的ObjectInputStream。</p>
<h4 id="反序列化操作1"><a href="#反序列化操作1" class="headerlink" title="反序列化操作1"></a>反序列化操作1</h4><p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用 ObjectInputStream 读取对象的方法：<code>public final Object readObject ()</code>: 读取一个对象。</p>
<p>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code>异常。</p>
<h4 id="反序列化操作2"><a href="#反序列化操作2" class="headerlink" title="反序列化操作2"></a>反序列化操作2</h4><p>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操 作也会失败，抛出一个 InvalidClassException 异常。</p>
<p>发生这个异常的原因如下：</p>
<ul>
<li>该类的序列版本号与从流中读取的类描述符的版本号不匹配</li>
<li>该类包含未知数据类型</li>
<li>该类没有可访问的无参数构造方法 Serializable 接口给需要序列化的类，提供了一个序列版本号</li>
</ul>
<p>serialVersionUID 该版本号的目的在于验证序 列化的对象和对应类是否版本匹配。</p>
<h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><p>平时我们在控制台打印输出，是调用 <code>print</code> 方法和 <code>println</code>方法完成的，这两个方法都来自于<code>java.io.PrintStream</code> 类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p>
<h3 id="PrintStream类"><a href="#PrintStream类" class="headerlink" title="PrintStream类"></a>PrintStream类</h3><h4 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h4><p><code>public PrintStream(String fileName)</code>： 使用指定的文件名创建一个新的打印流。</p>
<h4 id="改变打印流向"><a href="#改变打印流向" class="headerlink" title="改变打印流向"></a>改变打印流向</h4><p>System.out 就是 PrintStream 类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象， 我们就可以玩一个”小把戏”，改变它的流向。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintDemo</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">             <span class="comment">// 调用系统的打印流,控制台直接输出97</span></span><br><span class="line">             System.out.println(<span class="number">97</span>);</span><br><span class="line">             <span class="comment">// 创建打印流,指定文件的名称</span></span><br><span class="line">             PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">&quot;ps.txt&quot;</span>);</span><br><span class="line">             <span class="comment">// 设置系统的打印流流向,输出到ps.txt</span></span><br><span class="line">             System.setOut(ps);</span><br><span class="line">             <span class="comment">// 调用系统的打印流,ps.txt中输出97</span></span><br><span class="line">             System.out.println(<span class="number">97</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>知识整理</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL基础语法</title>
    <url>/2020/05/24/2020524-MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>对数据库进行操作的基本SQL(DDL DML DQL DCL)</p>
<span id="more"></span>

<h2 id="什么是SQL"><a href="#什么是SQL" class="headerlink" title="什么是SQL"></a>什么是SQL</h2><p>Structured Query Language 结构化查询语言</p>
<h2 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h2><ol>
<li><p>Data Definition Language (DDL 数据定义语言) 如：建库，建表</p>
</li>
<li><p>Data Manipulation Language(DML 数据操纵语言)如：对表中的记录操作增删改</p>
</li>
<li><p>Data Query Language(DQL 数据查询语言)如：对表中的查询操作</p>
</li>
<li><p>Data Control Language(DCL 数据控制语言)如：对用户权限的设置</p>
</li>
</ol>
<h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="对库操作"><a href="#对库操作" class="headerlink" title="对库操作"></a>对库操作</h3><ul>
<li><strong>创建数据库</strong><br><code>CREATE DATABASE 数据库名;</code><br><strong>判断</strong>数据库是否已经存在，不存在则创建数据库<br><code>CREATE DATABASE IF NOT EXISTS 数据库名;</code><br>创建数据库并<strong>指定字符集</strong><br><code>CREATE DATABASE 数据库名 CHARACTER SET 字符集;</code></li>
<li><strong>查看数据库</strong><br>– 查看<strong>所有</strong>的数据库 <code>show databases;</code><br>– 查看<strong>某个</strong>数据库的定义信息 <code>show create database db3;</code></li>
<li><strong>修改数据库</strong><br>修改数据库默认的<strong>字符集</strong><br><code>ALTER DATABASE 数据库名 DEFAULT CHARACTER SET 字符集;</code></li>
<li><strong>删除数据库</strong><br><code>DROP DATABASE 数据库名;</code></li>
<li><strong>使用数据库</strong><br><strong>查看</strong>正在使用的数据库 <code>SELECT DATABASE();</code><br>使用的一个 MySQL中的全局函数 <strong>使用</strong>/<strong>切换</strong>数据库 <code>USE 数据库名;</code></li>
</ul>
<h3 id="对表操作"><a href="#对表操作" class="headerlink" title="对表操作"></a>对表操作</h3><ul>
<li><strong>创建表</strong><br><code>CREATE TABLE 表名 ( 字段名 1 字段类型 1, 字段名 2 字段类型 2 --最后一个字段无分号 );</code><br>快速创建一个<strong>表结构相同</strong>的表<br><code>CREATE TABLE 新表名 LIKE 旧表名;</code></li>
<li><strong>查看表</strong><br>查看某个数据库中的<strong>所有表</strong><br><code>SHOW TABLES;</code><br>查看<strong>表结构</strong><br><code>DESC 表名;</code><br><strong>查看创建表</strong><br><code>SHOW CREATE TABLE 表名;</code></li>
<li><strong>删除表</strong><br><strong>直接</strong>删除表 <code>DROP TABLE 表名;</code><br><strong>判断</strong>表是否存在，如果存在则删除表<br><code>DROP TABLE IF EXISTS 表名;</code></li>
<li><strong>修改表</strong><br>添加<strong>表列</strong><br><code>ALTER TABLE 表名 ADD 列名 类型;</code><br>修改<strong>列类型</strong><br><code>ALTER TABLE 表名 MODIFY 列名 新的类型;</code><br>修改<strong>列名</strong><br><code>ALTER TABLE 表名 CHANGE 旧列名 新列名 类型;</code><br><strong>删除列</strong><br><code>ALTER TABLE 表名 DROP 列名;</code></li>
</ul>
<h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><h3 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h3><ul>
<li><strong>插入记录</strong><br><code>INSERT [INTO] 表名 [字段名] VALUES (字段值);</code><br><code> --INSERT INTO 表名：表示往哪张表中添加数据 (字段名 1, 字段名 2, …)：要给哪些字段设置值 VALUES (值 1, 值 2, …)：设置具体的值</code></li>
<li><strong>表的复制</strong><br>将表名 2 中的<strong>所有的列复制</strong>到表名 1 中<br><code>INSERT INTO 表名 1 SELECT * FROM 表名 2;</code><br>只复制<strong>部分列</strong><br><code>INSERT INTO 表名 1(列 1, 列 2) SELECT 列 1, 列 2 FROM student;</code></li>
<li><strong>更新表记录</strong><br><code>UPDATE 表名 SET 列名=值 [WHERE 条件表达式]; </code><br><code>--UPDATE: 需要更新的表名 SET: 修改的列值 WHERE: 符合条件的记录才更新 你可以同时更新一个或多个字段。 你可以在 WHERE 子句中指定任何条件。</code></li>
<li><strong>删除表记录</strong><br><code>DELETE FROM 表名 [WHERE 条件表达式]</code><br><code>--如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。 你可以在 WHERE 子句中指定任何条件</code></li>
</ul>
<h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><h3 id="查询表"><a href="#查询表" class="headerlink" title="查询表"></a>查询表</h3><ul>
<li><p>查询表<strong>所有</strong>行和列的数据<br><code>使用*表示所有列</code><br><code>SELECT * FROM 表名;</code></p>
</li>
<li><p>查询<strong>指定列</strong>的数据,多个列之间以逗号分隔<br><code>SELECT 字段名 1, 字段名 2, 字段名 3, ... FROM 表名;</code></p>
</li>
<li><p>对列指定<strong>别名</strong><br><code>SELECT 字段名 1 AS 别名, 字段名 2 AS 别名... FROM 表名;</code></p>
</li>
<li><p>对列和表同时指定<strong>别名</strong><br><code>SELECT 字段名 1 AS 别名, 字段名 2 AS 别名... FROM 表名 AS 表别名;</code></p>
</li>
<li><p>查询指定列并且结果<strong>不出现重复数据</strong><br><code>SELECT DISTINCT 字段名 FROM 表名;</code></p>
</li>
<li><p>某列数据和固定值<strong>运算</strong><br><code>SELECT 列名 1 + 固定值 FROM 表名;</code></p>
</li>
<li><p>某列数据和其他列数据参与<strong>运算</strong><br> <code>SELECT 列名 1 + 列名 2 FROM 表名;</code></p>
</li>
<li><p>条件查询</p>
<p>的语法 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段名 FROM 表名 WHERE 条件;</span><br></pre></td></tr></table></figure>

<p>流程：取出表中的每条数据，满足条件的记录就返回，不满足条件的记录不返回</p>
<ul>
<li><strong>in</strong> 关键字<br><code>SELECT 字段名 FROM 表名 WHERE 字段 in (数据 1, 数据 2...);</code><br>in 里面的每个数据都会作为一次条件，只要满足条件的就会显示</li>
<li><strong>between</strong> 关键字<br><code>BETWEEN 值 1 AND 值 2;</code><br>表示从值 1 到值 2 范围，包头又包尾 比如：age BETWEEN 80 AND 100 相当于： age&gt;=80 &amp;&amp; age&lt;=100</li>
<li><strong>like</strong> 关键字<br>LIKE 表示模糊查询<br><code>SELECT * FROM 表名 WHERE 字段名 LIKE &#39;通配符字符串&#39;;</code></li>
<li>MySQL <strong>通配符</strong><br> <strong>‘%’</strong> 匹配任意<strong>多</strong>个字符串<br><strong>‘_’</strong> 匹配<strong>一</strong>个字符</li>
</ul>
</li>
</ul>
<h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2><h3 id="操作用户"><a href="#操作用户" class="headerlink" title="操作用户"></a>操作用户</h3><ul>
<li><p><strong>创建</strong><br><code>CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</code></p>
</li>
<li><p><strong>授权</strong><br><code>GRANT 权限 1, 权限 2... ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;</code><br><img src="/images/MySQL/MySQL-Grant.png" alt="MySQL-Grant"></p>
</li>
<li><p><strong>撤销授权</strong><br><code>REVOKE 权限 1, 权限 2... ON 数据库.表名 revoke all on test.* from &#39;user1&#39;@&#39;localhost&#39;; </code><br><code>&#39;用户名&#39;@&#39;主机名&#39;;</code></p>
</li>
<li><p><strong>查看权限</strong><br><code>SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;</code></p>
</li>
<li><p><strong>删除用户</strong><br><code>DROP USER &#39;用户名&#39;@&#39;主机名&#39;;</code></p>
</li>
<li><p><strong>修改管理员密码</strong><br><code>mysqladmin -uroot -p password 新密码;</code></p>
</li>
<li><p><strong>修改普通用户密码</strong><br><code>set password for &#39;用户名&#39;@&#39;主机名&#39; = password(&#39;新密码&#39;);</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>Java内存划分</title>
    <url>/2020/05/29/2020529-Java%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<p>简要的指明Java中内存有哪些区域</p>
<span id="more"></span>

<h2 id="1-栈（Stack）"><a href="#1-栈（Stack）" class="headerlink" title="1. 栈（Stack）"></a>1. 栈（Stack）</h2><p><strong>存放的都是方法中的<code>局部变量</code></strong></p>
<p><strong>方法的运行一定要在栈中运行</strong></p>
<p>局部变量：方法的参数，或者是方法 {方法体} 内部的变量。</p>
<p>作用域：一旦超出作用域，立刻从栈内存中消失。</p>
<h2 id="2-堆（Heap）"><a href="#2-堆（Heap）" class="headerlink" title="2. 堆（Heap）"></a>2. 堆（Heap）</h2><p><strong>凡是 new 出来的<code>对象实例</code>，均存放在堆中</strong></p>
<p>堆内存里面的东西都有一个地址值：以 16 进制编写</p>
<p>堆内存里面的数据，都有默认值：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>整数</td>
<td>0</td>
</tr>
<tr>
<td>浮点数</td>
<td>0.0</td>
</tr>
<tr>
<td>字符</td>
<td>‘\u0000’</td>
</tr>
<tr>
<td>布尔</td>
<td>false</td>
</tr>
<tr>
<td>引用类型</td>
<td>null</td>
</tr>
</tbody></table>
<h2 id="3-方法区（Method-Area）"><a href="#3-方法区（Method-Area）" class="headerlink" title="3. 方法区（Method Area）"></a>3. 方法区（Method Area）</h2><p><strong>存储 <code>.class</code> 相关信息，包含<code>方法</code>的信息</strong></p>
<p>即为 JVM 加载的<strong>类</strong>、<strong>常量</strong>及<strong>静态变量</strong>等信息</p>
<h2 id="4-本地方法栈（Native-Method-Stack）"><a href="#4-本地方法栈（Native-Method-Stack）" class="headerlink" title="4. 本地方法栈（Native Method Stack）"></a>4. 本地方法栈（Native Method Stack）</h2><p><strong>与<code>操作系统</code>相关</strong></p>
<h2 id="5-寄存器（PC-Register）"><a href="#5-寄存器（PC-Register）" class="headerlink" title="5. 寄存器（PC Register）"></a>5. 寄存器（PC Register）</h2><p><strong>与<code>CPU</code>相关</strong></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>知识整理</category>
      </categories>
  </entry>
  <entry>
    <title>HTML基础知识</title>
    <url>/2020/05/30/2020530-HTML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>HTML的快速入门</p>
<span id="more"></span>

<h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a><strong>概念</strong>：</h2><p><strong>是最基础的网页开发语言</strong></p>
<ul>
<li>Hyper Text Markup Language 超文本标记语言<ul>
<li>超文本:<ul>
<li>超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本.</li>
</ul>
</li>
<li>标记语言:<ul>
<li>由标签构成的语言。&lt;标签名称&gt; 如 html，xml</li>
<li>标记语言不是编程语言</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="快速入门："><a href="#快速入门：" class="headerlink" title="快速入门："></a>快速入门：</h2><ul>
<li>语法：<ol>
<li>html文档后缀名 .html 或者 .htm</li>
<li>标签分为<ol>
<li><strong>围堵</strong>标签：有开始标签和结束标签。如 &lt;html&gt; &lt;/html&gt;</li>
<li><strong>自闭和</strong>标签：开始标签和结束标签在一起。如</li>
</ol>
</li>
<li>标签可以嵌套： 需要正确嵌套，不能你中有我，我中有你<br>错误：&lt;b&gt;&lt;/b&gt; 正确：&lt;b&gt;&lt;/b&gt;</li>
<li>在开始标签中可以定义属性。<br>属性是由键值对构成，值需要用引号(单双都可)引起</li>
<li>html的标签不区分大小写，但是建议使用小写。</li>
</ol>
</li>
<li>代码：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">FONT</span> <span class="attr">color</span>=<span class="string">&#x27;red&#x27;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&#x27;green&#x27;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="标签学习："><a href="#标签学习：" class="headerlink" title="标签学习："></a>标签学习：</h2><ol>
<li><p>文件标签</p>
<p>：构成html最基本的标签</p>
<ul>
<li>html:html文档的根标签</li>
<li>head：头标签。用于指定html文档的一些属性。引入外部的资源</li>
<li>title：标题标签。</li>
<li>body：体标签</li>
<li><? DOCTYPE html>：html5中定义该文档是html文档</li>
</ul>
</li>
<li><p>文本标签</p>
<p>：和文本有关的标签</p>
<ul>
<li>注释：&lt;!– 注释内容 –&gt;</li>
<li>&lt;h1&gt; ~ &lt;h6&gt;：标题标签  h1~h6:字体大小逐渐递减</li>
<li>&lt;p&gt;：段落标签</li>
<li>&lt;br&gt;：换行标签</li>
<li>&lt;hr&gt;：展示一条水平线<br> * 属性：<pre><code>        \* color：颜色 
        \* width：宽度 
        \* size：高度 
        \* align：对其方式
        \* center：居中 
        \* left：左对齐 
        \* right：右对齐​
</code></pre>
</li>
<li>&lt;b&gt;：字体加粗</li>
<li>&lt;i&gt;：字体斜体</li>
<li>&lt;font&gt;:字体标签</li>
<li>&lt;center&gt;:文本居中<br>* 属性： <pre><code>\* color：颜色 
\* size：大小 
\* face：字体​
</code></pre>
</li>
<li>属性定义：<ul>
<li>color：<ol>
<li>英文单词：red,green,blue</li>
<li>rgb(值1，值2，值3)：值的范围：0~255 如 rgb(0,0,255)</li>
<li>#值1值2值3：值的范围：00~FF(十六进制)之间。如： #FF00FF</li>
</ol>
</li>
<li>width：<ol>
<li>数值：width=’20’ ,数值的单位，默认是 px(像素)</li>
<li>数值%：占比相对于父元素的比例</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>图片标签：</p>
<ul>
<li>img：展示图片<ul>
<li>属性：<ul>
<li>src：指定图片的位置</li>
</ul>
</li>
<li>代码： &lt;!–展示一张图片 img–&gt;<br>&lt;!– 相对路径 <pre><code>  \* 以.开头的路径 ：
  \* ./：代表当前目录
  \* ../:代表上一级目录 --&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>列表标签：</p>
<ul>
<li>有序列表：&lt;ol&gt;&lt;li&gt;内容&lt;li&gt;&lt;/ol&gt;</li>
<li>无序列表：&lt;ul&gt;&lt;li&gt;内容&lt;li&gt;&lt;/ul&gt;</li>
</ul>
</li>
<li><p>链接标签：</p>
<ul>
<li>&lt;a&gt;:定义一个超链接</li>
</ul>
</li>
<li><p>div和span：</p>
<ul>
<li>div: 每一个div占满一整行（有换行）。块级标签</li>
<li>span: 文本信息在一行展示（无换行）。行内标签 内联标签</li>
</ul>
</li>
<li><p>语义化标签：</p>
<p> html5中为了提高程序的可读性，提供了一些标签。</p>
<ol>
<li>：&lt;header&gt;页眉</li>
<li>：&lt;footer&gt;页脚</li>
</ol>
</li>
<li><p>表格标签：</p>
<ul>
<li><p>table：定义表格</p>
<ul>
<li><p>width：宽度</p>
</li>
<li><p>border：边框</p>
</li>
<li><p>cellpadding：定义内容和单元格的距离</p>
</li>
<li><p>cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、</p>
</li>
<li><p>bgcolor：背景色</p>
</li>
<li><p>align：对齐方式</p>
</li>
</ul>
</li>
<li><p>tr：定义行</p>
<ul>
<li>bgcolor：背景色</li>
<li>align：对齐方式</li>
</ul>
</li>
<li><p>td：定义单元格</p>
<ul>
<li>colspan：合并列</li>
<li>rowspan：合并行</li>
</ul>
</li>
<li><p>th：定义表头单元格</p>
</li>
<li><p>&lt;caption&gt;：表格标题</p>
</li>
<li><p>&lt;thead&gt;：表示表格的头部分</p>
</li>
<li><p>&lt;tbody&gt;：表示表格的体部分</p>
</li>
<li><p>&lt;tfoot&gt;：表示表格的脚部分</p>
</li>
</ul>
</li>
<li><p><strong>表单标签</strong></p>
</li>
</ol>
<ul>
<li><p>表单：</p>
<ul>
<li><p>概念：用于<strong>采集用户输入的数据</strong>。用于和服务器进行交互。</p>
</li>
<li><p>form：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围</p>
<ul>
<li><p>属性：</p>
<ul>
<li><p>action：指定提交数据的URL</p>
</li>
<li><p>method: 指定提交方式</p>
<ul>
<li><p>分类：一共7种，2种比较常用</p>
</li>
<li><p>get：</p>
<ol>
<li><p>请求参数会在地址栏中<strong>显示</strong>。会封装到请求行中(HTTP协议后讲解)。</p>
</li>
<li><p>请求参数大小是有限制的。</p>
</li>
<li><p><strong>不太安全</strong>。</p>
</li>
</ol>
</li>
<li><p>post：</p>
<ol>
<li><p>请求参数不会再地址栏中显示。会<strong>封装</strong>在请求体中(HTTP协议后讲解)</p>
</li>
<li><p>请求参数的大小没有限制。</p>
</li>
<li><p>较为<strong>安全</strong>。</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>表单项中的数据要想被提交：<strong>必须指定其name属性</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>表单项标签：<br>* input：可以通过type属性值，改变元素展示的样式</p>
<pre><code>    \* type属性：
                 \* text：文本输入框，默认值
                           \* placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息
                 \* password：密码输入框
                 \* radio:单选框
                 \* checkbox：复选框
</code></pre>
<p>* 注意：</p>
<ol>
<li><p>要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。</p>
</li>
<li><p>一般会给每一个单选框提供value属性，指定其被选中后提交的值</p>
</li>
<li><p>checked属性，可以指定默认值<br>* checkbox：复选框<br>* 注意：</p>
</li>
<li><p>一般会给每一个单选框提供value属性，指定其被选中后提交的值</p>
</li>
<li><p>checked属性，可以指定默认值<br><code>* file：文件选择框 </code><br><code>* hidden：隐藏域，用于提交一些信息。 </code><br><code>* 按钮： </code></p>
<pre><code>           `* submit：提交按钮。可以提交表单 `
           `* button：普通按钮 `
</code></pre>
<p><code>* image：图片提交按钮 </code></p>
<pre><code>           `* src属性指定图片的路径 `
</code></pre>
<p><code>* label：指定输入项的文字描述信息 </code></p>
<pre><code>           `* 注意： * label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。 `
</code></pre>
<p><code>* select: 下拉列表 </code></p>
<pre><code>            `* 子元素：option，指定列表项 `
</code></pre>
<p><code>* textarea：文本域 </code></p>
<pre><code>           `* cols：指定列数，每一行有多少个字符 `
           `* rows：默认多少行。`
</code></pre>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title>数据库中的事务</title>
    <url>/2020/06/26/2020626-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>有关事务的四大特性(ACID)，以及隔离级别</p>
<span id="more"></span>

<h2 id="1、事务是什么"><a href="#1、事务是什么" class="headerlink" title="1、事务是什么"></a>1、事务是什么</h2><p>​    事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。</p>
<h2 id="2、事务的四大特性（ACID）"><a href="#2、事务的四大特性（ACID）" class="headerlink" title="2、事务的四大特性（ACID）"></a>2、事务的四大特性（ACID）</h2><p>   数据库事务 transaction 正确执行的四个基本要素。ACID,原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)。</p>
<p>   （1）<strong>原子性</strong>：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。<br>   （2）<strong>一致性</strong>：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。<br>   （3）<strong>隔离性</strong>：隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，  必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。<br>   （4）<strong>持久性</strong>：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p>
<h2 id="3-不考虑隔离性会产生的-3-个问题"><a href="#3-不考虑隔离性会产生的-3-个问题" class="headerlink" title="3.不考虑隔离性会产生的 3 个问题"></a>3.不考虑隔离性会产生的 3 个问题</h2><p>1）脏读：读取了<strong>未提交</strong>的新数据，然后新数据如果被回滚了，则读取了错误的不存在的数据。</p>
<p>2）不可重复读：在读取的过程中，一个事务范围内多次查询却返回了不同的数据值，因为被其他的事务所<strong>修改并提交</strong>了。</p>
<p>不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</p>
<p>3）幻读：在读取的过程中，被其他事务对数据进行了<strong>新增</strong>操作，导致多次读取返回值不一致。</p>
<p><strong>幻读和不可重复读的区别</strong>在于，不可重复是针对记录的 update 操作，只要在记录上加写锁，就可避免；幻读是对记录的 insert 操作，要禁止幻读必须加上全局的写锁(比如在表上加写锁)。</p>
<h2 id="4-事务的四个隔离级别"><a href="#4-事务的四个隔离级别" class="headerlink" title="4.事务的四个隔离级别"></a>4.事务的四个隔离级别</h2><p><strong>（从低到高，安全性和耗能增加）</strong></p>
<p><strong>第一类事务丢失：（称为回滚丢失）</strong>A 回滚了 B 读的数据</p>
<p><strong>第二类事务丢失：（提交覆盖丢失）</strong>A 覆盖了 B 写的数据</p>
<p><strong>1） 未提交读(Read uncommitted)。 （写加锁，读不加锁）</strong><br>写操作加写锁，读操作不加读锁。禁止第一类丢失更新，但是会出现所有其他数据并发问题。</p>
<p><strong>2）提交读(Read committed)。（写加锁，读加锁）</strong></p>
<p>写操作加写锁，读操作加读锁。禁止第一类丢失更新和脏读。</p>
<p>就是你已经开始读了数据，然后一个事务开始写，然后写的事务不提交的话，是不能进行读的事务，避免了脏读。</p>
<p><strong>3）可重复读(Read repeatable)。（写加锁，读加锁）</strong><br>对于读操作加读锁到<strong>事务结束</strong>，其他事务的更新操作只能等到事务结束之后进行。</p>
<p><strong>这是大部分关系数据库的默认隔离级别。</strong></p>
<p>和提交读的区别在于，提交读的读操作是加读锁到本次读操作结束，可重复读的锁粒度(一个锁实例所保护的共享数据的数量大小就称为该锁的粒度（Granularity))更大。禁止两类丢失更新，禁止脏读和不可 重复度，但是可能出现幻读。</p>
<p>一个事物读的时候，我们把两次读看成整体，在读的过程中，不允许写的操作，这样就可以禁止不可重复读。就是两次读操作不允许其他事物事务。</p>
<p><strong>4）序列化(Serializable)。（对表级的读写加锁）</strong></p>
<p>读操作加<strong>表级读写锁</strong>至事务结束。可以禁止幻读。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>黑马旅游网（案例）</title>
    <url>/2020/06/24/2020624-%E9%BB%91%E9%A9%AC%E6%97%85%E6%B8%B8%E7%BD%91%EF%BC%88%E6%A1%88%E4%BE%8B%EF%BC%89/</url>
    <content><![CDATA[<p>基于 tomcat 的简单 JavaWeb 项目(学习用)</p>
<span id="more"></span>

<h2 id="一、前期准备工作（环境搭建）"><a href="#一、前期准备工作（环境搭建）" class="headerlink" title="一、前期准备工作（环境搭建）"></a>一、前期准备工作（环境搭建）</h2><h3 id="1-导入已有maven项目"><a href="#1-导入已有maven项目" class="headerlink" title="1.导入已有maven项目"></a>1.导入已有maven项目</h3><p><img src="/images/hmTravel/hmTravel1.png" alt="image-20200619084400775"></p>
<p><img src="/images/hmTravel/hmTravel2.png" alt="image-20200619084434510"></p>
<p><img src="/images/hmTravel/hmTravel3.png" alt="image-20200619084526823"></p>
<ul>
<li>如果依赖部分导入失败可以使用本地 jar 包导入</li>
</ul>
<p>右键项目名称，打开如下 OMS</p>
<p><img src="/images/hmTravel/hmTravel4.png" alt="image-20200619084649260"></p>
<p>将 jar 包移入对应本地仓库</p>
<p><img src="/images/hmTravel/hmTravel5.png" alt="image-20200619084841084"></p>
<p>出现资源载入错误：</p>
<p>引入bootstrap..min.css的时候出现了URL：bootstrap.min.css.map 404的错误。</p>
<p>解决方法： 将bootstrap.min.css里的最后一行 /*#sourceMappingURL=bootstrap.min.css.map */删除即可</p>
<p>把chorme文件的工具–&gt;开发者工具–&gt;设置–&gt;Enable source maps勾去掉，去掉这个勾，jquery就不会去下载source map文件了！</p>
<h3 id="2-配置tomcat启动方式"><a href="#2-配置tomcat启动方式" class="headerlink" title="2.配置tomcat启动方式"></a>2.配置tomcat启动方式</h3><p><img src="/images/hmTravel/tomcatConf1.png" alt="image-20200619085624762"></p>
<p><img src="/images/hmTravel/tomcatConf2.png" alt="image-20200619085649754"></p>
<p><img src="/images/hmTravel/tomcatConf3.png" alt="image-20200619085709027"></p>
<p>配置完成后，就可以不通过右侧的 maven 点击 plugins 的 tomcat7:run 来启动tomcat服务。右上角可以直接启动 tomcat7:run 。</p>
<p><img src="/images/hmTravel/tomcatConf4.png" alt="image-20200619085847305"></p>
<p>异常一：</p>
<p><img src="/images/hmTravel/tomcatException1.png" alt="image-20200619181104638"></p>
<p>原因：</p>
<p>未指定plugin版本号</p>
<p>解决：</p>
<p>增加一行<version>x.x.x</version>即可</p>
<p>异常二：</p>
<p><img src="/images/hmTravel/tomcatException2.png" alt="image-20200619181256487"></p>
<p>原因：</p>
<p>未指定编码方式</p>
<p>解决：</p>
<p>在pom.xml文件中添加 <code>&lt;properties&gt;</code> <code>&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;</code></p>
<h3 id="3-所用技术"><a href="#3-所用技术" class="headerlink" title="3.所用技术"></a>3.所用技术</h3><h4 id="1）-Web层"><a href="#1）-Web层" class="headerlink" title="1） Web层"></a>1） Web层</h4><p>a) Servlet：前端控制器</p>
<p>b) html：视图</p>
<p>c) Filter：过滤器</p>
<p>d) BeanUtils：数据封装</p>
<p>e) Jackson：json序列化工具</p>
<h4 id="2）-service层"><a href="#2）-service层" class="headerlink" title="2） service层"></a>2） service层</h4><p>f) Javamail：java发送邮件工具</p>
<p>g) Redis：nosql内存数据库</p>
<p>h) Jedis：java的redis客户端</p>
<h4 id="3）-Dao层"><a href="#3）-Dao层" class="headerlink" title="3） Dao层"></a>3） Dao层</h4><p>i) Mysql：数据库</p>
<p>j) Druid：数据库连接池</p>
<p>k)JdbcTemplate：jdbc的工具</p>
<h3 id="4-创建数据库"><a href="#4-创建数据库" class="headerlink" title="4.创建数据库"></a>4.创建数据库</h3><p><img src="/images/hmTravel/dbTravel1.png" alt="image-20200619092747729"></p>
<p>tab_user：</p>
<p><img src="/images/hmTravel/dbTravel2.png" alt="image-20200619092853537"></p>
<h2 id="二、功能实现"><a href="#二、功能实现" class="headerlink" title="二、功能实现"></a>二、功能实现</h2><h3 id="1-注册功能"><a href="#1-注册功能" class="headerlink" title="1.注册功能"></a>1.注册功能</h3><h4 id="基本注册"><a href="#基本注册" class="headerlink" title="基本注册"></a>基本注册</h4><p><img src="/images/hmTravel/register1.png" alt="image-20200619095200842"></p>
<p>导入数据库失败，检查JDBCUtils工具类的properties的路径是否正确</p>
<p><img src="/images/hmTravel/register2.png" alt="image-20200619220726172"></p>
<h4 id="邮箱认证激活"><a href="#邮箱认证激活" class="headerlink" title="邮箱认证激活"></a>邮箱认证激活</h4><p><img src="/images/hmTravel/mailActive1.png" alt="image-20200619222039161"></p>
<p>发送认证邮件的配置：</p>
<p>USER是发件人的邮箱地址；PASSWORD是授权码，不是登录密码；</p>
<p><img src="/images/hmTravel/mailActive2.png" alt="image-20200619220838419"></p>
<p><img src="/images/hmTravel/mailActive3.png" alt="image-20200619220938541"></p>
<p>收件人的邮箱地址:</p>
<p><img src="/images/hmTravel/mailActive4.png" alt="image-20200619221025469"></p>
<h3 id="2-登录功能"><a href="#2-登录功能" class="headerlink" title="2.登录功能"></a>2.登录功能</h3><p><img src="/images/hmTravel/login1.png" alt="image-20200620105756465"></p>
<p>通过登录界面提供的数据，在数据库中查找对应的数据，如果找到，则将数据存在session中，并通过session在登录界面展示姓名</p>
<p><img src="/images/hmTravel/login2.png" alt="image-20200620110022489"></p>
<p><img src="/images/hmTravel/login3.png" alt="image-20200620105947460"></p>
<p><img src="/images/hmTravel/login4.png" alt="img"></p>
<p><img src="/images/hmTravel/login5.png" alt="image-20200620110131191"></p>
<p><img src="/images/hmTravel/login6.png" alt="image-20200620110157059"></p>
<p><img src="/images/hmTravel/login7.png" alt="image-20200620110230663"></p>
<p><img src="/images/hmTravel/login8.png" alt="image-20200620110308011"></p>
<p><img src="/images/hmTravel/login9.png" alt="image-20200620110332755"></p>
<h3 id="3-退出功能"><a href="#3-退出功能" class="headerlink" title="3.退出功能"></a>3.退出功能</h3><p>点击退出，调用exitServlet销毁session记录，重定向到登陆界面</p>
<p><img src="/images/hmTravel/logout1.png" alt="image-20200620112050048"></p>
<p><img src="/images/hmTravel/logout2.png" alt="image-20200620112108194"></p>
<h3 id="4-优化Servlet"><a href="#4-优化Servlet" class="headerlink" title="4.优化Servlet"></a>4.优化Servlet</h3><p>将不同功能但是同一类别的servlet放在同一个servlet中，较少servlet的数量</p>
<p><img src="/images/hmTravel/servlet.png" alt="image-20200620150505337"></p>
<h3 id="5-分类栏功能"><a href="#5-分类栏功能" class="headerlink" title="5.分类栏功能"></a>5.分类栏功能</h3><p><img src="/images/hmTravel/category.png" alt="image-20200620211341003"></p>
<p>使用template从数据库读取数据，写入html页面</p>
<p>小问题：</p>
<p>分类的内容不经常改变，所以可以存在缓存中，这样每次页面加载时就不会再次发出请求。减少加载时间的消耗和数据库的压力。</p>
<p>解决方法：</p>
<p>通过jedis使用redis</p>
<p><img src="/images/hmTravel/category2.png" alt="image-20200620221543104"></p>
<p><img src="/images/hmTravel/category3.png" alt="image-20200620223700926"></p>
<p>要和服务器一起启动redis程序</p>
<p><img src="/images/hmTravel/category4.png" alt="image-20200620223922760"></p>
<p><img src="/images/hmTravel/category5.png" alt="image-20200620223827928"></p>
<h3 id="6-分页展示功能"><a href="#6-分页展示功能" class="headerlink" title="6.分页展示功能"></a>6.分页展示功能</h3><p>分类和线路是一对多的关系，一个类别下有多个线路。</p>
<p><img src="/images/hmTravel/page1.png" alt="image-20200621085917484"></p>
<p>利用分类和线路共有的cid，实现分类</p>
<p><img src="/images/hmTravel/page2.png" alt="image-20200621093955475"></p>
<p><img src="/images/hmTravel/page3.png" alt="image-20200621094011588"></p>
<h3 id="7-查询功能"><a href="#7-查询功能" class="headerlink" title="7.查询功能"></a>7.查询功能</h3><p>更改sql语句查询方式，如果没有查询条件就查询全部</p>
<p><img src="/images/hmTravel/query1.png" alt="image-20200621172802357"></p>
<p>利用拼接的方式</p>
<p>在html页面的load函数，以及每次调用函数都要添加查询条件参数rname</p>
<p><img src="/images/hmTravel/query2.png" alt="image-20200621174116495"></p>
<p><img src="/images/hmTravel/query3.png" alt="image-20200621174146362"></p>
<h3 id="8-线路详情功能"><a href="#8-线路详情功能" class="headerlink" title="8.线路详情功能"></a>8.线路详情功能</h3><p><img src="/images/hmTravel/route1.png" alt="image-20200622091824618"></p>
<p><img src="/images/hmTravel/route2.png" alt="image-20200622091829391"></p>
<p>查询一个完整的route对象，有三部分，自身的route对象，img对象，seller对象。分别使用三个对象对应的dao查询并返回给service，再返回给servlet，最终到html。</p>
<h3 id="9-收藏功能"><a href="#9-收藏功能" class="headerlink" title="9.收藏功能"></a>9.收藏功能</h3><h4 id="判断收藏状态"><a href="#判断收藏状态" class="headerlink" title="判断收藏状态"></a>判断收藏状态</h4><p><img src="/images/hmTravel/favo1.png" alt="image-20200622203734332"></p>
<p><img src="/images/hmTravel/favo2.png" alt="image-20200622203804745"></p>
<p>根据收藏与否，改变html上收藏按钮的样式</p>
<h4 id="添加收藏"><a href="#添加收藏" class="headerlink" title="添加收藏"></a>添加收藏</h4><p><img src="/images/hmTravel/favo3.png" alt="img"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>案例</category>
      </categories>
  </entry>
  <entry>
    <title>CSS基础知识</title>
    <url>/2020/06/04/202064-CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>CSS基础入门</p>
<span id="more"></span>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>美化HTML页面</p>
<p>多个样式可以作用在同一个HTML的元素上，同时生效</p>
<p><strong>好处：</strong></p>
<ol>
<li>功能强大</li>
<li>将内容展示和样式控制分离<ul>
<li>降低耦合度 —— 解耦</li>
<li>让分工协作更容易</li>
<li>提高开发效率</li>
</ul>
</li>
</ol>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li>内联样式<ul>
<li>在标签内使用style属性指定css代码</li>
<li>eg：</li>
</ul>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> style=&quot;<span class="attribute">color</span>:red;&quot;&gt;hello css&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>内部样式<ul>
<li>在head标签内，定义style标签，style标签的标签体内容就是css代码</li>
<li>eg：</li>
</ul>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">       <span class="selector-tag">div</span>&#123;</span><br><span class="line">           <span class="attribute">color</span>:blue;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">   &lt;<span class="selector-tag">div</span>&gt;hello css&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>外部样式<ol>
<li>定义 css 资源文件。</li>
<li>在 head 标签内，定义 link 标签，引入外部的资源文件。eg：<ul>
<li>a.css文件：</li>
</ul>
</li>
</ol>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:green;</span><br><span class="line">&#125;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;css/<span class="selector-tag">a</span><span class="selector-class">.css</span>&quot;&gt; &lt;<span class="selector-tag">div</span>&gt;hello css&lt;/<span class="selector-tag">div</span>&gt; </span><br><span class="line">&lt;!--也可以写为：--&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line"> <span class="keyword">@import</span> <span class="string">&quot;css/a.css&quot;</span>;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li><p>格式：<br>选择器{ </p>
<pre><code>    属性名 1 ：属性值 1 ； 
    属性名 2 ：属性值 2 ；
     . . .
</code></pre>
<p>}</p>
</li>
<li><p>注意： 每一对属性都用 ； 分开，最后一对不用</p>
</li>
</ul>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p><strong>筛选具有相似特征的元素</strong></p>
<ul>
<li>分类：</li>
</ul>
<ol>
<li>基础选择器<ol>
<li>id 选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一<ul>
<li>语法：#id属性值{}</li>
</ul>
</li>
<li>元素选择器：选择具有相同标签名称的元素<ul>
<li>语法： 标签名称{}</li>
<li>注意：id选择器优先级高于元素选择器</li>
</ul>
</li>
<li>类选择器：选择具有相同的class属性值的元素。<ul>
<li>语法：.class属性值{}</li>
<li>注意：类选择器选择器优先级高于元素选择器</li>
</ul>
</li>
</ol>
</li>
<li>扩展选择器<ol>
<li>选择所有元素：<ul>
<li>语法： *{}</li>
</ul>
</li>
<li>并集选择器：<ul>
<li>选择器1,选择器2{}</li>
</ul>
</li>
<li>子选择器：筛选选择器1元素下的选择器2元素<ul>
<li>语法： 选择器1 选择器2{}</li>
</ul>
</li>
<li>父选择器：筛选选择器2的父元素选择器1<ul>
<li>语法： 选择器1 &gt; 选择器2{}</li>
</ul>
</li>
<li>属性选择器：选择元素名称，属性名=属性值的元素<ul>
<li>语法： 元素名称[属性名=”属性值”]{}</li>
</ul>
</li>
<li>伪类选择器：选择一些元素具有的状态<ul>
<li>语法： 元素:状态{}</li>
<li>如： <a><ul>
<li>状态：<ul>
<li>link：初始化的状态</li>
<li>visited：被访问过的状态</li>
<li>active：正在访问状态</li>
<li>hover：鼠标悬浮状态</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ol>
<li>字体、文本<ul>
<li>font-size：字体大小<ul>
<li>color：文本颜色</li>
<li>text-align：对其方式</li>
<li>line-height：行高</li>
</ul>
</li>
</ul>
</li>
<li>背景<ul>
<li>background：设置背景样式属性等</li>
</ul>
</li>
<li>边框<ul>
<li>border：设置边框，符合属性</li>
</ul>
</li>
<li>尺寸<ul>
<li>width：宽度</li>
<li>height：高度</li>
</ul>
</li>
<li>盒子模型：控制布局<ul>
<li>margin：外边距</li>
<li>padding：内边距<ul>
<li>默认情况下内边距会影响整个盒子的大小</li>
<li>box-sizing: border-box; 设置盒子的属性，让width和height就是最终盒子的大小</li>
</ul>
</li>
<li>float：浮动<ul>
<li>left</li>
<li>right</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript基础</title>
    <url>/2020/06/12/2020612-JavaScript%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>JavaScript是一种用来开发Web页面的脚本语言</p>
<span id="more"></span>

<h2 id="概念：-一门客户端脚本语言"><a href="#概念：-一门客户端脚本语言" class="headerlink" title="概念： 一门客户端脚本语言"></a>概念： 一门客户端脚本语言</h2><ul>
<li>运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎</li>
<li>脚本语言：不需要编译，直接就可以被浏览器解析执行了</li>
</ul>
<h2 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h2><ul>
<li>可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。</li>
</ul>
<h2 id="ECMAScript：客户端脚本语言的标准"><a href="#ECMAScript：客户端脚本语言的标准" class="headerlink" title="ECMAScript：客户端脚本语言的标准"></a>ECMAScript：客户端脚本语言的标准</h2><ol>
<li><p>基本语法：</p>
<ol>
<li><p>与html结合方式</p>
<ol>
<li>内部JS：<ul>
<li>定义&lt;script&gt;，标签体内容就是js代码</li>
</ul>
</li>
<li>外部JS：<ul>
<li>定义&lt;script&gt;，通过src属性引入外部的js文件</li>
</ul>
</li>
</ol>
<ul>
<li>注意：<ol>
<li>&lt;script&gt;可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。</li>
<li>&lt;script&gt;可以定义多个。</li>
</ol>
</li>
</ul>
</li>
<li><p>数据类型：</p>
<ol>
<li>原始数据类型(基本数据类型)：<ol>
<li>number：数字。 整数/小数/NaN(not a number 一个不是数字的数字类型)</li>
<li>string：字符串。 字符串 “abc” “a” ‘abc’</li>
<li>boolean: true和false</li>
<li>null：一个对象为空的占位符</li>
<li>undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined</li>
</ol>
</li>
<li>引用数据类型：对象</li>
</ol>
</li>
<li><p>变量</p>
<ul>
<li>变量：一小块存储数据的内存空间</li>
<li>Java语言是强类型语言，而JavaScript是弱类型语言。<ul>
<li>强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据</li>
<li>弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放<strong>任意类型的数据</strong>。</li>
</ul>
</li>
<li>语法：<ul>
<li>var 变量名 = 初始化值;</li>
</ul>
</li>
<li>typeof 运算符：获取变量的类型。<ul>
<li>注：null运算后得到的是object</li>
</ul>
</li>
</ul>
</li>
<li><p>运算符</p>
<ol>
<li><p>一元运算符：只有一个运算数的运算符</p>
<ul>
<li>++ –: 自增(自减)<ul>
<li>++(–) 在前，先自增(自减)，再运算</li>
<li>++(–) 在后，先运算，再自增(自减)</li>
</ul>
</li>
<li>+(-)：正负号</li>
<li>注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换<ul>
<li>其他类型转number：<ul>
<li>string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字）</li>
<li>boolean转number：true转为1，false转为0</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>算数运算符**” + - * / % …”**</p>
</li>
<li><p>赋值运算符 <strong>“ = += -= ….”</strong></p>
</li>
<li><p>比较运算符</p>
<p>“ &lt; &gt;= &lt;= == ===(全等于)”</p>
<ul>
<li>比较方式<ol>
<li>类型相同：直接比较<ul>
<li>字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。<ol>
<li>类型不同：先进行类型转换，再比较</li>
</ol>
</li>
<li><strong>===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false</strong></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>逻辑运算符&amp;&amp; || ！</p>
<ul>
<li>其他类型转 boolean ：<ol>
<li>number：0或NaN为假，其他为真</li>
<li>string：除了空字符串(“”)，其他都是true</li>
<li>null&amp;undefined:都是false<ol>
<li>对象：所有对象都为true</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li><p>流程控制语句 都与 Java 类似，其中 switch 语句可以接受任意的原始数据类型</p>
</li>
<li><p>JS特殊语法：</p>
<ol>
<li>语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议)<ol>
<li>变量的定义使用var关键字，也可以不使用<ul>
<li>用： 定义的变量是局部变量</li>
<li>不用：定义的变量是全局变量(不建议)</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="基本对象"><a href="#基本对象" class="headerlink" title="基本对象"></a>基本对象</h2><h3 id="Function：函数-方法-对象"><a href="#Function：函数-方法-对象" class="headerlink" title="Function：函数(方法)对象"></a>Function：函数(方法)对象</h3><ol>
<li>创建：<ol>
<li>var fun = new Function(形式参数列表,方法体); //忘掉吧</li>
<li>function 方法名称(形式参数列表){ 方法体 }<ol start="3">
<li>var 方法名 = function(形式参数列表){<pre><code>      方法体
</code></pre>
   }</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>2.特点：</p>
<ol>
<li>方法定义是，形参的类型不用写,返回值类型也不写。 果定义名称相同的方法，会覆盖<ol>
<li>在JS中，方法的调用只与方法的名称有关，和参数列表无关 隐藏的内置对象（数组），arguments,封装所有的实际参数</li>
</ol>
</li>
</ol>
<h3 id="Array-数组对象"><a href="#Array-数组对象" class="headerlink" title="Array:数组对象"></a>Array:数组对象</h3><ol>
<li>创建：<ol>
<li>var arr = new Array(元素列表);</li>
<li>var arr = new Array(默认长度);</li>
<li>var arr = [元素列表];</li>
</ol>
</li>
<li>方法 join(参数):将数组中的元素按照指定的分隔符拼接为字符串 push() 向数组的末尾添加一个或更多元素，并返回新的长度。</li>
<li>属性 length:数组的长度</li>
<li>特点：<ol>
<li>JS中，数组元素的类型可变的。</li>
<li>JS中，数组长度可变的。</li>
</ol>
</li>
</ol>
<h3 id="Date：日期对象"><a href="#Date：日期对象" class="headerlink" title="Date：日期对象"></a>Date：日期对象</h3><ol>
<li><p>创建： var date = new Date();</p>
</li>
<li><p>方法：<br> toLocaleString()：返回当前date对象对应的时间本地字符串格式<br> getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差</p>
</li>
</ol>
<h3 id="Math：数学对象"><a href="#Math：数学对象" class="headerlink" title="Math：数学对象"></a>Math：数学对象</h3><ol>
<li><p>创建：</p>
<ul>
<li>特点：Math对象不用创建，直接使用。 Math.方法名();</li>
</ul>
</li>
<li><p>方法：<br> random():返回 0 ~ 1 之间的随机数。 含0不含1<br> ceil(x)：对数进行上舍入。<br> floor(x)：对数进行下舍入。<br> round(x)：把数四舍五入为最接近的整数。</p>
</li>
<li><p>属性：<br> PI</p>
</li>
</ol>
<h3 id="RegExp：正则表达式对象"><a href="#RegExp：正则表达式对象" class="headerlink" title="RegExp：正则表达式对象"></a>RegExp：正则表达式对象</h3><ol>
<li><p>正则表达式：定义字符串的组成规则。 </p>
<ol>
<li>单个字符:[] 如： [a] [ab] [a-zA-Z0-9*] * 特殊符号代表特殊含义的单个字符: \d:单个数字字符 [0-9] \w:单个单词字符[a-zA-Z0-9*] </li>
<li> 量词符号： ?：表示出现0次或1次 *：表示出现0次或多次 +：出现1次或多次 {m,n}:表示 m&lt;= 数量 &lt;= n * m如果缺省： {,n}:最多n次 * n如果缺省：{m,} 最少m次 </li>
<li> 开始结束符号 * ^:开始 * $:结束</li>
</ol>
</li>
<li><p>正则对象：</p>
<ol>
<li>创建<ol>
<li>var reg = new RegExp(“正则表达式”);</li>
<li>var reg = /正则表达式/;</li>
</ol>
</li>
<li>方法<ol>
<li>test(参数):验证指定的字符串是否符合正则定义的规范</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Global-全局对象"><a href="#Global-全局对象" class="headerlink" title="Global: 全局对象"></a>Global: 全局对象</h3><ol>
<li>特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。 方法名();</li>
<li>方法：<br>encodeURI():url编码<br>decodeURI():url解码<br>encodeURIComponent():url编码,编码的字符更多<br>decodeURIComponent():url解码<br>parseInt():将字符串转为数字 * 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number<br>isNaN():判断一个值是否是NaN * NaN六亲不认，连自己都不认。NaN参与的==比较全部问false<br>eval():将 JavaScript 字符串，并把它作为脚本代码来执行。</li>
<li>URL编码 传智播客 = %E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2</li>
</ol>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM:"></a>BOM:</h2><ol>
<li>概念：Browser Object Model 浏览器对象模型<ul>
<li>将浏览器的<strong>各个组成部分封装成对象</strong>。</li>
</ul>
</li>
<li>组成：<ul>
<li>Window：窗口对象</li>
<li>Navigator：浏览器对象</li>
<li>Screen：显示器屏幕对象</li>
<li>History：历史记录对象</li>
<li>Location：地址栏对象</li>
</ul>
</li>
<li>Window：窗口对象<ol>
<li>创建</li>
<li>方法<ol>
<li>与弹出框有关的方法： alert() 显示带有一段消息和一个确认按钮的警告框。 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框。<ul>
<li>如果用户点击确定按钮，则方法返回true<ul>
<li>如果用户点击取消按钮，则方法返回false prompt() 显示可提示用户输入的对话框。<ul>
<li>返回值：获取用户输入的值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>与打开关闭有关的方法： close() 关闭浏览器窗口。<ul>
<li>谁调用我 ，我关谁 open() 打开一个新的浏览器窗口<ul>
<li>返回新的Window对象</li>
</ul>
</li>
</ul>
</li>
<li>与定时器有关的方式 setTimeout() 在指定的毫秒数后调用函数或计算表达式。<ul>
<li>参数：<ol>
<li>js代码或者方法对象</li>
<li>毫秒值<ul>
<li>返回值：唯一标识，用于取消定时器 clearTimeout() 取消由 setTimeout() 方法设置的 timeout。setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。 clearInterval() 取消由 setInterval() 设置的 timeout。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li>属性：<ol>
<li>获取其他BOM对象： history location Navigator Screen:</li>
<li>获取DOM对象 document</li>
</ol>
</li>
<li>特点<ul>
<li>Window对象不需要创建可以直接使用 window使用。 window.方法名();</li>
<li>window引用可以省略。 方法名();</li>
</ul>
</li>
</ol>
</li>
<li>Location：地址栏对象<ol>
<li>创建(获取)：<ol>
<li>window.location</li>
<li>location</li>
</ol>
</li>
<li>方法：<ul>
<li>reload() 重新加载当前文档。刷新</li>
</ul>
</li>
<li>属性<ul>
<li>href 设置或返回完整的 URL。</li>
</ul>
</li>
</ol>
</li>
<li>History：历史记录对象<ol>
<li>创建(获取)：<ol>
<li>window.history</li>
<li>history</li>
</ol>
</li>
<li>方法：<ul>
<li>back() 加载 history 列表中的前一个 URL。</li>
<li>forward() 加载 history 列表中的下一个 URL。</li>
<li>go(参数) 加载 history 列表中的某个具体页面。<ul>
<li>参数：<ul>
<li>正数：前进几个历史记录</li>
<li>负数：后退几个历史记录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>属性：<ul>
<li>length 返回当前窗口历史列表中的 URL 数量。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="DOM："><a href="#DOM：" class="headerlink" title="DOM："></a>DOM：</h2><ul>
<li><p>概念： Document Object Model 文档对象模型</p>
<ul>
<li>将<strong>标记语言文档的各个组成部分封装为对象</strong>。可以使用这些对象，对标记语言文档进行<strong>CRUD</strong>的动态操作</li>
</ul>
</li>
<li><p>W3C DOM 标准被分为 3 个不同的部分：</p>
<ul>
<li>核心 DOM - 针对任何结构化文档的标准模型<ul>
<li>Document：文档对象</li>
<li>Element：元素对象</li>
<li>Attribute：属性对象</li>
<li>Text：文本对象</li>
<li>Comment:注释对象</li>
<li>Node：节点对象，其他5个的父对象</li>
</ul>
</li>
<li>XML DOM - 针对 XML 文档的标准模型</li>
<li>HTML DOM - 针对 HTML 文档的标准模型</li>
</ul>
</li>
<li><p>核心DOM模型：</p>
<ul>
<li>Document：文档对象<ol>
<li>创建(获取)：在html dom模型中可以使用window对象来获取<ol>
<li>window.document</li>
<li>document</li>
</ol>
</li>
<li>方法：<ol>
<li>获取Element对象：<ol>
<li>getElementById() ： 根据id属性值获取元素对象。id属性值一般唯一</li>
<li>getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组</li>
<li>getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组</li>
<li>getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组</li>
</ol>
</li>
<li>创建其他DOM对象： createAttribute(name) createComment() createElement() createTextNode()</li>
</ol>
</li>
<li>属性</li>
</ol>
</li>
<li>Element：元素对象<ol>
<li>获取/创建：通过document来获取和创建</li>
<li>方法：<ol>
<li>removeAttribute()：删除属性</li>
<li>setAttribute()：设置属性</li>
</ol>
</li>
</ol>
</li>
<li>Node：节点对象，其他5个的父对象<ul>
<li>特点：所有dom对象都可以被认为是一个节点</li>
<li>方法：<ul>
<li>CRUD dom树：<ul>
<li>appendChild()：向节点的子节点列表的结尾添加新的子节点。</li>
<li>removeChild() ：删除（并返回）当前节点的指定子节点。</li>
<li>replaceChild()：用新节点替换一个子节点。</li>
</ul>
</li>
</ul>
</li>
<li>属性：<ul>
<li>parentNode 返回节点的父节点。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>HTML DOM</p>
<ol>
<li>标签体的设置和获取：innerHTML</li>
<li>使用html元素对象的属性</li>
<li>控制元素样式<ol>
<li>使用元素的style属性来设置 如： //修改样式方式1 div1.style.border = “1px solid red”; div1.style.width = “200px”; //font-size–&gt; fontSize div1.style.fontSize = “20px”;</li>
<li>提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="事件监听机制："><a href="#事件监听机制：" class="headerlink" title="事件监听机制："></a>事件监听机制：</h2><ul>
<li>概念：某些组件被执行了某些操作后，触发某些代码的执行<ul>
<li>事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了</li>
<li>事件源：组件。如： 按钮 文本输入框…</li>
<li>监听器：代码。</li>
<li>注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。</li>
</ul>
</li>
<li>常见的事件：<ol>
<li>点击事件：<ol>
<li>onclick：单击事件</li>
<li>ondblclick：双击事件</li>
</ol>
</li>
<li>焦点事件<ol>
<li>onblur：失去焦点</li>
<li>onfocus:  元素获得焦点。</li>
</ol>
</li>
<li>加载事件：<ol>
<li>onload：一张页面或一幅图像完成加载。</li>
</ol>
</li>
<li>鼠标事件：<ol>
<li>onmousedown 鼠标按钮被按下。</li>
<li>onmouseup 鼠标按键被松开。</li>
<li>onmousemove 鼠标被移动。</li>
<li>onmouseover 鼠标移到某元素之上。</li>
<li>onmouseout 鼠标从某元素移开。</li>
</ol>
</li>
<li>键盘事件：<ol>
<li>onkeydown 某个键盘按键被按下。<ol>
<li>onkeyup 某个键盘按键被松开。</li>
<li>onkeypress 某个键盘按键被按下并松开。</li>
</ol>
</li>
<li>选择和改变<ol>
<li>onchange 域的内容被改变。</li>
<li>onselect 文本被选中。</li>
</ol>
</li>
<li>表单事件：<ol>
<li>onsubmit 确认按钮被点击。</li>
<li>onreset 重置按钮被点击。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>MyBatis连接池</title>
    <url>/2020/07/11/2020711-MyBatis%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<p>MyBatis连接池配置说明</p>
<span id="more"></span>

<h2 id="1-分类"><a href="#1-分类" class="headerlink" title="1. 分类"></a>1. 分类</h2><p>UNPOOLED 不使用连接池的数据源</p>
<p>POOLED 使用连接池的数据源 （常用）</p>
<p>JNDI 使用 JNDI 实现的数据源</p>
<h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><p>在 SqlMapConfig.xml 中进行配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>MyBatis在初始化时，根据<dataSource>的 type属性来创建相应类型的的数据源DataSource,即:<br>type=”POOLED”: MyBatis 会创建 PooledDataSource 实例<br>type=”UNPOOLED” : MyBatis 会创建 UnpooledDataSource 实例<br>type=” JNDI”: MyBatis 会从 JNDI 服务上查找 DataSource 实例，然后返回使用</p>
<h2 id="3-动态SQL"><a href="#3-动态SQL" class="headerlink" title="3. 动态SQL"></a>3. 动态SQL</h2><ul>
<li><if>标签 判断条件是否成立，然后选择是否执行 sql 语句</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user &quot;</span>&gt;</span></span><br><span class="line">	select * from user where 1=1</span><br><span class="line">	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null and username != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">	and username like #&#123;username&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;address != null&quot;</span>&gt;</span></span><br><span class="line">    and address like #&#123;address&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意: <if>标签的test属性中写的是对象的属性名，如果是包装类的对象要使用OGNL表达式的写法。<br>另外要注意 where 1=1 的作用!</p>
<ul>
<li><where>标签 可以替代 where 1 = 1 的条件用法</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--根据用户信息查询--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user &quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--select * from user--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;defaultSql&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null and username != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">        and username like #&#123;username&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;address != null&quot;</span>&gt;</span></span><br><span class="line">        and address like #&#123;address&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span>	</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><foreach>标签 用来遍历集合以及它的属性</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--查询所有用户在 id 的集合之中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findInIds&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;queryvo&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--select * from user where id in (1,2,3,4,5);--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;defaultSql&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ids != null and ids.size() &gt; 0&quot;</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">open</span>=<span class="string">&quot;id in (&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">item</span>=<span class="string">&quot;uid&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            	#&#123;uid&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>SQL语句:<br>    select 字段 from user where id in (?)<br><foreach>标签用于遍历集合，它的属性:<br>    collection :代表要遍历的集合元素，注意编写时不要写#{}<br>    open:代表语句的开始部分<br>    close:代表结束部分</p>
<h2 id="4-抽取重复代码"><a href="#4-抽取重复代码" class="headerlink" title="4. 抽取重复代码"></a>4. 抽取重复代码</h2><p>使用 <sql></sql> 标签，将重复的语句写在其中，然后可以使用 <include></include> 加上 sql 标签的 id 使用。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--抽取重复的语句代码片段--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;defaultSql&quot;</span>&gt;</span></span><br><span class="line">	select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置查询所有操作--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引用--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;defaultSql&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
  </entry>
  <entry>
    <title>MyBatis多表查询之一对多</title>
    <url>/2020/07/14/2020714-MyBatis%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E4%B9%8B%E4%B8%80%E5%AF%B9%E5%A4%9A/</url>
    <content><![CDATA[<p>MyBatis实现简单的多表查询</p>
<span id="more"></span>

<p><img src="/images/MyBatis/user_account.png" alt="user_account"></p>
<h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><h3 id="定义账户信息的实体类"><a href="#定义账户信息的实体类" class="headerlink" title="定义账户信息的实体类"></a>定义账户信息的实体类</h3><p>用于存储数据库的账户信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> Integer uid;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line">    <span class="comment">//getter/setter</span></span><br><span class="line">    <span class="comment">//toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及 getter and setter 、toString 方法</p>
<h3 id="编写-Sql-语句"><a href="#编写-Sql-语句" class="headerlink" title="编写 Sql 语句"></a>编写 Sql 语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">	account.<span class="operator">*</span>,</span><br><span class="line">	user.username,</span><br><span class="line">	user.address</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	account,</span><br><span class="line">	<span class="keyword">user</span></span><br><span class="line"><span class="keyword">where</span> account.uid <span class="operator">=</span> user.id;</span><br></pre></td></tr></table></figure>

<h3 id="定义-AccountUser-类"><a href="#定义-AccountUser-类" class="headerlink" title="定义 AccountUser 类"></a>定义 AccountUser 类</h3><p>用于存储与账户对应的用户信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountUser</span> <span class="keyword">extends</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getUsername</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及 getter and setter 、toString 方法</p>
<h3 id="定义账户的持久层-Dao-接口"><a href="#定义账户的持久层-Dao-接口" class="headerlink" title="定义账户的持久层 Dao 接口"></a><strong>定义账户的持久层</strong> <strong>Dao</strong> <strong>接口</strong></h3><p>用于定义各种操作数据库的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询所有账户，同时获取账户的所属用户名称以及它的地址信息</span></span><br><span class="line">    <span class="function">List&lt;AccountUser&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义-AccountDao-xml-文件中的查询配置信息"><a href="#定义-AccountDao-xml-文件中的查询配置信息" class="headerlink" title="定义 AccountDao.xml 文件中的查询配置信息"></a>定义 <strong>AccountDao.xml</strong> <strong>文件中的查询配置信息</strong></h3><p>用于实现 Dao 中的具体方法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.dao.IAccountDao&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--配置查询所有操作--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;accountuser&quot;</span>&gt;</span></span><br><span class="line">    	select a.*,u.username,u.address from account a, user u where a.uid = u.id;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：上述  SQL 语句的查询结果包含了 User 以及 Account 的数据，所以返回值类型就设置成 accountuser</p>
<h3 id="创建-AccountTest-测试类"><a href="#创建-AccountTest-测试类" class="headerlink" title="创建 AccountTest 测试类"></a><strong>创建</strong> <strong>AccountTest</strong> <strong>测试类</strong></h3><p>测试具体的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InputStream in ;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory factory;</span><br><span class="line">    <span class="keyword">private</span> SqlSession session;</span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//执行操作</span></span><br><span class="line">		List&lt;AccountUser&gt; accountusers = accountDao.findAll();</span><br><span class="line">		<span class="keyword">for</span> (AccountUser au : accountusers) &#123;</span><br><span class="line">			System.out.println(au);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以及初始化方法、和结束方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span><span class="comment">//在测试方法执行之前执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//1.读取配置文件</span></span><br><span class="line">    in = Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">    <span class="comment">//2.创建构建者对象</span></span><br><span class="line">    SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">    <span class="comment">//3.创建Sq1Session工厂对象</span></span><br><span class="line">    factory = builder.build(in);</span><br><span class="line">    <span class="comment">//4.创建SqlSession对象</span></span><br><span class="line">    session = factory.openSession();</span><br><span class="line">    <span class="comment">//5.创建Dao的代理对象</span></span><br><span class="line">    accountDao = session.getMapper(IAccountDao.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@After</span><span class="comment">//在测试方法执行完成之后执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">//6.事务的提交</span></span><br><span class="line">    session. commit();</span><br><span class="line">	<span class="comment">//7.释放资源</span></span><br><span class="line">    session.close();</span><br><span class="line">    in.close() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><h3 id="修改-Account-类"><a href="#修改-Account-类" class="headerlink" title="修改 Account 类"></a>修改 Account 类</h3><p>加入 User 变量，标记该 Account 属于哪个 User</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> Integer uid;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter/setter</span></span><br><span class="line">    <span class="comment">//toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改-AccountDao-接口中的方法"><a href="#修改-AccountDao-接口中的方法" class="headerlink" title="修改 AccountDao 接口中的方法"></a>修改 AccountDao 接口中的方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询所有账户，同时获取账户的所属用户名称以及它的地址信息</span></span><br><span class="line">    <span class="function">List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 List 中的类型设置成 Account ，因为当前的 Account 类中包含了一个 User 类对象，所以可以直接封装账户对应的用户信息。</p>
<h3 id="重新定义-AccountDao-xml-文件"><a href="#重新定义-AccountDao-xml-文件" class="headerlink" title="重新定义 AccountDao.xml 文件"></a><strong>重新定义</strong> <strong>AccountDao.xml</strong> <strong>文件</strong></h3><p><img src="/images/MyBatis/AccountDao_xml.png" alt="image-20200711220339746"></p>
<h3 id="测试类相同"><a href="#测试类相同" class="headerlink" title="测试类相同"></a>测试类相同</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//执行操作</span></span><br><span class="line">    List&lt;AccountUser&gt; accountusers = accountDao.findAll();</span><br><span class="line">    <span class="keyword">for</span> (AccountUser au : accountusers) &#123;</span><br><span class="line">        System.out.println(au);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
  </entry>
  <entry>
    <title>MyBatis的延迟加载</title>
    <url>/2020/07/14/2020714-MyBatis%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<p>在进行一对一、一对多、多对多的查询时，不一定在加载用户信息的同时加载它的账户信息。此时，就可以使用延迟加载。</p>
<span id="more"></span>

<h2 id="什么是延迟加载"><a href="#什么是延迟加载" class="headerlink" title="什么是延迟加载"></a>什么是延迟加载</h2><p><strong>延迟加载</strong>：就是在<strong>需要用到数据时才进行加载</strong>，不需要用到数据时就不加载数据。延迟加载也称懒加载。<br><strong>好处：</strong>先从单表查询，需要时再从关联表去关联查询，大大提高数据库性能，因为查询单表要比关联查询多张表速 度要快。 </p>
<p><strong>坏处：</strong>因为只有当需要用到数据时，才会进行数据库查询，这样在大批量数据查询时，因为查询工作也要消耗时间，所以可能造成用户等待时间变长，造成用户体验下降。</p>
<h2 id="具体实现方法"><a href="#具体实现方法" class="headerlink" title="具体实现方法"></a>具体实现方法</h2><p>一对一：</p>
<p><img src="/images/MyBatis/settins_mybatis.png" alt="image-20200714173529954"></p>
<p>lazyLoadingEnabled 延迟加载<br>aggressiveLazyLoading 即时加载</p>
<p>SqlMapConfig.xml :</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启延迟加载--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;aggressiveLazyLoading&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>一对多：</p>
<p>在 User 实体类中加入 List<Account> 属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;Account&gt; accounts;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">getAccounts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accounts;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccounts</span><span class="params">(List&lt;Account&gt; accounts)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accounts = accounts;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">property</span>=<span class="string">&quot;birthday&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- collection 是用于建立一对多 中集合属性的对应关系</span></span><br><span class="line"><span class="comment">    ofType用于指定集合元素的数据类型</span></span><br><span class="line"><span class="comment">    select是用于指定查询账户的唯一标识 (账户的dao全限定类名加上方法名称)</span></span><br><span class="line"><span class="comment">    column是用于指定使用哪个字段的值作为条件查询</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>= <span class="string">&quot;accounts&quot;</span> <span class="attr">ofType</span>= <span class="string">&quot;account&quot;</span> <span class="attr">select</span>=<span class="string">&quot;com.itheima.dao.IAccountDao.findByUid&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">column</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置查询所有操作--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultMap</span>=<span class="string">&quot;userMap&quot;</span>&gt;</span></span><br><span class="line">select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><collection>标签：<br>主要用于加载关联的集合对象<br>select 属性：<br>用于指定查询 account 列表的 sql 语句，所以填写的是该 sql 映射的 id<br>column 属性：<br>用于指定 select 属性的 sql 语句的参数来源，上面的参数来自于 user 的 id 列，所以就写成 id 这一个字段名了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    in = Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载同一个配置了延迟加载的配置文件</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>最主要的是在 SqlMapConfig.xml 中开启延迟加载</p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
  </entry>
  <entry>
    <title>MyBatis的注解开发</title>
    <url>/2020/07/15/2020715-MyBatis%E7%9A%84%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<p>利用注解简化 MyBatis 的使用</p>
<span id="more"></span>

<h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><p>@Insert:实现新增<br>@Update:实现更新<br>@Delete:实现删除<br>@Select:实现查询<br>@Result:实现结果集封装<br>@Results:可以与@Result 一起使用，封装多个结果集<br>@ResultMap:实现引用@Results 定义的封装<br>@One:实现一对一结果集封装<br>@Many:实现一对多结果集封装<br>@SelectProvider: 实现动态 SQL 映射<br>@CacheNamespace:实现注解二级缓存的使用</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ol>
<li>编写实体类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> Date userBirthday;</span><br><span class="line">    <span class="keyword">private</span> String userSex;</span><br><span class="line">    <span class="keyword">private</span> String userAddress;</span><br><span class="line">    getter/setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>注解开发持久层（Dao）接口（此处不同） </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Select(&quot;select * from user&quot;)</span></span><br><span class="line">    <span class="meta">@Results(id=&quot;userMap&quot;,</span></span><br><span class="line"><span class="meta">            value=&#123;</span></span><br><span class="line"><span class="meta">                @Result(id=true,column=&quot;id&quot;,property=&quot;userId&quot;),</span></span><br><span class="line"><span class="meta">                @Result(column=&quot;username&quot;,property=&quot;userName&quot;),</span></span><br><span class="line"><span class="meta">                @Result(column=&quot;sex&quot;,property=&quot;userSex&quot;),</span></span><br><span class="line"><span class="meta">                @Result(column=&quot;address&quot;,property=&quot;userAddress&quot;),</span></span><br><span class="line"><span class="meta">                @Result(column=&quot;birthday&quot;,property=&quot;userBirthday&quot;)</span></span><br><span class="line"><span class="meta">            &#125;)</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Select(&quot;select * from user where id = #&#123;uid&#125;&quot;)</span></span><br><span class="line">    <span class="meta">@ResultMap(&quot;userMap&quot;)</span></span><br><span class="line">    <span class="function">User <span class="title">findById</span><span class="params">(Integer userId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>编写 SqlMapConfig 配置文件 </li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置properties文件的位置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbcConfig.properties &quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置别名的注册--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.itheima.domain&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置mysql的环境--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置事务的类型是JDBC --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.ur1&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置dao接口的位置，它有两种方式</span></span><br><span class="line"><span class="comment">第一种:使用mapper:标签配置class属性</span></span><br><span class="line"><span class="comment">第二种:使用package标签，直接指定dao接口所在的包--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.itheima.dao&quot;</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="注解说明"><a href="#注解说明" class="headerlink" title="注解说明"></a>注解说明</h2><ul>
<li>@Results 注解<br>代替的是标签<resultMap><br>该注解中可以使用单个@Result 注解，也可以使用@Result 集合@Results({@Result(),@Result()})或@Results(@Result())</li>
<li>@Resut 注解<br>代替了 <id>标签和<result>标签<br>@Result 中属性介绍：<br>id 是否是主键字段<br>column 数据库的列名<br>property 需要装配的属性名<br>one 需要使用的@One注解(@Result(one=@One)())<br>many 需要使用的@Many 注解(@Result(many=@many)())</li>
<li>@One 注解（一对一）<br>代替了<assocation>标签<br>是多表查询的关键，在注解中用来指定子查询返回单一对象。<br>@One 注解属性介绍：<br>select 指定用来多表查询的 sqlmapper<br>fetchType 会覆盖全局的配置参数 lazyLoadingEnabled<br>使用格式： @Result(column=” “,property=””,one=@One(select=””))</li>
<li>@Many 注解（多对一）<br>代替了<Collection>标签<br>是是多表查询的关键，在注解中用来指定子查询返回对象集合。<br>注意：聚集元素用来处理“一对多”的关系。需要指定映射的 Java 实体类的属性，属性的 javaType （一般为 ArrayList）但是注解中可以不定义；<br>使用格式： @Result(property=””,column=””,many=@Many(select=””))</li>
</ul>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
  </entry>
  <entry>
    <title>MyBatis的缓存问题</title>
    <url>/2020/07/15/2020715-MyBatis%E7%9A%84%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>MyBatis 中的缓存说明</p>
<span id="more"></span>

<h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>一级缓存是单个 SqlSession 的缓存区域。 MyBatis 对缓存提供支持，但是在没有配置的默认情况下，它只开启一级缓存，一级缓存只是相对于同一个 SqlSession 而言。所以在参数和 SQL 完全一样的情况下，我们使用同一个 SqlSession 对象调用一个 Mapper 方法，往往只执行一次SQL，因为使用SelSession第一次查询后，MyBatis会将其放在缓存中，以后再查询的时候，如果没有声明需要刷新，并且缓存没有超时的情况下， SqlSession 都会取出当前缓存的数据，而不会再次发送 SQL 到数据库。</p>
<p><img src="/images/MyBatis/SqlSession1.png" alt="image-20200715152101792"></p>
<p>第一次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，如果没有，从数据库查询用户信息。得到用户信息，将用户信息存储到一级缓存中。 如果 SqlSession 去执行 commit 操作（执行插入、更新、删除），清空  SqlSession  中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。 第二次发起查询用户 id 为 1 的用户信息，先去找缓存中是否有 id 为 1 的用户信息，缓存中有，直接从缓存中获取用户信息。</p>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>二级缓存是多个 SqlSession 共用的缓存区域。 SqlSession Factory 层面上的二级缓存默认是不开启的，二级缓存的开启需要进行配置，实现二级缓存的时候，MyBatis 要求返回的 POJO 必须是可序列化的。 也就是要求实 Serializable 接口，配置方法很简单，只需要在映射 XML 文件配置就可以开启缓存了。</p>
<p><img src="/images/MyBatis/SqlSession2.png" alt="image-20200715152410496"></p>
<p>首先开启 mybatis 的二级缓存。 SqlSession1 去查询用户信息，查询到用户信息会将查询数据存储到二级缓存中。 如果  SqlSession 3 去执行相同 mapper 映射下 sql，执行 commit 提交，将会清空该 mapper 映射下的二级缓存区域的数据。 SqlSession2 去查询与 SqlSession1 相同的用户信息，首先会去缓存中找是否存在数据，如果存在直接从缓存中取出数据。</p>
<h3 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h3><h4 id="xml方式"><a href="#xml方式" class="headerlink" title="xml方式"></a>xml方式</h4><ul>
<li>第一步：在 SqlMapConfig.xml 文件开启二级缓存</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ture&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>第二步：配置相关的  Mapper  映射文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.dao.IUserDao&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--开启二级缓存的支持--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache</span>&gt;</span><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><cache>标签表示当前这个 mapper 映射将使用二级缓存，区分的标准就看 mapper 的 namespace 值。</p>
<ul>
<li>第三步：配置 statement 上面的 useCache 属性 </li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span> <span class="attr">useCache</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">	select * from user where id=#&#123;uid&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>设置 useCache 为 true 代表当前这个 statement 要使用二级缓存，false 则为不使用。</p>
<h4 id="注解方式"><a href="#注解方式" class="headerlink" title="注解方式"></a>注解方式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@CacheNamespace(blocking=true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserDao</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
  </entry>
  <entry>
    <title>Spring基础</title>
    <url>/2020/07/16/2020716-Spring%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>对 Spring 进行简单介绍以及 IoC 和 AOP 的解读</p>
<span id="more"></span>

<h2 id="Spring的体系结构"><a href="#Spring的体系结构" class="headerlink" title="Spring的体系结构"></a>Spring的体系结构</h2><p><img src="/images/Spring/Spring_framework.png" alt="image-20200717074956359"></p>
<p>Spring 是分层的 Java SE/EE 应用 full-stack 轻量级开源框架，以 <strong>IoC（Inverse Of Control：反转控制）和 AOP（Aspect Oriented Programming：面向切面编程）</strong>为内核，提供了展现层 Spring MVC 和持久层 Spring JDBC 以及业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的 Java EE 企业应用开源框架。</p>
<h2 id="程序的耦合"><a href="#程序的耦合" class="headerlink" title="程序的耦合"></a>程序的耦合</h2><p>说到 Spring 就得提到耦合这一概念，Spring 的使用可以降低程序的耦合性，使得程序的独立性更强。</p>
<p>耦合性(Coupling)，也叫耦合度，是对模块间关联程度的度量。耦合的强弱取决于模块间接口的复杂性、调用模块的方式以及通过界面传送数据的多少。模块间的耦合度是指模块之间的依赖关系，包括控制关系、调用关系、数据传递关系。模块间联系越多，其耦合性越强，同时表明其独立性越差( 降低耦合性，可以提高其独立性)。</p>
<ul>
<li>划分模块的一个准则就是<strong>高内聚低耦合</strong></li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>（1）<strong>内容耦合</strong>。当一个模块直接修改或操作另一个模块的数据时，或一个模块<strong>不通过正常入口</strong>而转入另一个模块时，这样的耦合被称为内容耦合。内容耦合是<strong>最高程度的耦合</strong>，应该避免使用之。<br>（2）<strong>公共耦合</strong>。两个或两个以上的模块<strong>共同引用一个全局数据项</strong>，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。<br>（3） <strong>外部耦合</strong> 。一组模块都<strong>访问同一全局简单变量</strong>而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。<br>（4） <strong>控制耦合</strong> 。一个模块通过接口向另一个模块<strong>传递一个控制信号</strong>，接受信号的模块根据信号值而进行适当的动作，这种耦合被称为控制耦合。<br>（5）<strong>标记耦合</strong> 。若一个模块 A 通过接口向两个模块 B 和 C <strong>传递一个公共参数</strong>，那么称模块 B 和 C 之间存在一个标记耦合。<br>（6） <strong>数据耦合</strong>。模块之间<strong>通过参数来传递数据</strong>，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。<br>（7） <strong>非直接耦合</strong> 。两个模块之间<strong>没有直接关系</strong>，它们之间的联系完全是通过主模块的控制和调用来实现的。</p>
<h2 id="控制反转（IOC）"><a href="#控制反转（IOC）" class="headerlink" title="控制反转（IOC）"></a>控制反转（IOC）</h2><p>在应用加载时，创建一个 Map，用于存放三层对象。</p>
<p>我们把这个 Map 称之为<strong>容器</strong>。</p>
<p><img src="/images/Spring/ioc_aop.png" alt="image-20200717080102827"></p>
<p>而应用对对象的获取则是通过工厂来实现，以前，是采用 new 的方式，是<strong>主动</strong>获取对象。有了工厂后，在获取对象的时候向工厂要，工厂则会为我们查找或创建对象，是<strong>被动</strong>获取。</p>
<p><img src="/images/Spring/newObject.png" alt="image-20200717080417117"></p>
<p><img src="/images/Spring/factoryObj.png" alt="image-20200717080447044"></p>
<ul>
<li>这种被动接收的方式获取对象的思想就是控制反转，它是 Spring 框架的核心之一。</li>
</ul>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ol>
<li>准备开发 jar 包</li>
</ol>
<p><img src="/images/Spring/jarPac.png" alt="img"></p>
<ol start="2">
<li>创建业务层（service）接口和实现类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以进一步完善获取 Dao 的方法</span></span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao = <span class="keyword">new</span> AccountDaoImpl();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        accountDao.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建持久层（dao)接口和实现类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Save Account!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于-xml-的配置"><a href="#基于-xml-的配置" class="headerlink" title="基于 xml 的配置"></a>基于 xml 的配置</h3><ol>
<li>拷贝 jar 包到根路径的 libs 文件夹</li>
</ol>
<p><img src="/images/Spring/copyJar.png" alt="img"></p>
<ol start="2">
<li>在根路径（src）创建 xml 文件<br>从/Spring-framework-5.0.2.RELEASE-dist/Spring-framework-5.0.2.RELEASE/docs/Spring-framework-reference/index.html查找文档，找到相关约束</li>
</ol>
<p><img src="/images/Spring/spring_core.png" alt="image-20200717081606014"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>拷贝到 xml 文件</p>
<p>3.在配置文件中配置 service 和 dao，让 Spring 对其进行管理</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--bean 标签:用于配置让 Spring 创建对象，并且存入 ioc 容器之中</span></span><br><span class="line"><span class="comment">id属性:对象的唯一标识。</span></span><br><span class="line"><span class="comment">class属性:指定要创建对象的全限定类名</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置service --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置dao --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">class</span>= <span class="string">&quot;com.itheima.dao.impl.AccountDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4.模拟表现层测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1. 使用ApplicationContext接口，就是在获取 Spring容器</span></span><br><span class="line">	ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">	<span class="comment">//2.根据bean的id获取对象</span></span><br><span class="line">	IAccountService aService = (IAccountService)ac.getBean(<span class="string">&quot;accountService&quot;</span>);</span><br><span class="line">	System.out.println(aService);</span><br><span class="line">	IAccountDao aDao = (IAccountDao)ac.getBean(<span class="string">&quot;accountDao&quot;</span>);</span><br><span class="line">	System.out.println(aDao);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="/images/Spring/result.png" alt="img"></p>
<h3 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h3><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>ioc 只是降低了程序的耦合，并不能完全消除耦合性。例如，在业务层调用持久层的方法，仍然存在着依赖关系。所以，就可以使用依赖注入，<strong>让 Spring 帮我们把持久层对象传入业务层</strong>。不用自己去实例化持久层对象。</p>
<h3 id="构造函数注入"><a href="#构造函数注入" class="headerlink" title="构造函数注入"></a>构造函数注入</h3><h4 id="注入基本数据类型"><a href="#注入基本数据类型" class="headerlink" title="注入基本数据类型"></a>注入基本数据类型</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountService</span> <span class="title">Impl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountServiceImpl</span> <span class="params">(String name, Integer age, Date birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>给构造函数传参 </li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>= <span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>= <span class="string">&quot;com.itheima.service.impl.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;张三&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;18&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;now&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>= <span class="string">&quot;now&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.util.Date&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>利用生成的 setter 方法（常用） </li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;21&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;birthday&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;now&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>= <span class="string">&quot;now&quot;</span> <span class="attr">class</span>=<span class="string">&quot;java.util.Date&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用 p 名称（本质还是 setter）<br>使用该方法需要增加约束头</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlns:p=&quot;http://www.springframework.org/schema/p&quot;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.AccountServiceImpl&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;test&quot;</span> <span class="attr">p:age</span>=<span class="string">&quot;21&quot;</span> <span class="attr">p:birthday-ref</span>=<span class="string">&quot;now&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="注入集合属性"><a href="#注入集合属性" class="headerlink" title="注入集合属性"></a>注入集合属性</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] myStrs;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; myList;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; mySet;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; myMap;</span><br><span class="line">    <span class="keyword">private</span> Properties myProps;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注入集合数据</span></span><br><span class="line"><span class="comment">	List 结构：</span></span><br><span class="line"><span class="comment">		array,list,set</span></span><br><span class="line"><span class="comment">	Map 结构：</span></span><br><span class="line"><span class="comment">		map,entry,props,prop</span></span><br></pre></td></tr></table></figure>

<ul>
<li>List 数据结构：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--给数组注入数据--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>= <span class="string">&quot;myStrs&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注入list集合数据--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>= <span class="string">&quot;myList&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注入set集合数据--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">nande</span>= <span class="string">&quot;mySet&quot;</span>&gt;</span></span><br><span class="line">    &lt;1ist&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Map 数据结构：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注入Map数据--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myMap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;testA&quot;</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;testB&quot;</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注入properties数据--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;myProps&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;testA&quot;</span> <span class="attr">value</span>=<span class="string">&quot;aaa&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;testB&quot;</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">value</span>&gt;</span>bbb<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="底层分析"><a href="#底层分析" class="headerlink" title="底层分析"></a>底层分析</h2><h3 id="类结构图"><a href="#类结构图" class="headerlink" title="类结构图"></a>类结构图</h3><p><img src="/images/Spring/BeanFactory.png" alt="image-20200717082303159"></p>
<p>BeanFactory 才是 Spring 容器中的顶层接口。 ApplicationContext 是它的子接口。 BeanFactory 和 ApplicationContext 的区别： 创建对象的时间点不一样。</p>
<ul>
<li>ApplicationContext：只要一读取配置文件，默认情况下就会创建对象。</li>
<li>BeanFactory：什么使用什么时候创建对象。</li>
</ul>
<h3 id="实现类"><a href="#实现类" class="headerlink" title="实现类"></a>实现类</h3><p><img src="/images/Spring/ImplClass.png" alt="image-20200717082410114"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Spring整合JUnit</title>
    <url>/2020/07/17/2020717-Spring%E6%95%B4%E5%90%88JUnit/</url>
    <content><![CDATA[<p>整合 JUnit 为项目提供单元测试，减少代码冗余</p>
<span id="more"></span>

<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>在之前的测试类中，每个测试方法都有以下两行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">IAccountService as = ac.getBean(<span class="string">&quot;accountService&quot;</span>,IAccountService.class);</span><br></pre></td></tr></table></figure>

<p>这两行的代码作用是获取容器，所以不能随意删除，但是就造成了代码的重复。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>我们需要程序能够自动帮我们创造容器，就不用手动创建。</p>
<p>JUnit 给我们一个注解，可以让我们替换掉它的运行器。 这时，我们需要依靠 Spring 框架，因为它提供了一个运行器，可以读取配置文件（或注解）来创建容器。我们只需要告诉它配置文件在哪就行了。</p>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ol>
<li>导入jar包</li>
</ol>
<p><img src="/images/Spring/jar_junit.png" alt="jar_junit"></p>
<ol start="2">
<li>使用@RunWith 注解替换原有的运行器使用Spring提供的运行器</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceTest</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用@ContextConfiguration 指定 Spring 配置文件的位置</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations=&#123;&quot;classpath:bean.xml&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceTest</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>​    @ContextConfiguration 注解：<br>​            locations 属性：用于指定配置文件的位置，如果是类路径下，需要用 classpath: 表明。<br>​            classes 属性：用于指定注解的类，当不使用 xml 配置时，需要用此属性指定注解类的位置。</p>
<ol start="4">
<li>使用@Autowired 给测试类中的变量注入数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations=&#123;&quot;classpath:bean.xml&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IAccountService as;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Spring注解说明</title>
    <url>/2020/07/17/2020717-Spring%E6%B3%A8%E8%A7%A3%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>在 Spring 开发中，使用注解可以简化替代 xml 中的一些配置，大大提升了开发的便捷性</p>
<span id="more"></span>

<h2 id="用于创建对象的注解"><a href="#用于创建对象的注解" class="headerlink" title="用于创建对象的注解"></a>用于创建对象的注解</h2><p>相当于 xml：<bean id="" class=""></p>
<ul>
<li><p>@Component 作用： 把资源让 Spring 来管理。相当于在 xml 中配置一个 <strong>bean</strong>。<br>属性： value：指定 bean 的 id。如果不指定 value 属性，默认 bean 的 id 是当前类的类名。首字母小写。</p>
</li>
<li><p>@Controller @Service @Repository他们三个注解都是针对一个的衍生注解，他们的作用及属性都是一模一样的。 他们只不过是提供了更加明确的语义化。</p>
<ul>
<li>@Controller：一般用于<strong>表现层</strong>的注解。</li>
<li>@Service：一般用于<strong>业务层</strong>的注解。</li>
<li>@Repository：一般用于<strong>持久层</strong>的注解。</li>
</ul>
<p>细节：如果注解中有且只有一个属性要赋值时，且名称是 value，value 在赋值是可以不写。</p>
</li>
</ul>
<h2 id="用于注入数据的注解"><a href="#用于注入数据的注解" class="headerlink" title="用于注入数据的注解"></a>用于注入数据的注解</h2><p>相当于 xml ：<property name="" ref=""> <property name="" value=""></p>
<ul>
<li>@Autowired 作用： 自动按照类型注入。当使用注解注入属性时，<strong>set 方法可以省略</strong>。它只能注入其他 bean 类型。当有多个类型匹配时，使用要注入的对象变量名称作为 bean 的 id，在 Spring 容器查找，找到了也可以注入成功。找不到就报错。</li>
<li>@Qualifier 作用： 在自动按照类型注入的基础之上，再按照 Bean 的 id 注入。它在给字段注入时不能独立使用，<strong>必须和@Autowired 一起使用</strong>；但是给方法参数注入时，可以独立使用。<br>属性： value：指定 bean 的 id。</li>
<li>@Resource 作用： <strong>直接按照 Bean 的 id 注入</strong>。它也只能注入其他 bean 类型。<br>属性： name：指定 bean 的 id。</li>
<li>@Value 作用： 注入<strong>基本数据类型和 String 类型数据</strong>的。<br>属性： value：用于指定值</li>
</ul>
<h2 id="用于改变作用范围的注解"><a href="#用于改变作用范围的注解" class="headerlink" title="用于改变作用范围的注解"></a>用于改变作用范围的注解</h2><p>相当于 xml：<bean id="" class="" scope=""></p>
<ul>
<li>@Scope 作用： 指定 bean 的作用范围。<br>属性： value：指定范围的值。 取值：singleton(单例) prototype(多例) request session globalsession</li>
</ul>
<h2 id="和生命周期相关的注解（了解即可）"><a href="#和生命周期相关的注解（了解即可）" class="headerlink" title="和生命周期相关的注解（了解即可）"></a>和生命周期相关的注解（了解即可）</h2><p>相当于 xml：<bean id="" class="" init-method="" destroy-method=""/></p>
<ul>
<li>@PostConstruct 作用： 用于指定初始化方法。</li>
<li>@PreDestroy 作用： 用于指定销毁方法。</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>背包问题（动态规划）</title>
    <url>/2020/07/17/2020717-%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89/</url>
    <content><![CDATA[<p>背包问题是比较经典的动态规划入门题，问如何在不超过背包承重的情况下，装入的价值总和最大。</p>
<span id="more"></span>

<h2 id="零一背包"><a href="#零一背包" class="headerlink" title="零一背包"></a>零一背包</h2><p>有不同价值和重量的物品，一个承重已知的背包，求怎么装可以达到最大价值且不超重。</p>
<h3 id="二维数组实现"><a href="#二维数组实现" class="headerlink" title="二维数组实现"></a>二维数组实现</h3><p>两种情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f[i][j] = f[i-1][j]</span><br></pre></td></tr></table></figure>

<p>当前承重的历史最大值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f[i][j] = f[i-1][j-t[i]] + p[i]</span><br></pre></td></tr></table></figure>

<p>当前值加上剩余承重的历史最大值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> i,j,T,M,t[<span class="number">101</span>],p[<span class="number">101</span>],f[<span class="number">101</span>][<span class="number">1001</span>];</span><br><span class="line"><span class="comment">// T：承重 M：物品数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; T &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=M;i++)</span><br><span class="line">        cin &gt;&gt; t[i] &gt;&gt; p[i]; <span class="comment">//读取单位重量和价值</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从t[i]开始是因为这是能够装下当前物品的最小承重值，之前的都装不下，所以使用历史最大值</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;t[i];j++)</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];</span><br><span class="line">        <span class="keyword">for</span>(j=t[i];j&lt;=T;j++) </span><br><span class="line">            f[i][j]=<span class="built_in">max</span>(f[i<span class="number">-1</span>][j],f[i<span class="number">-1</span>][j-t[i]]+p[i]);<span class="comment">//递推</span></span><br><span class="line">    &#125;    </span><br><span class="line">    cout &lt;&lt; f[M][T];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一维数组实现"><a href="#一维数组实现" class="headerlink" title="一维数组实现"></a>一维数组实现</h3><p>可以将药的种类 <em>i</em> 省略 ，只开一个一维数组，用后面算的值覆盖掉前面算的值 。</p>
<p>判断时用旧的当前承重的历史最大值作比较，然后进行覆盖。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> i,j,T,M,t[<span class="number">101</span>],p[<span class="number">101</span>],f[<span class="number">1001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; T &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=M;i++)</span><br><span class="line">         cin &gt;&gt; t[i] &gt;&gt; p[i];</span><br><span class="line">    <span class="comment">// 此处发生改变</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=M;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=T;j&gt;=t[i];j--)<span class="comment">//从右到左计算</span></span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-t[i]]+p[i]);<span class="comment">//递推</span></span><br><span class="line">    <span class="comment">//当需要的左边的值为数组越界时，值不变</span></span><br><span class="line">    cout &lt;&lt; f[T];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h2><p>有不同价值和重量的物品，一个承重已知的背包，求怎么装可以达到最大价值且不超重。</p>
<p>不同的是一个物品可以重复装多次。</p>
<h3 id="二维数组实现-1"><a href="#二维数组实现-1" class="headerlink" title="二维数组实现"></a>二维数组实现</h3><p>一种可以装 n 次</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f[i][j] = max(f[i-1][j],f[i-1][j-n*t[i]] + n*p[i])</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>F</th>
<th>E</th>
<th>D</th>
<th>C</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td><strong>B</strong></td>
<td><strong>A</strong></td>
</tr>
</tbody></table>
<p>根据上图可知，求 A 的值需要 C D E F 的值，而求 B 的值需要 D E F 的值，可以得出以下状态转移方程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">f[i][j] = max(f[i-1][j],f[i][j-t[i]] + p[i])</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> i,j,T,M,t[<span class="number">10001</span>],p[<span class="number">10001</span>],f[<span class="number">10001</span>][<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; T &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=M;i++)</span><br><span class="line">        cin &gt;&gt; t[i] &gt;&gt; p[i];</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=M;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从左到右</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;t[i];j++)</span><br><span class="line">            f[i][j]=f[i<span class="number">-1</span>][j];<span class="comment">//针对左边为数组越界的状态</span></span><br><span class="line">        <span class="keyword">for</span>(j=t[i];j&lt;=T;j++)</span><br><span class="line">            f[i][j]=<span class="built_in">max</span>(f[i<span class="number">-1</span>][j],f[i][j-t[i]]+p[i]);<span class="comment">//此处不同</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[M][T];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一维数组实现-1"><a href="#一维数组实现-1" class="headerlink" title="一维数组实现"></a>一维数组实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> i,j,m,n;</span><br><span class="line">    <span class="keyword">long</span> f[<span class="number">1000001</span>],v[<span class="number">1000001</span>],h[<span class="number">1000001</span>];</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;<span class="comment">//时间与物品数量</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    cin &gt;&gt; h[i] &gt;&gt; v[i];<span class="comment">//读入重量与价值</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="keyword">for</span>(j=h[i];j&lt;=m;j++)<span class="comment">//与01背包的不同点，01背包是从m到h[i]，而完全背包是反过来正序循环</span></span><br><span class="line">            f[j]=<span class="built_in">max</span>(f[j],f[j-h[i]]+v[i]);<span class="comment">//保存较大数</span></span><br><span class="line">    cout &lt;&lt; f[m];<span class="comment">//输出结果</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>Spring-IOC-CRUD</title>
    <url>/2020/07/18/2020718-Spring-IOC-CRUD/</url>
    <content><![CDATA[<p>利用 Spring-IOC 控制反转的特性，对数据库进行简单的 CRUD 操作</p>
<span id="more"></span>

<h2 id="基于-xml-的配置"><a href="#基于-xml-的配置" class="headerlink" title="基于 xml 的配置"></a>基于 xml 的配置</h2><ol>
<li>拷贝 jar 包</li>
</ol>
<p><img src="/images/Spring/jar_crud.png" alt="image-20200718074221411"></p>
<ol start="2">
<li>创建数据库和编写实体类<br>数据库 sql 语句：</li>
</ol>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> account (</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">40</span>),</span><br><span class="line">    money <span class="type">float</span></span><br><span class="line">)<span class="type">character</span> <span class="keyword">set</span> utf8 <span class="keyword">collate</span> utf8_general_ci;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> account(name,money) <span class="keyword">values</span>(<span class="string">&#x27;aaa&#x27;</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> account(name,money) <span class="keyword">values</span>(<span class="string">&#x27;bbb&#x27;</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> account(name,money) <span class="keyword">values</span>(<span class="string">&#x27;ccc&#x27;</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<p>实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Float money;</span><br><span class="line"> 	getter/setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>编写持久层（dao）代码 </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Account account)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoIml</span> <span class="keyword">implements</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DBAssit dbAssit;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDbAssit</span><span class="params">(DBAssit dbAssit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dbAssit = dbAssit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        dbAssit.update(<span class="string">&quot;insert account(name,money) into value(?,?)&quot;</span>,account.getName(),account.getMoney());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>编写业务层（service）代码 </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(IAccountDao accountDao)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>编写 xml 配置文件 </li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding= &quot;UTF-8?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance” xsi:schemaLocation=&quot;</span><span class="attr">http:</span>//<span class="attr">www.springframework.org</span>/<span class="attr">schema</span>/<span class="attr">beans</span></span></span><br><span class="line"><span class="tag"><span class="attr">http:</span>//<span class="attr">www.springframework.org</span>/<span class="attr">schema</span>/<span class="attr">beans</span>/<span class="attr">spring-beans.xsd</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置service--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置dao--&gt;</span>                                                 </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.AccountDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dbAssit&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dbAssit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置dbAssit--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dbAssit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dbassit.DBAssit&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///spring_day02&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>编写测试类 </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations=&#123;&quot;classpath:bean.xml&quot;&#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSaveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IAccountService as;</span><br><span class="line">    </span><br><span class="line">    Account account = <span class="keyword">new</span> Account();</span><br><span class="line">    account.setName(<span class="string">&quot;黑马程序员&quot;</span>);</span><br><span class="line">    account.setMoney(<span class="number">100000f</span>);</span><br><span class="line">    as.saveAccount(account);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于注解的配置"><a href="#基于注解的配置" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h2><ol>
<li>拷贝相关 jar 包到 libs 目录 注意：在基于注解的配置中，我们还要多拷贝一个 aop 的 jar 包。</li>
</ol>
<p><img src="/images/Spring/jar_aop.png" alt="img"></p>
<ol start="2">
<li>导入约束文件<br>相较于上面的 xml 文件，多导入一个 context 名称空间下的约束。<br>由于我们使用了注解配置，此时不能继承 JdbcDaoSupport，需要自己配置一个 JdbcTemplate</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding= &quot;UTF-8?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--告知spring创建容器时要扫描的包--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置dbAssit--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dbAssit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dbassit.DBAssit&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///spring_day02&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用注解配置管理的资源 </li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;accountService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Componet(&quot;accountDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DBAssit dbAssit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://deepbreath373.github.io/2020/07/17/2020717-Spring%E6%B3%A8%E8%A7%A3%E8%AF%B4%E6%98%8E/">常用注解</a></p>
<h4 id="注解配置优化"><a href="#注解配置优化" class="headerlink" title="注解配置优化"></a>注解配置优化</h4><p>我们发现，之所以我们现在离不开 xml 配置文件，是因为我们有一句很关键的配置： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--告知spring框架在读取配置文件、创建容器时，扫描注解，依据注解创建对象，并存入容器中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> 如果他要也能用注解配置，那么我们就离脱离 xml 文件又进了一步。 另外，数据源和 JdbcTemplate 的配置也需要靠注解来实现。 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置dbAssit--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dbAssit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dbassit.DBAssit&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///spring_day02&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="新注解说明"><a href="#新注解说明" class="headerlink" title="新注解说明"></a>新注解说明</h5><ul>
<li>@Configuration 作用： 用于<strong>指定当前类是一个 spring 配置类</strong>，当创建容器时会从该类上加载注解。获取容器时需要使用 AnnotationApplicationContext(有@Configuration 注解的类.class)。 属性： value:用于指定配置类的字节码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>@ComponentScan 作用： 用于<strong>指定 spring 在初始化容器时要扫描的包</strong>。作用和在 spring 的 xml 配置文件中的： &lt;context:component-scan base-package=”com.itheima”/&gt;是一样的。 属性： basePackages：用于指定要扫描的包。和该注解中的 value 属性作用一样。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>@Bean 作用： 该注解<strong>只能写在方法上</strong>，<strong>表明使用此方法创建一个对象</strong>，并且放入 spring 容器。 属性： name：给当前@Bean 注解方法创建的对象指定一个名称(即 bean 的 id）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean(name=&quot;dataSource&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ComboPooledDataSource ds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">            ds.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">            ds.setPassword(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">            ds.setDriverClass(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            ds.setJdbcUrl(<span class="string">&quot;jdbc:mysql:///spring_day02&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ds;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(name=&quot;dbAssit&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DBAssit <span class="title">createDBAssit</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DBAssit(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，此时配置数据库的内容是写死的，所以还需要另一个注解</p>
<ul>
<li>@PropertySource作用： 用于加载.properties 文件中的配置。例如我们配置数据源时，可以把连接数据库的信息写到 properties 配置文件中，就可以使用此注解指定 properties 配置文件的位置。 属性： value[]：用于指定 properties 文件位置。如果是在类路径下，需要写上 classpath:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:db.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driver&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="meta">@Bean(name=&quot;dataSource&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ComboPooledDataSource ds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">            ds.setUser(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">            ds.setPassword(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">            ds.setDriverClass(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">            ds.setJdbcUrl(<span class="string">&quot;jdbc:mysql:///spring_day02&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ds;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean(name=&quot;dbAssit&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DBAssit <span class="title">createDBAssit</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DBAssit(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>@Import作用： 用于导入其他配置类，在引入其他配置类时，可以不用再写@Configuration 注解。当然，写上也没问题。 属性： value[]：用于指定其他配置类的字节码.</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages=&quot;com.itheima.spring&quot;)</span></span><br><span class="line"><span class="meta">@Import(&#123;JdbcConfig.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取 IOC 容器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext ac = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfiguration.class);</span><br></pre></td></tr></table></figure>

<h2 id="配置方式选择比对"><a href="#配置方式选择比对" class="headerlink" title="配置方式选择比对"></a>配置方式选择比对</h2><p>注解的优势：<br>配置简单，维护方便（我们找到类，就相当于找到了对应的配置）。<br>XML 的优势：<br>修改时，不用改源码。不涉及重新编译和部署。</p>
<p><img src="/images/Spring/spring_configuration.png" alt="img"></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Spring中的事务控制</title>
    <url>/2020/07/27/2020727-Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<p>当需要一组操作要么一起成功，要么一起失败的时候，就需要事务的处理</p>
<span id="more"></span>

<h1 id="相关接口"><a href="#相关接口" class="headerlink" title="相关接口"></a>相关接口</h1><h3 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a><strong>PlatformTransactionManager</strong></h3><p>此<strong>接口</strong>是spring的事务管理器，提供了常用的操作事务的方法。</p>
<ul>
<li>获取事务状态信息——TransactionStatus getTransaction(TransactionDefinition definition)</li>
<li>提交事务 ——void commit(TransactionStatus status)</li>
<li>回滚事务 ——void rollback(TransactionStatus status)</li>
</ul>
<p>正常情况使用它的实现类进行开发</p>
<ul>
<li>org.springframework.jdbc.datasource.DataSourceTransactionManager<br>使用 Spring JDBC 或 iBatis 进行持久化数据时使用</li>
<li>org.springframework.orm.hibernate5.HibernateTransactionManager<br>使用 Hibernate 版本进行持久化数据时使用</li>
</ul>
<h3 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h3><p>此<strong>接口</strong>是事务的定义信息对象</p>
<ul>
<li>获取事务对象名称：String getName()</li>
<li>获取事务隔离级别：int getIsolationLevel()</li>
<li>获取事务传播行为：int getPropagationBehavior()</li>
<li>获取事务超时时间：int getTimeout()</li>
<li>获取事务是否只读：boolean isReadOnly()<br>读写型事务：增加删除修改开启事务<br>只读型事务：执行查询时，也会开启事务</li>
</ul>
<h3 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h3><p>此<strong>接口</strong>提供事务具体的运行状态</p>
<ul>
<li>刷新事务：void flush()</li>
<li>获取是否存在存储点：boolean hasSavepoint()</li>
<li>获取事务是否完成：boolean isCompleted()</li>
<li>获取事务是否为新事务：boolean isNewTransaction()</li>
<li>获取事务是否回滚：boolean isRollbackOnly()</li>
<li>设置事务回滚：void setRollbackOnly()</li>
</ul>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>事务隔离级别反映事务提交并发访问时的处理态度</p>
<ul>
<li>默认级别，归属下列某一种：<br>ISOLATION_DEFAULT</li>
<li>可以读取未提交数据：<br>ISOLATION_READ_UNCOMMITTED</li>
<li>只能读取已提交数据，解决脏读问题(Oracle默认级别)：<br>ISOLATION_READ_COMMITTED</li>
<li>是否读取其他事务提交修改后的数据，解决不可重复读问题(MySQL默认级别)：<br>ISOLATION_REPEATABLE_READ</li>
<li>是否读取其他事务提交添加后的数据，解决幻读问题：<br>ISOLATION_SERIALIZABLE</li>
</ul>
<h2 id="事务的传播行为（propagation）"><a href="#事务的传播行为（propagation）" class="headerlink" title="事务的传播行为（propagation）"></a>事务的传播行为（propagation）</h2><ul>
<li>REQUIRED:<br>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中<br>一般的选择(默认值)</li>
<li>SUPPORTS:<br>支持当前事务，如果当前没有事务，就以非事务方式执行(没有事务)</li>
<li>MANDATORY:<br>使用当前的事务，如果当前没有事务，就抛出异常</li>
<li>REQUERS_NEW:<br>新建事务，如果当前在事务中，把当前事务挂起</li>
<li>NOT SUPPORTED:<br>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起</li>
<li>NEVER:<br>以非事务方式运行，如果当前存在事务，抛出异常</li>
<li>NESTED:<br>如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则执行REQUIRED类似的操作</li>
</ul>
<h2 id="基于xml的声明式事务控制"><a href="#基于xml的声明式事务控制" class="headerlink" title="基于xml的声明式事务控制"></a>基于xml的声明式事务控制</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>1.导入 jar 包</p>
<p><img src="/images/Spring/jar_tx.png" alt="image-20200727091425288"></p>
<p>2.导入约束</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1. 0&quot; encoding= &quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop/spring-aop.xsdi&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.准备数据库表和实体类</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> account(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">40</span>),</span><br><span class="line">    money <span class="type">float</span></span><br><span class="line">) <span class="type">character</span> <span class="keyword">set</span> utf8 <span class="keyword">collate</span> utf8_general_ci;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id; </span><br><span class="line">    <span class="keyword">private</span> string name;</span><br><span class="line">    <span class="keyword">private</span> Float money;</span><br><span class="line">    getter/setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.编写service接口和实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="function">Account <span class="title">findAccountById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">( IAccountDao accountDao)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> accountDao.findAccountById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.编写dao接口和实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="function">Account <span class="title">findAccountById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> <span class="keyword">implements</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountById</span><span class="params">(Integer id)</span></span>&#123;</span><br><span class="line">    	List&lt;Account&gt; list = getJdbcTemplate().query(<span class="string">&quot;select * from account where id = ?&quot;</span>,<span class="keyword">new</span> AccountRowMapper(), id);</span><br><span class="line">    	<span class="keyword">return</span> list.isEmpty()?<span class="keyword">null</span>:list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountRowMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">Account</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account();</span><br><span class="line">        account.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        account.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        account.setMoney(rs.getFloat(<span class="string">&quot;money&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> account;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.配置xml配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置service --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置dao --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.AccountDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注入dataSource --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///spring_day04&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><p>1.配置事务管理器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置一个事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注入DataSource--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.配置事务的通知引用事务管理器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--事务的配置--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.配置事务的属性</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在tx:advice标签内部配事务的属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定方法名称:是业务核心方法</span></span><br><span class="line"><span class="comment">        read-only:是否是只读事务。默认false,不只读。</span></span><br><span class="line"><span class="comment">        isolation:指定事务的隔离级别。默认值是使用数据库的默认隔离级别。</span></span><br><span class="line"><span class="comment">        propagation:指定事务的传播行为。</span></span><br><span class="line"><span class="comment">        timeout:指定超时时间。默认值为: -1。永不超时。</span></span><br><span class="line"><span class="comment">        rollback-for:用于指定一个异常，当执行产生该异常时，事务回滚。</span></span><br><span class="line"><span class="comment">					产生其他异常，事务不回滚。没有默认值，任何异常都回滚。</span></span><br><span class="line"><span class="comment">        no-rollback-for:用于指定一个异常，当产生该异常时，事务不回滚。</span></span><br><span class="line"><span class="comment">					产生其他异常时，事务回滚。没有默认值，任何异常都回滚。</span></span><br><span class="line"><span class="comment">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;SUPPORTS&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.配置 AOP 切入点表达式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置aop --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置切入点表达式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.itheima.service.impl.*.*(..))&quot;</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>5.配置切入点表达式和事务通知的对应关系</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--在aop:config标签内部:建立事务的通知和切入点表达式的关系--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="基于注解的配置方式"><a href="#基于注解的配置方式" class="headerlink" title="基于注解的配置方式"></a>基于注解的配置方式</h2><h3 id="环境搭建-1"><a href="#环境搭建-1" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>1.导入jar包(同上)</p>
<p>2.导入约束和配置扫描包路径</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1. 0&quot; encoding= &quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/aop/spring-aop.xsdi</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置JdbeTemplate--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;datasource&quot;</span><span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置spring提供的内置数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>= <span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://loca1host:3306/spring_day02&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.创建数据库表和实体类(同上)</p>
<p>4.创建service接口和实现类并使用注解让 spring 管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line">    <span class="comment">//其余代码和基于XML的配置相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.创建 Dao 接口和实现类并使用注解让 spring 管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;accountDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="comment">//其余代码和基于XML的配置相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="配置步骤-1"><a href="#配置步骤-1" class="headerlink" title="配置步骤"></a>配置步骤</h3><p>1.配置事务管理器并注入数据源</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.在业务层使用@Transactional 注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br><span class="line"><span class="meta">@Transactional(readOnly=true, propagation=Propagation.SUPPORTS)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line">    <span class="comment">//其余代码和基于XML的配置相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>该注解的属性和 xml 中的属性含义一致。该注解可以出现在接口上，类上和方法上。<br>出现接口上，表示该接口的所有实现类都有事务支持。<br>出现在类上，表示类中所有方法有事务支持<br>出现在方法上，表示方法有事务支持。<br>以上三个位置的优先级:方法&gt;类&gt;接口</li>
</ul>
<p>3.在配置文件中开启 spring 对注解事务的支持</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启spring对注解事务的支持--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>4.不使用 xml 的配置方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableTransactionManagement</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringTxConfiguration</span> </span>&#123;</span><br><span class="line">	<span class="comment">//里面配置数据源，配置JdbcTemplate，配置事务管理器。在之前的步骤已经写过了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Spring中的JdbcTemplate</title>
    <url>/2020/07/26/2020726-Spring%E4%B8%AD%E7%9A%84JdbcTemplate/</url>
    <content><![CDATA[<p>利用 Spring 提供的 Jdbc 对数据库进行操作</p>
<span id="more"></span>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdbcTemplate</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdbcTemplate</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    setDataSource(dataSource);</span><br><span class="line">    afterPropertiesSet();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdbcTemplate</span><span class="params">(DataSource dataSource, <span class="keyword">boolean</span> lazyInit)</span> </span>&#123;</span><br><span class="line">    setDataSource(dataSource);</span><br><span class="line">    setLazyInit(lazyInit);</span><br><span class="line">    afterPropertiesSet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>出了默认构造函数之外，都需要提供 DataSource 。并且使用 set 方法，这样就可以使用依赖注入的方式，在配置文件中配置这些对象。</p>
<h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><p>1.环境搭建</p>
<p><img src="/images/Spring/jar_jdbc.png" alt="image-20200726092455095"></p>
<p>2.导入约束</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.1配置 C3P0 数据源<br>导入 <strong>c3p0-0.9.2.1.jar</strong> 到工程的 lib 目录，在 Spring 的配置文件中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>= <span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>= <span class="string">&quot;jdbc:mysql:///spring_day02&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.2配置 DBCP 数据源<br>导入 <strong>commons-dbcp.jar</strong> <strong>commons-pool.jar</strong> 到工程的 lib 目录，在 Spring 的配置文件中配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>= <span class="string">&quot;jdbc:mysql:///spring_day02&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.3配置 spring 内置数据源</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>= <span class="string">&quot;jdbc:mysql:///spring_day02&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.4使用配置文件方式</p>
<p>定义properties文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql:///spring_day02</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">1234</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>一种导入方式 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;location&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>另一种导入方式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbc.properties&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><p>1.创建数据库表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> account(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">40</span>),</span><br><span class="line">    money <span class="type">float</span></span><br><span class="line">)<span class="type">character</span> <span class="keyword">set</span> utf8 <span class="keyword">collate</span> utf8_general_ci;</span><br></pre></td></tr></table></figure>

<p>2.配置JdbcTemplate</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">    http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置一个数据库的操作模板：JdbcTemplate--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>= <span class="string">&quot;jdbc:mysql:///spring_day02&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.基本操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.获取Spring容器</span></span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="comment">//2.根据id获取bean对象</span></span><br><span class="line">        JdbcTemplate jt = (JdbcTemplate) ac.getBean(<span class="string">&quot;jdbcTemplate&quot;</span>);</span><br><span class="line">        <span class="comment">//3.执行操作</span></span><br><span class="line">        jt.execute(<span class="string">&quot;insert into account (name，money) values(&#x27;eee&#x27;,500)&quot;</span>);</span><br><span class="line">        <span class="comment">//保存</span></span><br><span class="line">        jt.update(<span class="string">&quot;insert into account (name, money) values(?, ?)&quot;</span>, <span class="string">&quot;fff&quot;</span>, <span class="number">5000</span>) ;</span><br><span class="line">        <span class="comment">//修改</span></span><br><span class="line">        jt.update(<span class="string">&quot;update account set money = money-? where id = ?&quot;</span>,<span class="number">300</span>,<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//删除</span></span><br><span class="line">        jt.update(<span class="string">&quot;delete from account where id = ?&quot;</span>,<span class="number">6</span>);</span><br><span class="line">        <span class="comment">//查询所有</span></span><br><span class="line">        List&lt;Account&gt; accounts = jt.query (<span class="string">&quot;select * from account where money &gt; ? &quot;</span>，</span><br><span class="line">        <span class="keyword">new</span> AccountRowMapper()，<span class="number">500</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (Account account : accounts) &#123;</span><br><span class="line">      		System.out.print1n(account);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountRowMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">Account</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account();</span><br><span class="line">        account.setId(rs.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">        account.setName(rs.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        account.setMoney(rs.getFloat(<span class="string">&quot;money&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> account;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>Spring 中的 RowMapper 可以将返回的每行数据分装成一个用户自定义的类。此处的 AccountRowMapper 则是将查询到的每行数据封装成一个个 Account 用户。</li>
</ul>
<h2 id="在Dao中使用"><a href="#在Dao中使用" class="headerlink" title="在Dao中使用"></a>在Dao中使用</h2><p>1.准备实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Float money;</span><br><span class="line">    getter/setter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.1在dao中定义JdbcTemplate</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJdbcTemplate</span><span class="params">(JdbcTemplate jdbcTemplate)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.jdbcTemplate = jdbcTemplate;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置一个dao--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.AccountDaoImpl&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--注入jdbcTemplate--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;jdbcTemplate&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是这样会导致多个dao中有许多重复的定义方法。</p>
<p>2.2让dao继承JdbcTemplate</p>
<ul>
<li><p>JdbcDaoSupport 是 spring 框架为我们提供的一个类，该类中定义了一个JdbcTemplate 对象，我们可以直接获取使用，但是要想创建该对象，需要为其提供一个数据源。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcDaoSupport</span> <span class="keyword">extends</span> <span class="title">DaoSupport</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义对象</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line">    <span class="comment">//set方法注入数据源，判断是否注入了，注入了就创建JdbcTemplate</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setDataSource</span> <span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.jdbcTemplate == <span class="keyword">null</span> || dataSource != <span class="keyword">this</span>.jdbcTemplate.getDataSource())&#123;</span><br><span class="line">            <span class="comment">//如果提供了数据源就创建JdbcTemplate</span></span><br><span class="line">            <span class="keyword">this</span>.jdbcTemplate = createJdbcTemplate (dataSource) ;</span><br><span class="line">            initTemplateConfig();</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>让dao继承JdbcDaoSupport</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl2</span> <span class="keyword">extends</span> <span class="title">JdbcDaoSupport</span> <span class="keyword">implements</span> <span class="title">IAccountDao</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>就可以使用父类的 getJdbcTemplate（） 方法获取</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置dao2--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao2&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.AccountDaoImol2&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--注入dataSource--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>区别：<ul>
<li>第一种在Dao类中定义 JdbcTemplate 的方式，适用于所有配方式( xml 和注解都可以)。</li>
<li>第二种让Dao继承 JdbeDaoSupport 的方式，只能用于基于 XML 的方式，注解用不了。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>MyBatis入门搭建</title>
    <url>/2020/07/04/202074-MyBatis%E5%85%A5%E9%97%A8%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>在Maven中配置一个对MySQL进行CRUD的简单例子</p>
<span id="more"></span>

<h2 id="一、创建maven工程并导入坐标"><a href="#一、创建maven工程并导入坐标" class="headerlink" title="一、创建maven工程并导入坐标"></a>一、创建maven工程并导入坐标</h2><p>Maven创建时出现：</p>
<p>Cannot resolve plugin org.apache.maven.plugins:maven-clean-plugin:2.5</p>
<p>出现插件无法加载，是maven的配置出现问题</p>
<p><img src="/images/MyBatis/mavenConfig.png" alt="image-20200623100242831"></p>
<p>导入坐标（依赖）：</p>
<p><img src="/images/MyBatis/dependence.png" alt="image-20200623103757129"></p>
<h3 id="二、创建实体类和dao接口"><a href="#二、创建实体类和dao接口" class="headerlink" title="二、创建实体类和dao接口"></a>二、创建实体类和dao接口</h3><p><img src="/images/MyBatis/construction.png" alt="image-20200623103839205"></p>
<p>实体类中的变量名称和数据库中的保持一致</p>
<p><img src="/images/MyBatis/attribute.png" alt="image-20200623103907554"></p>
<p><img src="/images/MyBatis/dbColumn.png" alt="image-20200623103944899"></p>
<h3 id="三、创建mybatis主配置文件"><a href="#三、创建mybatis主配置文件" class="headerlink" title="三、创建mybatis主配置文件"></a>三、创建mybatis主配置文件</h3><p>SqlMapConfig.xml</p>
<p><img src="/images/MyBatis/SqlMapConfig.png" alt="image-20200623104114826"></p>
<p>以及下一步需要的映射配置文件位置</p>
<p><img src="/images/MyBatis/resource.png" alt="image-20200623104202619"></p>
<h3 id="四、创建映射配置文件"><a href="#四、创建映射配置文件" class="headerlink" title="四、创建映射配置文件"></a>四、创建映射配置文件</h3><p>IUserDao.xml</p>
<p><img src="/images/MyBatis/IUserDao.png" alt="image-20200623104244095"></p>
<p>配置对应的IUserDao中方法于select中</p>
<p><img src="/images/MyBatis/Sql.png" alt="image-20200623104253901"></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>环境搭建的注意事项：<br>第一个：创建IUserDao.xml 和 IUserDao.java时名称是为了和我们之前的知识保持一致。 在Mybatis中它把持久层的操作接口名称和映射文件也叫做：Mapper，所以：IUserDao 和 IUserMapper是一样的<br>第二个：在idea中创建目录的时候，它和包是不一样的 包在创建时：com.itheima.dao它是三级结构 目录在创建时：com.itheima.dao是一级目录<br>第三个：mybatis的映射配置文件位置必须和dao接口的包结构相同<br>第四个：映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名<br>第五个：映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法名</p>
<ul>
<li>当我们遵从了第三，四，五点之后，我们在开发中就<strong>无须再写dao的实现类。</strong></li>
</ul>
<h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><p><img src="/images/MyBatis/error1.png" alt="image-20200623150326980"></p>
<p>IUserDao.xml 未指定返回类型</p>
<p><img src="/images/MyBatis/resultType.png" alt="image-20200623150421533"></p>
<p>指定后返回User类型</p>
<p><img src="/images/MyBatis/returnResult.png" alt="image-20200623151000236"></p>
<p><img src="/images/MyBatis/analyze1.png" alt="img"></p>
<p><img src="/images/MyBatis/analyze2.png" alt="入门案例的分析"></p>
<h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><h3 id="使用-xml-方式"><a href="#使用-xml-方式" class="headerlink" title="使用 xml 方式"></a>使用 xml 方式</h3><p>在IUserDao接口中写出方法</p>
<p><img src="/images/MyBatis/IUserDaoClass.png" alt="image-20200625091223684"></p>
<p>在IUserDao.xml中配置方法</p>
<p><img src="/images/MyBatis/IUserDaoXml.png" alt="image-20200625091318129"></p>
<p>在MyBatisTest测试类方法实现</p>
<p><img src="/images/MyBatis/testSave.png" alt="image-20200625091551914"></p>
<h3 id="使用注解方式"><a href="#使用注解方式" class="headerlink" title="使用注解方式"></a>使用注解方式</h3><p>在接口方法上标注注解（Select , Insert , Update , Delete）</p>
<p><img src="/images/MyBatis/explain.png" alt="image-20200628094307199"></p>
<p>在Test类中编写方法实现</p>
<p><img src="/images/MyBatis/test.png" alt="image-20200628094431365"></p>
<p><img src="/images/MyBatis/test2.png" alt="image-20200628094446934"></p>
<h2 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h2><h3 id="Error-java-不支持发行版本xxx-的问题"><a href="#Error-java-不支持发行版本xxx-的问题" class="headerlink" title="Error : java 不支持发行版本xxx 的问题"></a>Error : java 不支持发行版本xxx 的问题</h3><ol>
<li><p>配置一 在 Setting-&gt;Java Compiler 中将 Project bytecode version 与 target bytecode version 全部设为与本地版本相同的 version 13。</p>
</li>
<li><p>配置二 在 Project Structure-&gt;Modules-&gt;Language level 也设置成 13，与上面配置的版本一致。</p>
</li>
<li><p>配置三 我是先根据博客上面说的前面两个步骤来配置，发现还是有问题。其实在进行第二处配置之后，idea 会弹出一个警告：jdk的版本可能会被maven项目覆盖了。于是在 pom.xml 文件中，我们指定编译器的jdk版本： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                         <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">configuration</span>&gt;</span> <span class="comment">&lt;!--让编译器使用本地的xx版本jdk--&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">source</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">source</span>&gt;</span> 	</span><br><span class="line">		<span class="tag">&lt;<span class="name">target</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">target</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>把上面这一串代码直接丢到</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="实体类名和数据库的列名不匹配"><a href="#实体类名和数据库的列名不匹配" class="headerlink" title="实体类名和数据库的列名不匹配"></a>实体类名和数据库的列名不匹配</h3><h4 id="xml配置中的问题"><a href="#xml配置中的问题" class="headerlink" title="xml配置中的问题"></a>xml配置中的问题</h4><p>第一种方法（起别名，让数据库别名和实体类匹配）</p>
<p>效率高（直接运行改后的sql），但是麻烦</p>
<p><img src="/images/MyBatis/%E8%B5%B7%E5%88%AB%E5%90%8D.png" alt="image-20200625095654969"></p>
<p>第二种方法（配置返回值结果和实体类的关系）</p>
<p>效率低（二次解析resultMap配置），但是省事可复用</p>
<p><img src="/images/MyBatis/resultMap.png" alt="image-20200625100006550"></p>
<h4 id="注解配置中的问题"><a href="#注解配置中的问题" class="headerlink" title="注解配置中的问题"></a>注解配置中的问题</h4><p>第一种方法（起别名，让数据库别名和实体类匹配）</p>
<p>效率高（直接运行改后的sql），但是麻烦</p>
<p><img src="/images/MyBatis/%E8%B5%B7%E5%88%AB%E5%90%8D2.png" alt="image-20200625095654969"></p>
<p>第二种方法在 dao 中加注释</p>
<p><img src="/images/MyBatis/daoAnotation.png" alt="image-20200628094658908"></p>
<p><img src="/images/MyBatis/daoAnotation2.png" alt="image-20200628094852512"></p>
<p><img src="/images/MyBatis/daoAnotation3.png" alt="image-20200628095535721"></p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
  </entry>
  <entry>
    <title>有关线程的知识点</title>
    <url>/2020/07/04/202074-%E6%9C%89%E5%85%B3%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>认识线程的创建、以及可用的方法</p>
<span id="more"></span>

<h1 id="创建线程的三种方法"><a href="#创建线程的三种方法" class="headerlink" title="创建线程的三种方法"></a>创建线程的三种方法</h1><h2 id="1-继承-Thread-类"><a href="#1-继承-Thread-类" class="headerlink" title="1. 继承 Thread 类"></a>1. 继承 Thread 类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　 System.out.println(<span class="string">&quot;MyThread is run.&quot;</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，调用该类的 start 方法就可以启动一个线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">myThread.start();</span><br></pre></td></tr></table></figure>

<p>该方法方便、快捷，但是用继承的方法实现就会有一定限制。如果是一个子类，那么，它就不能通过继承的方法来创建线程。</p>
<h2 id="2-实现-Runnable-接口-无返回值"><a href="#2-实现-Runnable-接口-无返回值" class="headerlink" title="2. 实现 Runnable 接口(无返回值)"></a>2. 实现 Runnable 接口(无返回值)</h2><p>通过实现接口的方式就可以有效避免 Java 单继承的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">OtherClass</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　 System.out.println(<span class="string">&quot;MyThread is run.&quot;</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了启动MyThread，需要首先实例化一个Thread，并传入自己的MyThread实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(myThread);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p>当传入一个实现了 Runnable 接口的类给 Thread 后，Thread的run()方法就会调用target.run()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">　　 target.run();</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-实现-Callable-接口-有返回值"><a href="#3-实现-Callable-接口-有返回值" class="headerlink" title="3. 实现 Callable 接口(有返回值)"></a>3. 实现 Callable 接口(有返回值)</h2><p>执行Callable任务后，可以获取一个Future的对象，在该对象上调用get就可以获取到Callable任务返回的Object了，再结合线程池接口ExecutorService就可以实现传说中有返回结果的多线程了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 有返回值的线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException,</span></span><br><span class="line"><span class="function">    InterruptedException </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;----程序开始运行----&quot;</span>);</span><br><span class="line">   Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">int</span> taskSize = <span class="number">5</span>;</span><br><span class="line">   <span class="comment">// 创建一个线程池</span></span><br><span class="line">   ExecutorService pool = Executors.newFixedThreadPool(taskSize);</span><br><span class="line">   <span class="comment">// 创建多个有返回值的任务</span></span><br><span class="line">   List&lt;Future&gt; list = <span class="keyword">new</span> ArrayList&lt;Future&gt;();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskSize; i++) &#123;</span><br><span class="line">    Callable c = <span class="keyword">new</span> MyCallable(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="comment">// 执行任务并获取Future对象</span></span><br><span class="line">    Future f = pool.submit(c);</span><br><span class="line">    <span class="comment">// System.out.println(&quot;&gt;&gt;&gt;&quot; + f.get().toString());</span></span><br><span class="line">    list.add(f);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 关闭线程池</span></span><br><span class="line">   pool.shutdown();</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 获取所有并发任务的运行结果</span></span><br><span class="line">   <span class="keyword">for</span> (Future f : list) &#123;</span><br><span class="line">    <span class="comment">// 从Future对象上获取任务的返回值，并输出到控制台</span></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&quot;</span> + f.get().toString());</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   Date date2 = <span class="keyword">new</span> Date();</span><br><span class="line">   System.out.println(<span class="string">&quot;----程序结束运行----，程序运行时间【&quot;</span></span><br><span class="line">     + (date2.getTime() - date1.getTime()) + <span class="string">&quot;毫秒】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String taskNum;</span><br><span class="line"> </span><br><span class="line">MyCallable(String taskNum) &#123;</span><br><span class="line">   <span class="keyword">this</span>.taskNum = taskNum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;&gt;&gt;&gt;&quot;</span> + taskNum + <span class="string">&quot;任务启动&quot;</span>);</span><br><span class="line">   Date dateTmp1 = <span class="keyword">new</span> Date();</span><br><span class="line">   Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">   Date dateTmp2 = <span class="keyword">new</span> Date();</span><br><span class="line">   <span class="keyword">long</span> time = dateTmp2.getTime() - dateTmp1.getTime();</span><br><span class="line">   System.out.println(<span class="string">&quot;&gt;&gt;&gt;&quot;</span> + taskNum + <span class="string">&quot;任务终止&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> taskNum + <span class="string">&quot;任务返回运行结果,当前任务时间【&quot;</span> + time + <span class="string">&quot;毫秒】&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="sleep和yield的区别"><a href="#sleep和yield的区别" class="headerlink" title="sleep和yield的区别"></a>sleep和yield的区别</h1><p>①<strong>sleep方法</strong>给其他线程运行机会时不考虑线程的优先级,因此会给低线程优先级运行的机会,而<strong>yield方法</strong>只会给相同优先级或者更高优先级线程运行的机会</p>
<p>②线程执行<strong>sleep()方法</strong>后转入阻塞状态,所以,执行sleep()方法的线程在指定的时间内不会被执行,而<strong>yield()方法</strong>只是使当前线程重新回到可执行状态,所以执行yield()方法的线程可能在进入可执行状态后马上又被执行</p>
<p>③<strong>sleep()方法</strong>声明抛出InterruptedException,而<strong>yield()方法</strong>没有声明任何异常</p>
<p>④<strong>sleep()方法</strong>比yield()方法(跟操作系统相关)有<strong>更好的可移植性</strong></p>
<h1 id="start-和-run-的区别"><a href="#start-和-run-的区别" class="headerlink" title="start() 和 run() 的区别"></a>start() 和 run() 的区别</h1><p><strong>一：Java中Thread.start和Thread.run是什么？</strong></p>
<p>1.Java中的start()方法是什么？</p>
<p>线程类的start()方法可以用来启动线程；该方法会在内部调用Runnable接口的run()方法，以在<strong>单独的线程</strong>中执行run()方法中指定的代码。</p>
<p>start()方法启动线程执行以下任务：</p>
<p>1.1 它统计了一个<strong>新线程</strong></p>
<p>1.2线程从New State移动到<strong>Runnable状态</strong>。</p>
<p>1.3 当线程有机会执行时，它的目标run()方法将运行。</p>
<p>2.Java中的run()方法是什么？</p>
<p>线程类的run()方法是Runnable接口的一个<strong>抽象方法</strong>，由<strong>java虚拟机直接调用</strong>的，不会创建的新线程。</p>
<p><strong>二：start()方法和run()方法的区别有哪些</strong></p>
<p><strong>1、方法的定义</strong></p>
<p>start()方法在<strong>java.lang.Thread类</strong>中定义；而，run()方法在<strong>java.lang.Runnable接口</strong>中定义，必须在实现类中重写。</p>
<p><strong>2、新线程创建</strong></p>
<p>当程序调用start()方法时，会创建一个新线程，然后执行run()方法。但是如果我们直接调用run()方法，则不会创建新的线程，run()方法将作为当前调用线程本身的常规方法调用执行，并且不会发生多线程。</p>
<p><strong>3、多次调用</strong></p>
<p><strong>start()方法不能多次调用</strong>，否则抛出java.lang.IllegalStateException；而，<strong>run()方法可以进行多次调用</strong>，因为它只是一种正常的方法调用。</p>
<h1 id="脏读、幻读、不可重复读"><a href="#脏读、幻读、不可重复读" class="headerlink" title="脏读、幻读、不可重复读"></a>脏读、幻读、不可重复读</h1><ul>
<li>脏读</li>
</ul>
<p>（<strong>针对未提交数据</strong>）如果一个事务中对数据进行了更新，但事务还没有提交，另一个事务可以“看到”该事务没有提交的更新结果，这样造成的问题就是，如果第一个事务回滚，那么，第二个事务在此之前所“看到”的数据就是一笔脏数据。</p>
<ul>
<li>幻读—修改</li>
</ul>
<p>（<strong>针对其他提交前后，读取数据条数的对比</strong>） 幻读是指同样一笔查询在整个事务过程中多次执行后，查询所得的结果集是不一样的。幻读针对的是多笔记录。在Read Uncommitted隔离级别下， 不管事务2的插入操作是否提交，事务1在插入操作之前和之后执行相同的查询，取得的结果集是不同的，所以，Read Uncommitted同样无法避免幻读的问题。</p>
<ul>
<li>不可重复读—增加或删除</li>
</ul>
<p>（<strong>针对其他提交前后，读取数据本身的对比</strong>）不可重复读取是指同一个事务在整个事务过程中对同一笔数据进行读取，每次读取结果都不同。如果事务1在事务2的更新操作之前读取一次数据，在事务2的更新操作之后再读取同一笔数据一次，两次结果是不同的，所以，Read Uncommitted也无法避免不可重复读取的问题。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>线程</category>
      </categories>
  </entry>
  <entry>
    <title>SpringMVC入门</title>
    <url>/2020/08/03/202083-SpringMVC%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>SpringMVC 作为 Java 进行 B/S 架构开发的一个标准</p>
<span id="more"></span>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><p>开发架构一般基于两种形式，一种是 C/S 架构，也就是客户端/服务器，另一种是 B/S 架构，也就是浏览器/服务器。在 JavaEE 开发中，几乎全都是基于 B/S 架构的开发，在此架构中，系统标准的三层架构包括：表现层、业务层、持久层。</p>
<ul>
<li><strong>表现层</strong> 也就是我们常说的<strong>web层</strong>。它负责<strong>接收客户端请求</strong>，向客户端响应结果，通常客户端使用http协议请求web 层，web 需要接收 http 请求，完成 http 响应。 表现层包括展示层和控制层：控制层负责接收请求，展示层负责结果的展示。 表现层依赖业务层，接收到客户端请求一般会调用业务层进行业务处理，并将处理结果响应给客户端。 <strong>表现层的设计一般都使用 MVC 模型。（MVC 是表现层的设计模型，和其他层没有关系）</strong></li>
<li><strong>业务层</strong> 也就是我们常说的 <strong>service 层</strong>。它负责<strong>业务逻辑处理</strong>，和我们开发项目的需求息息相关。web 层依赖业务层，但是业务层不依赖 web 层。 业务层在业务处理时可能会依赖持久层，如果要对数据持久化需要保证事务一致性。（也就是我们说的，事务应该放到业务层来控制）</li>
<li><strong>持久层</strong> 也就是我们是常说的 <strong>dao 层</strong>。负责<strong>数据持久化</strong>，包括数据层即数据库和数据访问层，数据库是对数据进行持久化的载体，数据访问层是业务层和持久层交互的接口，业务层需要通过数据访问层将数据持久化到数据库中。通俗的讲，持久层就是和数据库交互，对数据库表进行增删改查的。</li>
</ul>
<h3 id="MVC模型"><a href="#MVC模型" class="headerlink" title="MVC模型"></a>MVC模型</h3><p>MVC 全名是 Model View Controller，是模型—视图—控制器的缩写，是一种用于设计创建Web 应用程序表现层的模式。MVC 中每个部分各司其职：</p>
<ul>
<li>Model 通常指的就是我们的<strong>数据模型</strong>。作用一般情况下用于<strong>封装数据</strong>。</li>
<li>View 通常指的就是我们的 <strong>jsp 或者 html</strong>。作用一般就是<strong>展示数据</strong>的。 通常视图是依据模型数据创建的。</li>
<li>Controller 是应用程序中处理<strong>用户交互</strong>的部分。作用一般就是<strong>处理程序逻辑</strong>的。</li>
</ul>
<h2 id="SpringMVC概念"><a href="#SpringMVC概念" class="headerlink" title="SpringMVC概念"></a>SpringMVC概念</h2><p><img src="/images/SpringMVC/analy_pic.png" alt="image-20200807091506299"></p>
<h2 id="SpringMVC的优势"><a href="#SpringMVC的优势" class="headerlink" title="SpringMVC的优势"></a>SpringMVC的优势</h2><p>1、清晰的<strong>角色划分</strong>:<br>            前端控制器(Di spa tcherServlet)<br>            请求到处理器映射( HandlerMapping)<br>            处理器适配器(HandlerAdapter)<br>            视图解析器(ViewResolver)<br>            处理器或页面控制器(Controller)<br>            验证器( Validator)<br>            命令对象(Command请求参数绑定到的对象就叫命令对象)<br>            表单对象(Form Object提供给表单展示和提交到的对象就叫表单对象)。<br>2、<strong>分工明确</strong>，而且扩展点相当灵活，可以很容易扩展，虽然几乎不需要。<br>3、由于命令对象就是一个POJO，无需继承框架特定API,可以<strong>使用命令对象直接作为业务对象</strong>。<br>4、<strong>和Spring其他框架无缝集成</strong>，是其它Web框架所不具备的。<br>5、<strong>可适配</strong>，通过HandlerAdapter可以支持任意的类作为处理器。<br>6、<strong>可定制性</strong>，HandlerMapping、 ViewResolver 等能够非常简单的定制。<br>7、功能强大的<strong>数据验证、格式化、绑定机制</strong>。<br>8、利用Spring提供的Mock对象能够非常简单的进行<strong>Web层单元测试</strong>。<br>9、<strong>本地化、主题的解析的支持</strong>，使我们更容易进行国际化和主题的切换。<br>10、强大的<strong>JSP标签库</strong>，使JSP编写更容易。<br>        ……还有比如RESTful风格的支持、简单的文件上传、约定大于配置的契约式编程支持、基于注解的零配置支持等等。</p>
<h2 id="SpringMVC-和-Struts2-的优劣分析"><a href="#SpringMVC-和-Struts2-的优劣分析" class="headerlink" title="SpringMVC 和 Struts2 的优劣分析"></a>SpringMVC 和 Struts2 的优劣分析</h2><p>共同点:<br>        它们都是表现层框架，都是<strong>基于 MVC 模型</strong>编写的。<br>        它们的底层都离不开原始 <strong>ServletAPI</strong>。<br>        它们处理请求的机制都是一个<strong>核心控制器</strong>。<br>区别:<br>        Spring MVC 的入口是 Servlet,而 Struts2 是 Filter<br>        Spring MVC 是基于方法设计的，而 Struts2 是基于类，Struts2 每次执行都会创建一个动作类。所以 Spring MVC 会稍微比 Struts2 快些。<br>        Spring MVC 使用更加简洁，同时还支持 JSR303 ,处理 ajax 的请求更方便<br>        ( JSR303 是一套 JavaBean 参数校验的标准，它定义了很多常用的校验注解，我们可以直接将这些注解加在我们 JavaBean 的属性上面，就可以在需要校验的时候进行校验了。)<br>        Struts2 的 OGNL 表达式使页面的开发效率相比 Spring MVC 更高些，但执行效率并没有比 JSTL 提升，尤其是 struts2 的表单标签，远没有 html 执行效率高。</p>
<h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><h3 id="配置步骤"><a href="#配置步骤" class="headerlink" title="配置步骤"></a>配置步骤</h3><p>1.创建 web 工程，引入开发的 jar 包</p>
<p>pom.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--版本锁定--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span> &gt;</span>spring-webd/artifactId&gt;</span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        &lt;artifactIdspring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.serv1et.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.配置核心控制器（DispatcherServlet）</p>
<p>web.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--SpringMVC的核心控制器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--配置Servlet的初始化参数，读取springmvc的配置文件，创建spring容器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--配置servlet启动时加载对象--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.配置springmvc.xml</p>
<p>springmvc.xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1. 0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:mvc</span>=<span class="string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://Www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/mvc/spring-mvc.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置spring创建容器时要扫描的包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置视图解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;viewResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INF/pages/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置spring开启注解mvc的支持</span></span><br><span class="line"><span class="comment">    &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4.编写index.jsp和HelloController控制器类</p>
<p>index.jsp:</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h3&gt;</span><br><span class="line">        入门案例</span><br><span class="line">    &lt;/h3&gt;</span><br><span class="line">    &lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/hello&quot;</span>&gt;入门案例&lt;/a&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>HelloController:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*控制器</span></span><br><span class="line"><span class="comment">* <span class="doctag">@authorrt</span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*接收请求</span></span><br><span class="line"><span class="comment">    * @return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@RequestMapping(path=&quot;/hello&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print1n(<span class="string">&quot;Hello SpringMVC!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.在WEB-INF目录下创建pages文件夹，编写success.jsp的成功页面</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h3&gt;</span><br><span class="line">        入门成功！</span><br><span class="line">    &lt;/h3&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>

<p>6.启动Tomcat服务器，进行测试</p>
<h3 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h3><ol>
<li>当启动 Tomcat 服务器的时候，因为配置了 load-on-startup 标签，所以会创建 DispatcherServlet 对象，就会加载 springmvc.xml 配置文件</li>
<li>开启了注解扫描，那么 HelloController 对象就会被创建</li>
<li>从 index.jsp 发送请求，请求会先到达 DispatcherServlet 核心控制器，根据配置 @RequestMapping 注解找到执行的具体方法</li>
<li>根据执行方法的返回值，再根据配置的视图解析器，去指定的目录下查找指定名称的 JSP 文件</li>
<li>Tomcat 服务器渲染页面，做出响应</li>
</ol>
<p><img src="/images/SpringMVC/process.png" alt="image-20200808080428507"></p>
<h2 id="请求参数的绑定"><a href="#请求参数的绑定" class="headerlink" title="请求参数的绑定"></a>请求参数的绑定</h2><p>1.请求参数的绑定说明</p>
<p>​    绑定机制</p>
<p>​    表单提交的数据都是 k=v 格式的 username=haha&amp;password=123</p>
<p>​    SpringMVC 的参数绑定过程是把表单提交的请求参数，作为控制器中方法的参数进行绑定的</p>
<p>​    要求：提交表单的name和参数的名称是相同的</p>
<p>2.支持的数据类型</p>
<p>​    基本数据类型和字符串类型</p>
<p>​    实体类型（JavaBean）</p>
<p>​    集合数据类型（List、map集合等）</p>
<p><strong>基本数据类型和字符串类型：</strong></p>
<ul>
<li><p>提交表单的name和参数的名称是相同的</p>
</li>
<li><p>区分大小写</p>
</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!--基本类型示例--&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;account/findAccount?accountId=10&amp;accountName=zhangsan&quot;</span>&gt;查询账户&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/findAccount&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findAccount</span><span class="params">(Integer accountId, String accountName)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实体类型（JavaBean）：</strong></p>
<ul>
<li><p>提交表单的name和JavaBean中的属性名称需要一致</p>
</li>
<li><p>如果一个JavaBean类中包含其他的引用类型，那么表单的name属性需要编写成：对象.属性 例如：address.name</p>
</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!--POJO类型演示--&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;account/saveAccount&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    账户名称：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">    账户金额：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;money&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">    账户省份：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;address.provinceName&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">    账户城市：&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;address.cityName&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;保存&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/saveAccount&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">saveAccount</span><span class="params">(Account account)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p><strong>给集合属性数据封装：</strong></p>
<ul>
<li>JSP页面编写方式：list[0].属性</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">账户<span class="number">1</span>名称: &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;accounts[0].name&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">账户<span class="number">1</span>金额: &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;accounts[0].money&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">账户<span class="number">2</span>名称: &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;accounts[1].name&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">账户<span class="number">2</span>金额: &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;accounts[1].money&quot;</span>&gt;&lt;br/&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/updateAccount&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">updateAccount</span><span class="params">(User user)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>3.请求参数中文乱码的解决</p>
<ul>
<li>在web.xml中配置Spring提供的过滤器类</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置过滤器，解决中文乱码的问题--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定字符集--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-va1ue</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4.自定义类型转换器</p>
<ul>
<li><p>表单提交的任何数据类型全部都是字符串类型，但是后台定义Integer类型，数据也可以封装上，说明Spring框架内部会<strong>默认进行数据类型转换</strong>。</p>
</li>
<li><p>如果想自定义数据类型转换，可以实现Converter的接口</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">把字符串转换成日期的转换器</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> rt</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToDateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *进行类型转换的方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断</span></span><br><span class="line">        <span class="keyword">if</span>(source == nu11) &#123;</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;参数不能为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        	<span class="comment">//解析字符串</span></span><br><span class="line">            Date date = df.parse(source);</span><br><span class="line">            <span class="keyword">return</span> date;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;类型转换错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.注册自定义类型转换器，在springmvc.xml配置文件中编写配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册自定义类型转换器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;conversionService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ConversionServiceFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;converters&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.itcast.utils.StringToDateConverter&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--开启Spring对MVC注解的支持--&gt;</span></span><br><span class="line">&lt;mvc:annotation-drivenconversion-service=&quot;conversionService&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>5.在控制器中使用原生的 ServletAPI 对象</p>
<ul>
<li>只需要在控制器的方法参数定义 HttpServletRequest 和 HttpServletResponse 对象</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!--原始ServletAPI作为控制器参数--&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;account/testServletAPI&quot;</span>&gt;测试访问ServletAPI&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testServletAPI</span><span class="params">(HttpServletRequest request,</span></span></span><br><span class="line"><span class="params"><span class="function">                            HttpServletResponse response,</span></span></span><br><span class="line"><span class="params"><span class="function">                            HttpSession session)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title>SSM整合</title>
    <url>/2020/08/10/2020810-SSM%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<p>SSM 就是指 Spring + SpringMVC + MyBatis，常被用为数据源较简单的 web 项目框架</p>
<span id="more"></span>

<h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>1.创建数据库和表结构</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> database ssm;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> account(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    money <span class="keyword">double</span>(<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>2.创建maven工程</p>
<p>在工程下创建子模块</p>
<table>
<thead>
<tr>
<th>ssm_domain</th>
<th>jar</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ssm_dao</strong></td>
<td><strong>jar</strong></td>
</tr>
<tr>
<td><strong>ssm_service</strong></td>
<td><strong>jar</strong></td>
</tr>
<tr>
<td><strong>ssm_web</strong></td>
<td><strong>war</strong></td>
</tr>
</tbody></table>
<p>3.导入如下坐标依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring</span><br><span class="line">slf4j</span><br><span class="line">log4j</span><br><span class="line">shiro</span><br><span class="line">mysql</span><br><span class="line">mybatis</span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4.编写实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Float money;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.编写业务层接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.编写持久层接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(Account account)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="整合步骤"><a href="#整合步骤" class="headerlink" title="整合步骤"></a>整合步骤</h2><h3 id="保证spring框架在web工程中独立运行"><a href="#保证spring框架在web工程中独立运行" class="headerlink" title="保证spring框架在web工程中独立运行"></a>保证spring框架在web工程中独立运行</h3><p>1.编写spring配置文件并导入约束</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding= &quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">				http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置spring创建容器时要扫描的包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--制定扫包规则，不扫描@Controller注解的JAVA类，其他的还是要扫描--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.使用注解配置业务层和持久层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAllAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountDao.findAllAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;accountDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Account&gt; <span class="title">findAllAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;查询了所有账户&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.测试spring能否独立运行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test01Spring</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        IAccountService as = ac.getBean(<span class="string">&quot;accountService&quot;</span>, IAccountService.class);</span><br><span class="line">        as.findAllAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/SpringMVC/test_result.png" alt="test_result"></p>
<h3 id="保证SpringMVC在web工程中独立运行"><a href="#保证SpringMVC在web工程中独立运行" class="headerlink" title="保证SpringMVC在web工程中独立运行"></a>保证SpringMVC在web工程中独立运行</h3><p>1.在web.xml中配置核心控制器(DispatcherServlet)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置spring mvc的核心控制器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvcDispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.Dispatcherservlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--配置初始化参数，用于读取springmvc的配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--配置servlet的对象的创建时间点:应用加载时创建。取值只能是非0正整数，表示启动顺</span></span><br><span class="line"><span class="comment">序--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvcDispatcherservlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置springMVC编码过滤器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilterk<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置过滤器中的属性值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--启动过滤器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--过滤所有请求--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.编写springmvc的配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--省略约束头文件--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置创建spring容器要扫描的包--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--制定扫包规则,只扫描使用@Controller注解的JAVA类--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置视图解析器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;prefix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/WEB-INE/pages/&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;suffix&quot;</span> <span class="attr">value</span>=<span class="string">&quot;.jsp&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.编写controller和jsp页面</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;account/findAllAccount&quot;</span>&gt;访问查询账户&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller(&quot;accountController&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/findAllAccount&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findAllAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;执行了查询账户&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="整合spring和springmvc"><a href="#整合spring和springmvc" class="headerlink" title="整合spring和springmvc"></a>整合spring和springmvc</h3><p>目的：在controller中能够成功调用service对象中的方法</p>
<p>1.在项目启动的时候，加载applicationContext.xml的配置文件，在web.xml中配置ContextLoaderListener监听器（该监听器只能加载WEB-INF目录下的applicationContext.xml的配置文件）。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Spring的监听器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderlistener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置加载类路径的配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfiglocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.在controller中注入service对象，调用其方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccountService accoutService;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *查询所有的数据</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/findAll&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;表现层:查询所有账户...&quot;</span>);</span><br><span class="line">        accoutService.findA11();</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;list&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="保证mybatis框架在web工程中独立运行"><a href="#保证mybatis框架在web工程中独立运行" class="headerlink" title="保证mybatis框架在web工程中独立运行"></a>保证mybatis框架在web工程中独立运行</h3><p>1.编写AccountDao映射配置文件</p>
<ul>
<li>注意：我们使用代理 dao 的方式来操作持久层，所以此处 Dao 的实现类就是多余的了。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">    <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> </span></span><br><span class="line"><span class="meta">    <span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.dao.IAccountDao&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findA1l&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.itheima.domain.Account&quot;</span>&gt;</span></span><br><span class="line">	select * from account</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.编写SqlMapConfig配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta"><span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbcConfig.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;pooled&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$ &#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;com/itheima/dao/AccountDao.xml&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>jdbcConfig.properties:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://1ocalhost:3306/ssm，</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">1234</span></span><br></pre></td></tr></table></figure>

<p>3.测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Account account = <span class="keyword">new</span> Account();</span><br><span class="line">    account.setName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">    account.setMoney(<span class="number">5000f</span>);</span><br><span class="line">    InputStream in = Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">    Sq1SessionFactory factory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(in);</span><br><span class="line">    SqlSession session = factory.openSession();</span><br><span class="line">    IAccountDao aDao = session.getMapper(IAccountDao.class);</span><br><span class="line">    aDao.save(account);</span><br><span class="line">    session.commit();</span><br><span class="line">    session.close();</span><br><span class="line">    in.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="整合spring和mybatis"><a href="#整合spring和mybatis" class="headerlink" title="整合spring和mybatis"></a>整合spring和mybatis</h3><p>整合思路： 把 mybatis 配置文件（SqlMapConfig.xml）中内容配置到 spring 配置文件中同时，把 mybatis 配置文件的内容清掉。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta"><span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意： 由于我们使用的是代理 Dao 的模式，Dao 具体实现类由 MyBatis 使用代理方式创建，所以此时 mybatis 配置文件不能删。 当我们整合 spring 和 mybatis 时，mybatis 创建的 Mapper.xml 文件名必须和 Dao 接口文件名一致</li>
</ul>
<p>1.spring接管mybatis的session工厂</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--加载配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:jdbcConfig.properties&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置MyBatis的Session工厂--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--数据库连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载mybatis的全局配置文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;configLocation&quot;</span> <span class="attr">value</span>=<span class="string">&quot;classpath:Sq1MapConfig.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.配置自动扫描所有Mapper接口和文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置Mapper扫描器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basePackage&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.itheima.dao&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.配置spring的事务</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置事务的通知--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;SUPPORTS&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置aop --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置切入点表达式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>= <span class="string">&quot;execution (* com.itheima.service.impl.*.*(..))&quot;</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--建立通知和切入点表达式的关系--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4.测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations=&#123;&quot;classpath:applicationContext.xml&quot;&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test03SpringMabatis</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IAccountService accountService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List list = accountService.findAllAccount();</span><br><span class="line">        System.out.println(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account();</span><br><span class="line">        account.setName(<span class="string">&quot;测试账号&quot;</span>);</span><br><span class="line">        account.setMoney(<span class="number">1234f</span>);</span><br><span class="line">        accountService.saveAccount(account);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试SSM整合结果"><a href="#测试SSM整合结果" class="headerlink" title="测试SSM整合结果"></a>测试SSM整合结果</h2><p>1.编写测试jsp</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;account/findAIlAccount&quot;</span>&gt;访问查询账户&lt;/a&gt;</span><br><span class="line">&lt;hr/&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;account/saveAccount&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    账户名称: &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;name&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">    账户金额: &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;money&quot;</span>/&gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;保存&quot;</span>/&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;c:forEach items=<span class="string">&quot;$&#123;accounts&#125;&quot;</span> <span class="keyword">var</span>=<span class="string">&quot;account&quot;</span> varStatus=<span class="string">&quot;vs&quot;</span>&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;$&#123;vs.count&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;account.name&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;account.money&#125;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure>

<p>2.修改controller中的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller(&quot;accountController&quot;)</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/account&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IAccountService accountService ;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *查询所有账户</span></span><br><span class="line"><span class="comment">    *<span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span> (<span class="string">&quot;/findAllAccount&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">findAllAccount</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;Account&gt; accounts = accountService.findAllAccount();</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mv.addobject(<span class="string">&quot;accounts&quot;</span>, accounts);</span><br><span class="line">        mv.setViewName(<span class="string">&quot;accountlist&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.结果</p>
<p>jsp页面</p>
<p><img src="/images/SpringMVC/jsp.png" alt="image-20200809082350634"></p>
<p>返回结果</p>
<p><img src="./images/SpringMVC/return.png" alt="image-20200809082358685"></p>
<p>数据库数据</p>
<p><img src="/images/SpringMVC/database.png" alt="img"></p>
]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title>SpringMVC常用注解</title>
    <url>/2020/08/08/202088-SpringMVC%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>利用注解在前后端间传输数据</p>
<span id="more"></span>

<h2 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="RequestMapping"></a>RequestMapping</h2><p><strong>源码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Mapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;...&#125;</span><br></pre></td></tr></table></figure>

<p><strong>作用：</strong> 用于建立请求 URL 和处理请求方法之间的对应关系。</p>
<p><strong>属性：</strong><br>    value：用于指定请求的 URL。它和 path 属性的作用是一样的。<br>    method：用于指定请求的方式。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。<br>    params：用于指定限制请求参数的条件。它支持简单的表达式。要求请求参数的 key 和 value 必须和配置的一模一样。</p>
<p><strong>例如：</strong> params = {“accountName”}，表示请求参数必须有 accountName params = {“moeny!100”}，表示请求参数中 money 不能是 100。 headers：用于指定限制请求消息头的条件。</p>
<p><strong>注意：</strong> 以上四个属性只要出现 2 个或以上时，他们的关系是与的关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/findAccount&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findAccount</span><span class="params">()</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!--第一种访问方式--&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;$&#123;pageContext.request.contextPath&#125;/account/findAccount&quot;</span>&gt;</span><br><span class="line">	查询账户</span><br><span class="line">&lt;/a&gt;</span><br><span class="line">&lt;br/&gt;</span><br><span class="line">&lt;!--第二种访问方式--&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;account/findAccount&quot;</span>&gt;查询账户&lt;/a&gt; </span><br></pre></td></tr></table></figure>

<h2 id="RequestParam"><a href="#RequestParam" class="headerlink" title="RequestParam"></a><strong>RequestParam</strong></h2><p><strong>作用：</strong> 把请求中指定名称的参数给控制器中的形参赋值。</p>
<p><strong>属性：</strong><br>    value：请求参数中的名称。<br>    required：请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;springmvc/useRequestParam?name=test&quot;</span>&gt;requestParam注解&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/useRequestParam&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">useRequestParam</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span>String username,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="meta">@RequestParam(value=&quot;age&quot;,required=false)</span>Integer age)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RequestBody"><a href="#RequestBody" class="headerlink" title="RequestBody"></a>RequestBody</h2><p><strong>作用：</strong> 用于获取请求体内容。直接使用得到是 key=value&amp;key=value…结构的数据。 get 请求方式不适用。</p>
<p><strong>属性：</strong><br>    required：是否必须有请求体。默认值是:true。当取值为 true 时,get 请求方式会报错。如果取值为 false，get 请求得到是 null。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;springmvc/useRequestBody&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    用户名称: &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">	用户密码: &lt;input type=<span class="string">&quot;password&quot;</span> name=<span class="string">&quot;password&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">	用户年龄: &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;age&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">	&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;保存&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/useRequestBody&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">useRequestBody</span><span class="params">(<span class="meta">@RequestBody(required=false)</span>String body)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<h2 id="PathVaribale"><a href="#PathVaribale" class="headerlink" title="PathVaribale"></a>PathVaribale</h2><p><strong>作用：</strong> 用于绑定 url 中的占位符。例如：请求 url 中 /delete/{id}，这个{id}就是 url 占位符。 url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。</p>
<p><strong>属性：</strong><br>    value：用于指定 url 中占位符名称。<br>    required：是否必须提供占位符。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;springmvc/usePathVariable/100&quot;</span>&gt;pathVariable注解&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/usePathVariable/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">usePathVariable</span><span class="params">(<span class="meta">@PathVariable(&quot;id&quot;)</span>Integer id)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<h2 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="RequestHeader"></a>RequestHeader</h2><p><strong>作用：</strong> 用于获取请求消息头。</p>
<p><strong>属性：</strong><br>    value：提供消息头名称<br>    required：是否必须有此消息头</p>
<p><strong>注：</strong> 在实际开发中一般不怎么用。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;springmvc/useRequestHeader&quot;</span>&gt;获取请求消息头&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/useRequestHeader&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">useRequestHeader</span><span class="params">(<span class="meta">@RequestHeader(value=&quot;Accept-Language&quot;,</span></span></span></span><br><span class="line"><span class="meta"><span class="params"><span class="function">                                             required=false)</span>String requestHeader)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<h2 id="CookieValue"><a href="#CookieValue" class="headerlink" title="CookieValue"></a>CookieValue</h2><p><strong>作用：</strong> 用于把指定 cookie 名称的值传入控制器方法参数。</p>
<p><strong>属性：</strong><br>    value：指定 cookie 的名称。<br>    required：是否必须有此 cookie。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;springmvc/useCookieValue&quot;</span>&gt;绑定cookie的值&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/useCookieValue&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">useCookieValue</span><span class="params">(<span class="meta">@CookieValue(value=&quot;JSESSIONID&quot;,</span></span></span></span><br><span class="line"><span class="meta"><span class="params"><span class="function">                                             required=false)</span>String cookieValue)</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="ModelAttribute"></a>ModelAttribute</h2><p><strong>作用：</strong> 该注解是 SpringMVC4.3 版本以后新加入的。它可以用于修饰方法和参数。 出现在方法上，表示当前方法会在控制器的方法执行之前，先执行。它可以修饰没有返回值的方法，也可以修饰有具体返回值的方法。 出现在参数上，获取指定的数据给参数赋值。</p>
<p><strong>属性：</strong><br>    value：用于获取数据的 key。key 可以是 POJO 的属性名称，也可以是 map 结构的 key。</p>
<p><strong>应用场景：</strong> 当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。 例如： 我们在编辑一个用户时，用户有一个创建信息字段，该字段的值是不允许被修改的。在提交表单数据是肯定没有此字段的内容，一旦更新会把该字段内容置为 null，此时就可以使用此注解解决问题。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">&quot;springmvc/updateUser&quot;</span> method=<span class="string">&quot;post&quot;</span>&gt;</span><br><span class="line">    用户名称: &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;username&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">	用户年龄: &lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;age&quot;</span>&gt;&lt;br/&gt;</span><br><span class="line">	&lt;input type=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;保存&quot;</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showModel</span><span class="params">(String username, Map&lt;String,User&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//模拟取数据库数据</span></span><br><span class="line">    User user = findUserByName(username);</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    map.put(<span class="string">&quot;abc&quot;</span>,user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/updateUser&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testModelAttribute</span><span class="params">(<span class="meta">@ModelAttribute(&quot;abc&quot;)</span>User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SessionAttribute"><a href="#SessionAttribute" class="headerlink" title="SessionAttribute"></a>SessionAttribute</h2><p><strong>作用：</strong> 用于多次执行控制器方法间的参数共享。</p>
<p><strong>属性：</strong><br>    value：用于指定存入的属性名称 type：用于指定存入的数据类型。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;a href=<span class="string">&quot;springmvc/testPut&quot;</span>&gt;存入SessionAttribute&lt;/a&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;springmvc/testGet&quot;</span>&gt;取出SessionAttribute&lt;/a&gt;</span><br><span class="line">&lt;a href=<span class="string">&quot;springmvc/testClean&quot;</span>&gt;清除SessionAttribute&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SessionAttribute(value=&#123;&quot;username&quot;,&quot;password&quot;&#125;,types=&#123;Integer.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionAttributeController</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testPut&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testPut</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">&quot;username&quot;</span>,<span class="string">&quot;莱斯特&quot;</span>);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;password&quot;</span>,<span class="string">&quot;123&quot;</span>);</span><br><span class="line">    model.addAttribute(<span class="string">&quot;age&quot;</span>,<span class="number">31</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testGet&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testGet</span><span class="params">(ModelMap model)</span></span>&#123;</span><br><span class="line">    System.out.println(model.get(<span class="string">&quot;username&quot;</span>)+<span class="string">&quot;;&quot;</span>+model.get(<span class="string">&quot;password&quot;</span>)+<span class="string">&quot;;&quot;</span>+model.get(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;success&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/testClean&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">complete</span><span class="params">(SessionStatus sessionStatus)</span> </span>&#123;</span><br><span class="line">    sessionStatus.setComplete();</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;successs&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title>SpringMVC中的拦截器</title>
    <url>/2020/08/09/202089-SpringMVC%E4%B8%AD%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<p>SpringMVC框架中的拦截器用于对处理器进行预处理和后处理的技术</p>
<span id="more"></span>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol>
<li>SpringMVC 框架中的拦截器用于对处理器进行<strong>预处理和后处理</strong>的技术。</li>
<li>可以定义拦截器链，拦截器链就是将拦截器按着一定的顺序结成一条链，在访问被拦截的方法时，拦截器链中的拦截器会<strong>按着定义的顺序执行</strong>。</li>
<li>拦截器和过滤器的功能比较类似，区别在于：<ol>
<li>过滤器是 Servlet 规范的一部分，任何框架都可以使用过滤器技术。</li>
<li>拦截器是 SpringMVC 框架<strong>独有</strong>的。</li>
<li>过滤器配置了/*，可以拦截任何资源。</li>
<li>拦截器只会<strong>对控制器中的方法进行拦截</strong>。</li>
</ol>
</li>
<li>拦截器也是<strong>AOP思想</strong>的一种实现方式</li>
<li>想要自定义拦截器，需要实现 HandlerInterceptor 接口。</li>
</ol>
<h2 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h2><p>1.创建类，实现 HandlerInterceptor 接口，重写需要的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor1</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *controller方法执行前，进行拦截的方法</span></span><br><span class="line"><span class="comment">    *return true放行</span></span><br><span class="line"><span class="comment">    *return false拦截</span></span><br><span class="line"><span class="comment">    *可以使用转发或者重定向直接跳转到指定的页面。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;拦截器执行了...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.在 springmvc.xml 中配置拦截器类</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置拦截器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mVc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 哪些方法进行拦截 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/user/*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--哪些方法不进行拦截</span></span><br><span class="line"><span class="comment">        &lt;mvc:exclude-mapping path=&quot;&quot;/&gt;</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注册拦截器对象--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.itcast.demo1.MyInterceptor1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="HandlerInterceptor接口中的方法"><a href="#HandlerInterceptor接口中的方法" class="headerlink" title="HandlerInterceptor接口中的方法"></a>HandlerInterceptor接口中的方法</h2><ol>
<li>preHandle方法是<strong>controller方法执行前</strong>拦截的方法<ol>
<li>可以使用request或者response跳转到指定的页面</li>
<li>return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法。</li>
<li>return false不放行，不会执行controller中的方法。</li>
</ol>
</li>
<li>postHandle是<strong>controller方法执行后</strong>执行的方法，在JSP视图执行前。<ol>
<li>可以使用request或者response跳转到指定的页面</li>
<li>如果指定了跳转的页面，那么controller方法跳转的页面将不会显示。</li>
</ol>
</li>
<li>afterCompletion方法是在<strong>JSP执行后</strong>执行<ol>
<li>request或者response不能再跳转页面了</li>
</ol>
</li>
</ol>
<h2 id="配置多个拦截器"><a href="#配置多个拦截器" class="headerlink" title="配置多个拦截器"></a>配置多个拦截器</h2><p>1.编写多个拦截器的类</p>
<p>2.对多个拦截器进行配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置拦截器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--哪些方法进行拦截--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/user/*&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 哪些方法不进行拦截</span></span><br><span class="line"><span class="comment">        &lt;mvc:exclude-mapping path=&quot;&quot;/&gt;</span></span><br><span class="line"><span class="comment">		--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注册拦截器对象--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.itcast.demo1.MyInterceptor1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--哪些方法进行拦截--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">&quot;/**&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注册拦截器对象--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.itcast.demo1.MyInterceptor2&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
  </entry>
  <entry>
    <title>SpringData JPA(二)</title>
    <url>/2021/02/06/202126-SpringData-JPA(%E4%BA%8C)/</url>
    <content><![CDATA[<p>利用 SpringData JPA 可以简化对数据库的操作</p>
<span id="more"></span>

<h2 id="SpringData-JPA的概述"><a href="#SpringData-JPA的概述" class="headerlink" title="SpringData JPA的概述"></a>SpringData JPA的概述</h2><p>Spring Data JPA 是 Spring 基于 ORM 框架、JPA 规范的基础上封装的一套 JPA 应用框架，可使开 发者用极简的代码即可实现对数据库的访问和操作。使用了 SpringDataJpa，我们的 dao 层中只需要写接口，就自动具有了增删改查、分页查询等方法。</p>
<h2 id="SpringData-JPA的快速入门"><a href="#SpringData-JPA的快速入门" class="headerlink" title="SpringData JPA的快速入门"></a>SpringData JPA的快速入门</h2><h3 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h3><p>1.引入 SDJPA 的坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>4.2.4.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">hibernate.version</span>&gt;</span>5.0.7.Final<span class="tag">&lt;/<span class="name">hibernate.version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>1.6.6<span class="tag">&lt;/<span class="name">slf4j.version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">log4j.version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">log4j.version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">c3p0.version</span>&gt;</span>0.9.1.2<span class="tag">&lt;/<span class="name">c3p0.version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- junit单元测试 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- spring beg --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context-support<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-orm<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-beans<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- spring end --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- hibernate beg --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hibernate.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-entitymanager<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;hibernate.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.1.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- hibernate end --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- c3p0 beg --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;c3p0.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- c3p0 end --&gt;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- log end --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- log end --&gt;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- el beg 使用spring data jpa 必须引入 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.el<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.el-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish.web<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.el<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- el end --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.整合SDJPA与Spring</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:jdbc</span>=<span class="string">&quot;http://www.springframework.org/schema/jdbc&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:jpa</span>=<span class="string">&quot;http://www.springframework.org/schema/data/jpa&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:task</span>=<span class="string">&quot;http://www.springframework.org/schema/task&quot;</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot; </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/beans/spring-beans.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/aop/spring-aop.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/context/spring-context.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/jdbc </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/jdbc/spring-jdbc.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/tx </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/tx/spring-tx.xsd </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/data/jpa </span></span></span><br><span class="line"><span class="string"><span class="tag">                           http://www.springframework.org/schema/data/jpa/spring-jpa.xsd&quot;</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 1.dataSource 配置数据库连接池--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/jpa&quot;</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 2.配置entityManagerFactory --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;entityManagerFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;packagesToScan&quot;</span> <span class="attr">value</span>=<span class="string">&quot;cn.itcast.entity&quot;</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;persistenceProvider&quot;</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.hibernate.jpa.HibernatePersistenceProvider&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!--JPA的供应商适配器--&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jpaVendorAdapter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter&quot;</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;generateDdl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;database&quot;</span> <span class="attr">value</span>=<span class="string">&quot;MYSQL&quot;</span> /&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;databasePlatform&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.hibernate.dialect.MySQLDialect&quot;</span> /&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;showSql&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jpaDialect&quot;</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.jpa.vendor.HibernateJpaDialect&quot;</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 3.事务管理器--&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- JPA事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.orm.jpa.JpaTransactionManager&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;entityManagerFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;entityManagerFactory&quot;</span> /&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 整合spring data jpa--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">jpa:repositories</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.itcast.dao&quot;</span> <span class="attr">transaction-manager-ref</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">entity-manager-factory-ref</span>=<span class="string">&quot;entityManagerFactory&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jpa:repositories</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 4.txAdvice--&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;save*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;insert*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;delete*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;find*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;true&quot;</span>/&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;*&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 5.aop--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pointcut&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* cn.itcast.service.*.*(..))&quot;</span> /&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pointcut&quot;</span> /&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.itcast&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!--组装其它 配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.使用JPA注解配置映射关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.entity; </span><br><span class="line"><span class="keyword">import</span> javax.persistence.Column; </span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity; </span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue; </span><br><span class="line"><span class="keyword">import</span> javax.persistence.GenerationType; </span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id; </span><br><span class="line"><span class="keyword">import</span> javax.persistence.Table; </span><br><span class="line"><span class="comment">/**** </span></span><br><span class="line"><span class="comment">* 所有的注解都是使用JPA的规范提供的注解， * </span></span><br><span class="line"><span class="comment">* 所以在导入注解包的时候，一定要导入javax.persistence下的 */</span> </span><br><span class="line"><span class="meta">@Entity</span> </span><br><span class="line"><span class="comment">//声明实体类 </span></span><br><span class="line"><span class="meta">@Table(name=&quot;cst_customer&quot;)</span></span><br><span class="line"><span class="comment">//建立实体类和表的映射关系 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="comment">//声明当前私有属性为主键 </span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy=GenerationType.IDENTITY)</span> </span><br><span class="line">    <span class="comment">//配置主键的生成策略 </span></span><br><span class="line">    <span class="meta">@Column(name=&quot;cust_id&quot;)</span> </span><br><span class="line">    <span class="comment">//指定和表中cust_id字段的映射关系 </span></span><br><span class="line">    <span class="keyword">private</span> Long custId; </span><br><span class="line">    <span class="meta">@Column(name=&quot;cust_name&quot;)</span> </span><br><span class="line">    <span class="comment">//指定和表中cust_name字段的映射关系</span></span><br><span class="line">    <span class="keyword">private</span> String custName; </span><br><span class="line">    <span class="meta">@Column(name=&quot;cust_source&quot;)</span></span><br><span class="line">    <span class="comment">//指定和表中cust_source字段的映射关系 </span></span><br><span class="line">    <span class="keyword">private</span> String custSource; </span><br><span class="line">    <span class="meta">@Column(name=&quot;cust_industry&quot;)</span></span><br><span class="line">    <span class="comment">//指定和表中cust_industry字段的映射关系</span></span><br><span class="line">    <span class="keyword">private</span> String custIndustry;</span><br><span class="line">    <span class="meta">@Column(name=&quot;cust_level&quot;)</span></span><br><span class="line">    <span class="comment">//指定和表中cust_level字段的映射关系 </span></span><br><span class="line">    <span class="keyword">private</span> String custLevel; </span><br><span class="line">    <span class="meta">@Column(name=&quot;cust_address&quot;)</span></span><br><span class="line">    <span class="comment">//指定和表中cust_address字段的映射关系</span></span><br><span class="line">    <span class="keyword">private</span> String custAddress; </span><br><span class="line">    <span class="meta">@Column(name=&quot;cust_phone&quot;)</span></span><br><span class="line">    <span class="comment">//指定和表中cust_phone字段的映射关系</span></span><br><span class="line">    <span class="keyword">private</span> String custPhone;</span><br><span class="line">    getter/setter...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完成需求"><a href="#完成需求" class="headerlink" title="完成需求"></a>完成需求</h3><p>1.编写Dao层的接口<br>SDJPA是spring提供的一款对于数据访问层的框架，使用springdataJPA，只需要按照框架的规范提供Dao接口，不需要实现类就可以完成数据库的增删改查等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.dao; </span><br><span class="line"><span class="keyword">import</span> java.util.List; </span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaRepository; </span><br><span class="line"><span class="keyword">import</span> org.springframework.data.jpa.repository.JpaSpecificationExecutor; </span><br><span class="line"><span class="keyword">import</span> cn.itcast.entity.Customer; </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* JpaRepository&lt;实体类类型，主键类型&gt;：用来完成基本CRUD操作 </span></span><br><span class="line"><span class="comment">* JpaSpecificationExecutor&lt;实体类类型&gt;：用于复杂查询（分页等查询操作） */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Customer</span>, <span class="title">Long</span>&gt;, <span class="title">JpaSpecificationExecutor</span>&lt;<span class="title">Customer</span>&gt; </span>&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.CRUD操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span> </span><br><span class="line"><span class="meta">@ContextConfiguration(locations=&quot;classpath:applicationContext.xml&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerDaoTest</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">private</span> CustomerDao customerDao; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 保存客户：调用save(obj)方法 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Test</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSave</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        Customer c = <span class="keyword">new</span> Customer(); </span><br><span class="line">        c.setCustName(<span class="string">&quot;传智播客&quot;</span>); </span><br><span class="line">        customerDao.save(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 修改客户：调用save(obj)方法 </span></span><br><span class="line"><span class="comment">    * 对于save方法的解释：如果执行此方法是对象中存在id属性，即为更新操作会先根据id查询，再更新 </span></span><br><span class="line"><span class="comment">    * 如果执行此方法中对象中不存在id属性，即为保存操作</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="comment">//根据id查询id为1的客户 </span></span><br><span class="line">        Customer customer = customerDao.findOne(<span class="number">1l</span>); </span><br><span class="line">        <span class="comment">//修改客户名称 </span></span><br><span class="line">        customer.setCustName(<span class="string">&quot;传智播客顺义校区&quot;</span>); </span><br><span class="line">        <span class="comment">//更新 </span></span><br><span class="line">        customerDao.save(customer); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据id删除：调用delete(id)方法 */</span> </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        customerDao.delete(<span class="number">1l</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据id查询：调用findOne(id)方法 </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="meta">@Test</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindById</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        Customer customer = customerDao.findOne(<span class="number">2l</span>); </span><br><span class="line">        System.out.println(customer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="SpringData-JPA的内部原理剖析"><a href="#SpringData-JPA的内部原理剖析" class="headerlink" title="SpringData JPA的内部原理剖析"></a>SpringData JPA的内部原理剖析</h2><p>1.常用接口分析</p>
<ul>
<li>为什么不用实现Dao接口就能对数据库进行访问？<br>Dao接口继承了JpaRepository、JpaSpecificationExecutor，SDJPA对这两个接口的方法都进行了实现，所以我们可以使用这两个接口的所有方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Customer</span>, <span class="title">Long</span>&gt;, <span class="title">JpaSpecificationExecutor</span>&lt;<span class="title">Customer</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.实现过程</p>
<ul>
<li>代理子类的实现过程<br>自动注入的customerDao对象是由JdkDynamicAopProxy生成的代理对象。</li>
</ul>
<p><img src="/images/SpringDataJPA/daoProxy.png" alt="img"></p>
<ul>
<li>代理对象中方法调用的分析<br>当程序执行时，通过JdkDynamicAopProxy的invoke方法，对customerDao对象生成动态代理对象。通过动态代理对象SimpleJpaRepository，实现对数据库的访问。<br>在SimpleJpaRepository中，有各种已经编写好的方法。 </li>
</ul>
<p><img src="/images/SpringDataJPA/invoke.png" alt="img"></p>
<p><img src="/images/SpringDataJPA/method.png" alt="img"></p>
<p>Spring Data JPA 是对标准 JPA 操作进行了进一步封装，简化了 Dao 层代码的开发。</p>
<p>3.SDJPA完整的调用过程分析 </p>
<p><img src="/images/SpringDataJPA/process.png" alt="img"></p>
<h2 id="Spring-Data-JPA-的查询方式"><a href="#Spring-Data-JPA-的查询方式" class="headerlink" title="Spring Data JPA 的查询方式"></a>Spring Data JPA 的查询方式</h2><p>1.使用SDJPA中接口定义的方法进行查询</p>
<ul>
<li>继承JpaRepository </li>
</ul>
<p><img src="/images/SpringDataJPA/jpaRep.png" alt="img"></p>
<ul>
<li>继承JpaSpecificationExecutor </li>
</ul>
<p><img src="/images/SpringDataJPA/JSE.png" alt="img"></p>
<p>2.使用JPQL的方式查询 使用@Query注解，结合JPQL的语句方式完成查询 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomerDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">Customer</span>, <span class="title">Long</span>&gt;,<span class="title">JpaSpecificationExecutor</span>&lt;<span class="title">Customer</span>&gt; </span>&#123; </span><br><span class="line">    <span class="comment">//@Query 使用jpql的方式查询。 </span></span><br><span class="line">    <span class="meta">@Query(value=&quot;from Customer&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Customer&gt; <span class="title">findAllCustomer</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">//@Query 使用jpql的方式查询。?1代表参数的占位符，其中1对应方法中的参数索引 </span></span><br><span class="line">    <span class="meta">@Query(value=&quot;from Customer where custName = ?1&quot;)</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Customer <span class="title">findCustomer</span><span class="params">(String custName)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，也可以通过使用 @Query 来执行一个更新操作，为此，我们需要在使用 @Query 的同时， 用 @Modifying 来将该操作标识为修改查询，这样框架最终会生成一个更新的操作，而非查询</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(value=&quot;update Customer set custName = ?1 where custId = ?2&quot;)</span> </span><br><span class="line"><span class="meta">@Modifying</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCustomer</span><span class="params">(String custName,Long custId)</span></span>;</span><br></pre></td></tr></table></figure>

<p>3.使用SQL语句查询 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* nativeQuery : 使用本地sql的方式查询 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">@Query(value=&quot;select * from cst_customer&quot;,nativeQuery=true)</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findSql</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>4.方法命名规则查询 根据方法的名字，创建对应的查询。SDJPA在程序执行时，会解析方法名称，自动生成查询语句进行查询。</p>
<p><img src="/images/SpringDataJPA/method_rule.png" alt="img"></p>
<p><img src="/images/SpringDataJPA/method_rule2.png" alt="img"></p>
]]></content>
      <categories>
        <category>SpringData JPA</category>
      </categories>
  </entry>
  <entry>
    <title>问题集</title>
    <url>/2021/03/15/2021315-%E9%97%AE%E9%A2%98%E9%9B%86/</url>
    <content><![CDATA[<p>开发中遇到的问题</p>
<span id="more"></span>

<p><strong>问题：MongoDB查询报错：class com.mongodb.MongoSecurityException： Exception authenticating MongoCredential</strong></p>
<p>原因：MongoDB用户验证失败</p>
<p>方法：设置用户名和密码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> use admin</span></span><br><span class="line">switched to db admin</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">  db.createUser(&#123;user:<span class="string">&quot;test&quot;</span>,<span class="built_in">pwd</span>:<span class="string">&quot;123&quot;</span>,roles:[<span class="string">&quot;readWrite&quot;</span>]&#125;)</span></span><br><span class="line">Successfully added user: &#123; &quot;user&quot; : &quot;test&quot;, &quot;roles&quot; : [ &quot;readWrite&quot; ] &#125;</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.auth(<span class="string">&quot;wlf&quot;</span>,<span class="string">&quot;123&quot;</span>)</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><strong>问题：maven编译报错：java.lang.ExceptionInInitializerError: com.sun.tools.javac.code.TypeTags</strong></p>
<p>原因：Lombok版本太低，不支持Java10以上</p>
<p>方法：引入高版本Lombok</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.18<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>问题：安装cnpm无效</strong></p>
<p>原因：未配置环境变量</p>
<p>方法：在path中配置cnpm命令所在的文件路径</p>
<p><img src="/images/problem/npm_mod.png" alt="img"></p>
<p><strong>问题：nrm ls 报错internal/validators.js:124 throw new ERR_INVALID_ARG_TYPE(name, ‘string‘, value)</strong></p>
<p>原因：</p>
<p><img src="/images/problem/nrm_ls.png" alt="img"></p>
<p>方法：找到图中红框路径文件</p>
<p>将17行进行修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//const NRMRC = path.join(process.env.HOME, &#x27;.nrmrc&#x27;);(注释掉)</span></span><br><span class="line"><span class="keyword">const</span> NRMRC = path.join(process.env[(process.platform == <span class="string">&#x27;win32&#x27;</span>) ? <span class="string">&#x27;USERPROFILE&#x27;</span> : <span class="string">&#x27;HOME&#x27;</span>], <span class="string">&#x27;.nrmrc&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>问题：OpenSSL SSL_read: Connection was reset, errno 10054</strong></p>
<p>原因：服务器的SSL证书没有经过第三方机构的签署，所以报错。</p>
<p>方法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global http.sslVerify &quot;false&quot;</span><br></pre></td></tr></table></figure>

<p><strong>问题：Error: Node Sass does not yet support your current environment: Windows 64-bit</strong></p>
<p>原因：node sass 和当前项目不匹配</p>
<p>方法：<br>安装新的node-sass版本<br>在项目所在路径下执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install node-sass --save</span><br></pre></td></tr></table></figure>

<p><strong>问题：eslint Error: Failed to load plugin : Cannot find module ‘eslint-plugin-xxx’</strong></p>
<p>原因：项目未安装相关插件</p>
<p>方法：<br>在项目所在路径执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install eslint-plugin-xxx --save-dev</span><br></pre></td></tr></table></figure>

<p><strong>问题：在vue文件上方出现Typeerror:require(…).Linter is not a constructor</strong></p>
<p>原因：跟踪源码发现，缺少eslint</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCoreRule</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> map = ruleMap || (ruleMap = <span class="keyword">new</span> (<span class="built_in">require</span>(<span class="string">&#x27;eslint&#x27;</span>).Linter)().getRules())</span><br><span class="line">	<span class="keyword">return</span> map.get(name) || <span class="built_in">require</span>(<span class="string">&#x27;eslint/lib/rules/$&#123;name&#125;&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法：</p>
<p>在项目所在路径执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cnpm install eslint</span><br></pre></td></tr></table></figure>

<p><strong>问题：No ‘Access-Control-Allow-Origin’ header is present on the requested resource.</strong></p>
<p>原因：浏览器的同源策略不允许跨域访问，所谓同源策略是指协议、域名、端口相同。</p>
<p>解决：采用proxyTable解决。</p>
<p>利用代理转发，当url为cms路径时，自动使用proxyTable转发至另一个31001查询url</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> http.requestQuickGet(apiUrl+<span class="string">&#x27;/cms/page/list/&#x27;</span>+page+<span class="string">&#x27;/&#x27;</span>+size)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> apiUrl = sysConfig.xcApiUrlPre;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">xcApiUrlPre: <span class="string">&#x27;/api&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;/api/cms&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:31001&#x27;</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p><strong>问题：java.security.AccessControlException: access denied</strong></p>
<p>原因：elasticsearch和当前jdk版本不匹配导致</p>
<p>方法：重新安装版本匹配的elasticsearch</p>
<p>匹配详情参见：<a href="https://www.elastic.co/cn/support/matrix#matrix_jvm">https://www.elastic.co/cn/support/matrix#matrix_jvm</a></p>
<p><strong>问题：org.springframework.beans.factory.BeanCreationException: Error creating bean with name ‘entityManagerFactory’ defined in class path resource [org/springframework/boot/autoconfigure/orm/jpa/HibernateJpaConfiguration.class]: Invocation of init method failed; nested exception is javax.persistence.PersistenceException: [PersistenceUnit: default] Unable to build Hibernate SessionFactory; nested exception is org.hibernate.MappingException: Could not get constructor for org.hibernate.persister.entity.SingleTableEntityPersister</strong></p>
<p>原因：</p>
<p>方法：导入如下依赖到pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.javassist<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javassist<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.23.1-GA<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>问题：Spring security启动报错 Error creating bean with name ‘springSecurityFilterChain’ defined in class path</strong></p>
<p>原因：jdk版本不兼容，导致一些注释无法编译解析</p>
<p>方法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/javax.activation/activation --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.activation<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>activation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.glassfish.jaxb/jaxb-runtime --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.glassfish.jaxb<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-runtime<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0-b170127.1453<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>问题整理</category>
      </categories>
  </entry>
  <entry>
    <title>前端跨域实现数据库查询</title>
    <url>/2021/03/14/2021314-%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>Vue使用axios跨域请求服务端并基于Spring data mongoDB实现对数据库的查询</p>
<span id="more"></span>

<h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><p>1.定义Api接口文档，为后续使用Swagger调试做说明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Api(value=&quot;cms页面管理接口&quot;,description = &quot;cms页面管理接口，提供页面的模板查询&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CmsTemplateControllerApi</span> </span>&#123;</span><br><span class="line">    <span class="comment">//站点查询</span></span><br><span class="line">    <span class="meta">@ApiOperation(&quot;查询模板列表&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> QueryResponseResult <span class="title">findList</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.编写Dao层<br>因为使用了Spring data mongoDB来对数据库进行操作，所以继承MongoRepository&lt;CmsTemplate,String&gt;。<br>两个泛型的含义：<br>CmsTemplate：数据库表名<br>String：主键类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用spring data mongoDB对数据库进行操作</span></span><br><span class="line"><span class="comment"> * CmsTemplate(数据库表名）Repository 固定写法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CmsTemplateRepository</span> <span class="keyword">extends</span> <span class="title">MongoRepository</span>&lt;<span class="title">CmsTemplate</span>,<span class="title">String</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>同时本次使用的是findAll方法来查询所有的模板数据，而父类中已拥有findAll方法，所以不再编写。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NoRepositoryBean</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MongoRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt; <span class="keyword">extends</span> <span class="title">PagingAndSortingRepository</span>&lt;<span class="title">T</span>, <span class="title">ID</span>&gt;, <span class="title">QueryByExampleExecutor</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    &lt;S extends T&gt; <span class="function">List&lt;S&gt; <span class="title">saveAll</span><span class="params">(Iterable&lt;S&gt; var1)</span></span>;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">List&lt;T&gt; <span class="title">findAll</span><span class="params">(Sort var1)</span></span>;</span><br><span class="line">    &lt;S extends T&gt; <span class="function">S <span class="title">insert</span><span class="params">(S var1)</span></span>;</span><br><span class="line">    &lt;S extends T&gt; <span class="function">List&lt;S&gt; <span class="title">insert</span><span class="params">(Iterable&lt;S&gt; var1)</span></span>;</span><br><span class="line">    &lt;S extends T&gt; <span class="function">List&lt;S&gt; <span class="title">findAll</span><span class="params">(Example&lt;S&gt; var1)</span></span>;</span><br><span class="line">    &lt;S extends T&gt; <span class="function">List&lt;S&gt; <span class="title">findAll</span><span class="params">(Example&lt;S&gt; var1, Sort var2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.编写service层</p>
<p>调用Dao层的findAll方法，并返回数据列表List。然后，将List存入queryResult保持返回对象一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryResult</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//数据列表</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; list;</span><br><span class="line">    <span class="comment">//数据总数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建QueryResponseResult对象，返回成功消息以及queryResult结果集。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplateService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    CmsTemplateRepository cmsTemplateRepository;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 页面查询方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> QueryResponseResult <span class="title">findList</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;CmsTemplate&gt; all = cmsTemplateRepository.findAll();</span><br><span class="line">        QueryResult queryResult = <span class="keyword">new</span> QueryResult();</span><br><span class="line">        queryResult.setList(all);<span class="comment">//数据列表</span></span><br><span class="line">        queryResult.setTotal(all.size());<span class="comment">//数据总记录数</span></span><br><span class="line">        QueryResponseResult queryResponseResult = <span class="keyword">new</span> QueryResponseResult(CommonCode.SUCCESS,queryResult);</span><br><span class="line">        <span class="keyword">return</span> queryResponseResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.编写controller层</p>
<p>使用get方式提交请求，所以用GetMapping来设置访问url(/cms/template/list)。随后调用service层来实现调用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/cms/template&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CmsTemplateController</span> <span class="keyword">implements</span> <span class="title">CmsTemplateControllerApi</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TemplateService templateService;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/list&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> QueryResponseResult <span class="title">findList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//调用service</span></span><br><span class="line">        <span class="keyword">return</span> templateService.findList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.通过swaggerUI进行测试</p>
<p><img src="/images/SpringBoot/swagger.png" alt="image-20210314102546678"></p>
<p><img src="/images/SpringBoot/swaggerRes.png" alt="image-20210314102604469"></p>
<p>成功查询到数据，并以json格式返回。</p>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><p>1.在cms.js中配置前端请求服务端的查询方法</p>
<p>通过get请求对应的url</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//模板查询</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> template_list = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">//请求服务端的页面查询接口</span></span><br><span class="line">  <span class="keyword">return</span> http.requestQuickGet(apiUrl + <span class="string">&#x27;/cms/template/list&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.在config/index.js中配置axios跨域代理</p>
<p>让url中包含/api/cms的访问，自动转发至31001端口的服务端url，实现对服务端的接口访问。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;/api/cms&#x27;</span>: &#123;</span><br><span class="line">        <span class="attr">target</span>: <span class="string">&#x27;http://localhost:31001&#x27;</span>,</span><br><span class="line">        <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>3.在前端vue中的methods，配置query调用服务端接口</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">cmsApi.template_list().then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.templateList = res.queryResult.list;</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure>

<p>将返回结果赋值给templateList</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-select v-model=&quot;pageForm.templateId&quot; placeholder=&quot;请选择&quot;&gt;</span><br><span class="line">     &lt;el-option</span><br><span class="line">           v-for=&quot;item in templateList&quot;</span><br><span class="line">           :key=&quot;item.templateId&quot;</span><br><span class="line">           :label=&quot;item.templateName&quot;</span><br><span class="line">           :value=&quot;item.templateId&quot;&gt;</span><br><span class="line">     &lt;/el-option&gt;</span><br><span class="line">&lt;/el-select&gt;</span><br></pre></td></tr></table></figure>

<p>4.登录前端测试</p>
<p><img src="/images/SpringBoot/res.png" alt="image-20210314103829462"></p>
]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title>学成在线--项目总结</title>
    <url>/2021/04/15/2021415-%E5%AD%A6%E6%88%90%E5%9C%A8%E7%BA%BF--%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>一个简单的基于 SpringBoot 的练手项目</p>
<span id="more"></span>

<p><a href="https://github.com/deepbreath373/xcEduService.git">Github源码</a></p>
<h2 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h2><p>学成在线是一个在线教育平台，包括前台课程学习系统、后台课程管理系统以及CMS（内容管理系统）。该项目为前后端分离开发，前端基于vue.js技术，服务端基于SpringBoot、SpringCloud等Spring全家桶技术。</p>
<p>前台课程学习系统：首页门户、课程搜索、课程详情、在线学习、用户登录</p>
<p>后台课程管理系统：课程管理、文件上传</p>
<p>CMS：页面管理</p>
<h2 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xc</span><br><span class="line">├── xc-framework-common -- 通用代码</span><br><span class="line">├── xc-framework-model -- 各服务所需的模型类</span><br><span class="line">├── xc-framework-parent -- 父工程(负责依赖导入)</span><br><span class="line">├── xc-framework-utils -- 工具类</span><br><span class="line">├── xc-govern-center -- EurekaServer</span><br><span class="line">├── xc-govern-gateway -- zuul网关</span><br><span class="line">├── xc-service-api -- api接口定义</span><br><span class="line">├── xc-service-base-filesystem -- 文件系统</span><br><span class="line">├── xc-service-learning -- 在线播放视频</span><br><span class="line">├── xc-service-manage-cms -- cms页面管理(增删改查)</span><br><span class="line">├── xc-service-manage-cms-client -- cms页面发布</span><br><span class="line">├── xc-service-manage-course -- 课程管理</span><br><span class="line">├── xc-service-manage-media -- 媒资文件管理</span><br><span class="line">├── xc-service-manage-media-processor -- 媒资文件格式处理工程</span><br><span class="line">├── xc-service-manage-order -- 订单管理</span><br><span class="line">├── xc-service-search -- 基于elasticsearch的课程搜索</span><br><span class="line">├── xc-service-ucenter -- 用户中心</span><br><span class="line">└── xc-service-ucenter-auth -- 用户的登录认证</span><br></pre></td></tr></table></figure>

<h2 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h2><h3 id="后端技术"><a href="#后端技术" class="headerlink" title="后端技术"></a>后端技术</h3><table>
<thead>
<tr>
<th>技术</th>
<th>说明</th>
<th>官网</th>
</tr>
</thead>
<tbody><tr>
<td>SpringBoot</td>
<td>容器+MVC框架</td>
<td><a href="https://spring.io/projects/spring-boot">https://spring.io/projects/spring-boot</a></td>
</tr>
<tr>
<td>SpringCloud</td>
<td>微服务</td>
<td><a href="https://spring.io/projects/spring-cloud">https://spring.io/projects/spring-cloud</a></td>
</tr>
<tr>
<td>SpringSecurity Oauth2</td>
<td>认证和授权框架</td>
<td><a href="https://spring.io/projects/spring-security-oauth">https://spring.io/projects/spring-security-oauth</a></td>
</tr>
<tr>
<td>SpringTask</td>
<td>任务处理</td>
<td></td>
</tr>
<tr>
<td>Swagger-UI</td>
<td>服务端测试工具</td>
<td><a href="https://github.com/swagger-api/swagger-ui">https://github.com/swagger-api/swagger-ui</a></td>
</tr>
<tr>
<td>MyBatis</td>
<td>ORM框架(MySQL)</td>
<td><a href="http://www.mybatis.org/mybatis-3/zh/index.html">http://www.mybatis.org/mybatis-3/zh/index.html</a></td>
</tr>
<tr>
<td>PageHelper</td>
<td>MyBatis物理分页插件</td>
<td><a href="http://git.oschina.net/free/Mybatis_PageHelper">http://git.oschina.net/free/Mybatis_PageHelper</a></td>
</tr>
<tr>
<td>ElasticSearch</td>
<td>搜索引擎</td>
<td><a href="https://github.com/elastic/elasticsearch">https://github.com/elastic/elasticsearch</a></td>
</tr>
<tr>
<td>RabbitMq</td>
<td>消息队列</td>
<td><a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a></td>
</tr>
<tr>
<td>Redis</td>
<td>分布式缓存</td>
<td><a href="https://redis.io/">https://redis.io/</a></td>
</tr>
<tr>
<td>MongoDb</td>
<td>NoSql数据库</td>
<td><a href="https://www.mongodb.com/">https://www.mongodb.com/</a></td>
</tr>
<tr>
<td>MySQL</td>
<td>关系型数据库</td>
<td><a href="https://www.mysql.com/cn/">https://www.mysql.com/cn/</a></td>
</tr>
<tr>
<td>JWT</td>
<td>JWT登录支持</td>
<td><a href="https://github.com/jwtk/jjwt">https://github.com/jwtk/jjwt</a></td>
</tr>
<tr>
<td>LogStash</td>
<td>数据采集</td>
<td><a href="https://github.com/logstash/logstash-logback-encoder">https://github.com/logstash/logstash-logback-encoder</a></td>
</tr>
<tr>
<td>Lombok</td>
<td>简化对象封装工具</td>
<td><a href="https://github.com/rzwitserloot/lombok">https://github.com/rzwitserloot/lombok</a></td>
</tr>
</tbody></table>
<h3 id="前端技术"><a href="#前端技术" class="headerlink" title="前端技术"></a>前端技术</h3><table>
<thead>
<tr>
<th>技术</th>
<th>说明</th>
<th>官网</th>
</tr>
</thead>
<tbody><tr>
<td>Vue</td>
<td>前端框架</td>
<td><a href="https://vuejs.org/">https://vuejs.org/</a></td>
</tr>
<tr>
<td>Element-UI</td>
<td>前端UI框架</td>
<td><a href="https://element.eleme.io/">https://element.eleme.io</a></td>
</tr>
</tbody></table>
<h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><table>
<thead>
<tr>
<th>工具</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>IDEA</td>
<td>java开发IDE</td>
</tr>
<tr>
<td>WebStorm</td>
<td>前端开发IDE</td>
</tr>
<tr>
<td>RedisDesktop</td>
<td>redis客户端连接工具</td>
</tr>
<tr>
<td>SQLyog</td>
<td>MySQL连接工具</td>
</tr>
<tr>
<td>Studio-3T</td>
<td>MongoDB连接工具</td>
</tr>
<tr>
<td>Postman</td>
<td>API接口调试工具</td>
</tr>
<tr>
<td>Typora</td>
<td>Markdown编辑器</td>
</tr>
</tbody></table>
<h2 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h2><p><img src="/images/Java/construct.png" alt="img"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>案例</category>
      </categories>
  </entry>
  <entry>
    <title>Java中的引用类型</title>
    <url>/2021/04/15/2021415-Java%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>四种引用类型：强引用、软引用、弱引用、虚引用</p>
<span id="more"></span>

<p><strong>四种引用类型</strong></p>
<p>JDK1.2 之前，一个对象只有“已被引用”和”未被引用”两种状态，这将无法描述某些特殊情况下的对象，比如，当内存充足时需要保留，而内存紧张时才需要被抛弃的一类对象。 </p>
<p>JDK.1.2 之后，Java 对引用的概念进行了扩充，将引用分为了：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4 种，这 4 种引用的强度依次减弱。</p>
<p><strong>一，强引用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object obj = new Object(); //只要obj还指向Object对象，Object对象就不会被回收 </span><br><span class="line">obj = null; //手动置null</span><br></pre></td></tr></table></figure>

<p><strong>只要强引用存在，垃圾回收器将永远不会回收被引用的对象</strong>，哪怕内存不足时，JVM 也会直接抛出 OutOfMemoryError，不会去回收。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为 null，这样一来，JVM 就可以适时的回收对象了</p>
<p><strong>二，软引用</strong></p>
<p>软引用是用来描述一些非必需但仍有用的对象。<strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong>。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。在 JDK1.2 之后，用 java.lang.ref.SoftReference 类来表示软引用。</p>
<p><strong>三，弱引用</strong></p>
<p>弱引用的引用强度比软引用要更弱一些，<strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</strong>。在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用。</p>
<p><strong>四，虚引用</strong></p>
<p>虚引用是最弱的一种引用关系，<strong>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，</strong>在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>多态——“编译看左边，运行看右边”</title>
    <url>/2021/04/16/2021416-%E5%A4%9A%E6%80%81%E2%80%94%E2%80%94%E2%80%9C%E7%BC%96%E8%AF%91%E7%9C%8B%E5%B7%A6%E8%BE%B9%EF%BC%8C%E8%BF%90%E8%A1%8C%E7%9C%8B%E5%8F%B3%E8%BE%B9%E2%80%9D/</url>
    <content><![CDATA[<p>Fu f = new Zi() 的情况下创建的对象是怎样的</p>
<span id="more"></span>

<p>首先看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fu method_4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fu method_3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num =<span class="number">8</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;zi method_4&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;zi method_3&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DuoTaiDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Fu f = <span class="keyword">new</span> Zi();</span><br><span class="line">        System.out.println(f.num);<span class="comment">//与父类一致</span></span><br><span class="line">        f.method4();<span class="comment">//与父类一致</span></span><br><span class="line">        f.method3();<span class="comment">//编译时与父类一致，运行时与子类一致</span></span><br><span class="line">        Zi z = <span class="keyword">new</span> Zi();</span><br><span class="line">        System.out.println(z.num);</span><br><span class="line">        z.method4();</span><br><span class="line">        z.method3();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行该程序，结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">fu method_4</span><br><span class="line">zi method_3</span><br><span class="line">8</span><br><span class="line">zi method_4</span><br><span class="line">zi method_3</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Fu f = <span class="keyword">new</span> Zi();</span><br></pre></td></tr></table></figure>

<p>首先，Fu f 声明了一个变量名为 f 的 Fu 类，所以可以得出 f 就是一个 Fu 类。接着，new Zi(); 则是新建了一个 Zi 类对象，并且赋值给了 f 。最后可以得出，f 是一个被 Zi 类方法重写后的 Fu 类对象。</p>
<p>在当前这个 Fu 类中，只有 Zi 类的方法重写改变了原本父类的方法，而父类中的成员变量 num 、静态方法 method4 均不改变。所以 <strong>f 所代表的仅仅是一个只有方法被重写之后的 Fu 类，原本的成员变量、静态方法都是父类的。</strong></p>
<p>那么，为什么成员变量和静态方法不会改变？</p>
<p>重写针对的是方法，所以 f 作为一个 Fu 类，所拥有的成员变量仍旧是 Fu 类的成员变量。</p>
<p>而静态方法则是在 Fu 类加载时被加载，当创建 Zi 类对象时，父类的静态方法已经存在，不能被之后出现的 Zi 类对象所重写。因此，静态方法还是 Fu 类的静态方法。</p>
<p>结论：</p>
<ul>
<li>成员变量：编译和运行都看父类</li>
<li>非静态方法：编译看父类，运行看子类</li>
<li>静态方法：编译和运行都看父类</li>
</ul>
<p>练习：</p>
<p>假定 Base b = new Derived(); 调用执行 b.methodOne() 后，输出结果是什么？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span> <span class="comment">//(2)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      System.out.print(<span class="string">&quot;A&quot;</span>); <span class="comment">//(3)</span></span><br><span class="line">      methodTwo(); <span class="comment">//(4)没写super则是调用当前对象，即子类的方法</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodTwo</span><span class="params">()</span> <span class="comment">//(5)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      System.out.print(<span class="string">&quot;B&quot;</span>); <span class="comment">//(6)</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOne</span><span class="params">()</span> <span class="comment">//(1)首先调用的是重写后的子类方法</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.methodOne(); <span class="comment">//(2)由super调用的父类方法</span></span><br><span class="line">      System.out.print(<span class="string">&quot;C&quot;</span>);<span class="comment">//(8)</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodTwo</span><span class="params">()</span> <span class="comment">//(4)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>.methodTwo(); <span class="comment">//(5)由super调用的父类方法</span></span><br><span class="line">      System.out.print(<span class="string">&quot;D&quot;</span>); <span class="comment">//(7)</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：</p>
<p>1.多态中成员方法使用规则 编译看左边，运行看右边。<br>2.多态中，子类重写的方法，当super调用就是调用父类方法。如果没有写，因为当前对象是子类，所以默认调用子类的方法。</p>
<p>结果：<br>ABDC</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>知识整理</category>
      </categories>
  </entry>
  <entry>
    <title>消息队列的作用</title>
    <url>/2021/04/16/2021416-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
    <content><![CDATA[<p>解耦、异步、削峰</p>
<span id="more"></span>

<h2 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h2><p>将消息写入消息队列，需要消息的模块通过订阅消息队列，自动从队列获取相关数据。</p>
<p>这样，模块之间<strong>不存在直接调用</strong>，那么当新增模块或者修改模块时对其他模块的影响较小，同时增强了系统的<strong>可扩展性</strong>。</p>
<p><img src="/images/msgQueue/msg_queue.png" alt="img"></p>
<p>生产者发送消息到消息队列中去，消费者去消息队列中取出对应的消息进行消费。这样，生产者和消费者之间不存在直接调用，减少了系统之间的耦合性，提高系统的扩展性。</p>
<h2 id="异步-amp-削峰"><a href="#异步-amp-削峰" class="headerlink" title="异步&amp;削峰"></a>异步&amp;削峰</h2><p>将消息写入消息队列后，非必要的业务逻辑以异步的方式运行，<strong>加快了系统的响应速度</strong>，<strong>增强用户的体验性</strong>。</p>
<p>消费者按照数据库能处理的并发量，从消息队列中分次拉取消息，<strong>减轻数据库压力</strong>。</p>
<p>当我们不使用消息队列的时候，所有的用户请求会直接调用服务器，然后通过数据库或者缓存来做出响应。假如遇到了高并发的情况，大量的请求落在数据库或者缓存上，如果数据库或者缓存无法承受这么大的压力，那么会造成响应速度缓慢，甚至造成数据库宕机。但是，在使用消息队列之后，用户在请求数据发送给消息队列之后就能立即返回，不用等待服务端完成工作。再由消息队列的消费者进程从中获取数据，异步写入数据库。由于消息队列服务器处理速度快于数据库，所以会大幅提升响应速度。</p>
<p><img src="/images/msgQueue/msg_process.png" alt="img"></p>
<p>而削峰作用即是借助于消息队列的异步处理，将短时间内高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务。例如，在电商系统中的秒杀、促销活动中，在一定的时间中，会产生大量的用户请求，那么，合理使用消息队列就可以有效降低数据的压力，减少系统崩溃的概率。</p>
<p><img src="/images/msgQueue/msg_slash.png" alt="img"></p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>系统<strong>可用性降低</strong><br>在使用消息队列后，需要考虑MQ中间件可能会出现宕机的情况，或者消息在传输过程中的丢失问题。</li>
<li>系统<strong>复杂性增加</strong><br>消息是否被重复消费、处理消息的丢失、保证消息传递的顺序性</li>
<li><strong>一致性</strong>问题<br>异步情况下，真正的消费者没有正确消费信息导致的数据不一致</li>
</ul>
]]></content>
      <categories>
        <category>消息队列</category>
      </categories>
  </entry>
  <entry>
    <title>Java中的双重检查锁</title>
    <url>/2021/04/18/2021418-Java%E4%B8%AD%E7%9A%84%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81/</url>
    <content><![CDATA[<p>在<a href="https://deepbreath373.github.io/2021/06/04/202164-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F">单例模式</a>中为了创建出唯一实例就用到了双重检查锁</p>
<span id="more"></span>

<p><a href="https://www.cnblogs.com/xz816111/p/8470048.html">本文摘自</a></p>
<h1 id="错误情况"><a href="#错误情况" class="headerlink" title="错误情况"></a>错误情况</h1><p>在实现单例模式时，如果未考虑多线程的情况，就容易写出下面的错误代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueSingleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            uniqueSingleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在多线程的情况下，这样写可能会导致<code>uniqueSingleton</code>有多个实例。比如下面这种情况，考虑有两个线程同时调用<code>getInstance()</code>：</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>Thread A</th>
<th>Thread B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>检查到<code>uniqueSingleton</code>为空</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>检查到<code>uniqueSingleton</code>为空</td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>初始化对象<code>A</code></td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>返回对象<code>A</code></td>
</tr>
<tr>
<td>T5</td>
<td>初始化对象<code>B</code></td>
<td></td>
</tr>
<tr>
<td>T6</td>
<td>返回对象<code>B</code></td>
<td></td>
</tr>
</tbody></table>
<p>可以看到，<code>uniqueSingleton</code>被实例化了两次并且被不同对象持有。完全违背了单例的初衷。</p>
<h1 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h1><p>出现这种情况，第一反应就是加锁，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueSingleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            uniqueSingleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样虽然解决了问题，但是因为用到了<code>synchronized</code>，会导致很大的性能开销，并且加锁其实只需要在第一次初始化的时候用到，之后的调用都没必要再进行加锁。</p>
<h1 id="双重检查锁"><a href="#双重检查锁" class="headerlink" title="双重检查锁"></a>双重检查锁</h1><p>双重检查锁（double checked locking）是对上述问题的一种优化。先判断对象是否已经被初始化，再决定要不要加锁。</p>
<h2 id="错误的双重检查锁"><a href="#错误的双重检查锁" class="headerlink" title="错误的双重检查锁"></a>错误的双重检查锁</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueSingleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == uniqueSingleton) &#123;</span><br><span class="line">                    uniqueSingleton = <span class="keyword">new</span> Singleton();   <span class="comment">// error</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果这样写，运行顺序就成了：</p>
<ol>
<li>检查变量是否被初始化(不去获得锁)，如果已被初始化则立即返回。</li>
<li>获取锁。</li>
<li>再次检查变量是否已经被初始化，如果还没被初始化就初始化一个对象。</li>
</ol>
<p>执行双重检查是因为，如果多个线程同时了通过了第一次检查，并且其中一个线程首先通过了第二次检查并实例化了对象，那么剩余通过了第一次检查的线程就不会再去实例化对象。</p>
<p>这样，除了初始化的时候会出现加锁的情况，后续的所有调用都会避免加锁而直接返回，解决了性能消耗的问题。</p>
<h3 id="隐患"><a href="#隐患" class="headerlink" title="隐患"></a>隐患</h3><p>上述写法看似解决了问题，但是有个很大的隐患。实例化对象的那行代码（标记为error的那行），实际上可以分解成以下三个步骤：</p>
<ol>
<li>分配内存空间</li>
<li>初始化对象</li>
<li>将对象指向刚分配的内存空间</li>
</ol>
<p>但是有些编译器为了性能的原因，可能会将第二步和第三步进行<strong>重排序</strong>，顺序就成了：</p>
<ol>
<li>分配内存空间</li>
<li>将对象指向刚分配的内存空间</li>
<li>初始化对象</li>
</ol>
<p>现在考虑重排序后，两个线程发生了以下调用：</p>
<table>
<thead>
<tr>
<th>Time</th>
<th>Thread A</th>
<th>Thread B</th>
</tr>
</thead>
<tbody><tr>
<td>T1</td>
<td>检查到<code>uniqueSingleton</code>为空</td>
<td></td>
</tr>
<tr>
<td>T2</td>
<td>获取锁</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td>再次检查到<code>uniqueSingleton</code>为空</td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td>为<code>uniqueSingleton</code>分配内存空间</td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td>将<code>uniqueSingleton</code>指向内存空间</td>
<td></td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>检查到<code>uniqueSingleton</code>不为空</td>
</tr>
<tr>
<td>T7</td>
<td></td>
<td>访问<code>uniqueSingleton</code>（此时对象还未完成初始化）</td>
</tr>
<tr>
<td>T8</td>
<td>初始化<code>uniqueSingleton</code></td>
<td></td>
</tr>
</tbody></table>
<p>在这种情况下，T7时刻线程B对<code>uniqueSingleton</code>的访问，访问的是一个<strong>初始化未完成</strong>的对象。</p>
<h2 id="正确的双重检查锁"><a href="#正确的双重检查锁" class="headerlink" title="正确的双重检查锁"></a>正确的双重检查锁</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueSingleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == uniqueSingleton) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == uniqueSingleton) &#123;</span><br><span class="line">                    uniqueSingleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueSingleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了解决上述问题，需要在<code>uniqueSingleton</code>前加入关键字<code>volatile</code>。使用了volatile关键字后，重排序被禁止，所有的写（write）操作都将发生在读（read）操作之前。</p>
<p>至此，双重检查锁就可以完美工作了。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>线程</category>
      </categories>
  </entry>
  <entry>
    <title>HashMap/Hashtable/ConcurrentHashMap</title>
    <url>/2021/04/18/2021418-HashMapHashtableConcurrentHashMap/</url>
    <content><![CDATA[<p>关于HashMap/Hashtable/ConcurrentHashMap的区别</p>
<span id="more"></span>

<h2 id="线程安全性："><a href="#线程安全性：" class="headerlink" title="线程安全性："></a>线程安全性：</h2><p>HashMap 是非线程安全的，在高并发状态下可能会因为 rehash 进入死循环。</p>
<p>HashTable 是线程安全的，它使用 synchronized 修饰了大部分的方法。</p>
<p>ConcurrentHashMap 是线程安全的，在 JDK1.7 中，它将数据分割分段（Segment），每一把锁只负责容器中的一部分数据，当一段数据被访问时，访问其他段数据的线程也不会堵塞。这样就提高了并发效率，同时实现了线程安全。到了 JDK1.8 ，直接使用 Node 数组+链表/红黑树的数据结构实现，并发控制使用 synchronized 和 CAS 来操作。</p>
<h2 id="对null的支持"><a href="#对null的支持" class="headerlink" title="对null的支持"></a>对null的支持</h2><table>
<thead>
<tr>
<th>Map集合类</th>
<th>key</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>HashMap</td>
<td>null</td>
<td>null</td>
</tr>
<tr>
<td>HashTable</td>
<td>not null</td>
<td>not null</td>
</tr>
<tr>
<td>ConcurrentMap</td>
<td>not null</td>
<td>not null</td>
</tr>
</tbody></table>
<h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>JDK1.8 之前 <code>HashMap</code> 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。</p>
<p>JDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p>
<p><img src="/images/Java/HashMap.png" alt="img"></p>
<h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>将所有的数据加锁</p>
<p><img src="/images/Java/HashTable.png" alt="img"></p>
<h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>JDK1.7：将数据分割分段为一个个 Segment ，并为每个 Segment 加锁</p>
<p><img src="/images/Java/ConcurrentHashMap7.png" alt="img"></p>
<p>JDK1.8：Node数组/TreeNode+链表/红黑树，链表用Node数组，红黑树用TreeNode</p>
<p><img src="/images/Java/ConcurrentHashMap8.png" alt="img"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>知识整理</category>
      </categories>
  </entry>
  <entry>
    <title>Access-Control-Allow-Origin跨域问题</title>
    <url>/2021/04/02/202142-Access-Control-Allow-Origin%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>浏览器进行跨域调用时拒绝接收返回的资源</p>
<span id="more"></span>

<h2 id="浏览器的同源安全策略"><a href="#浏览器的同源安全策略" class="headerlink" title="浏览器的同源安全策略"></a>浏览器的同源安全策略</h2><p><strong>同源：</strong>协议 + 域名 + 端口（均相同）</p>
<p><strong>同源策略：</strong>它是由 Netscape 提出的一个著名的安全策略。现在所有支持 JavaScript 的浏览器都会使用这个策略。同源策略是浏览器的行为，是为了保护本地数据不被 JavaScript 代码获取回来的数据污染，因此它将会拦截客户端发出 request 后响应回来的 response 。即使请求发送了，服务器也成功响应，但是却被浏览器拒绝接收。</p>
<p>所以，怎么才算跨域呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">请求协议 —— http,https 的不同</span><br><span class="line">域 —— domain 的不同</span><br><span class="line">端口 —— port 的不同</span><br></pre></td></tr></table></figure>

<p>既然是浏览器的策略，则说明资源请求是可以正常返回的，只是浏览器拒绝接收这个资源。</p>
<h2 id="浏览器报错"><a href="#浏览器报错" class="headerlink" title="浏览器报错"></a>浏览器报错</h2><p>当出现跨域调用时，浏览器便会发出如下信息：</p>
<p><img src="/images/JavaWeb/access_error.png" alt="img"></p>
<p>在信息末尾提到 “No ‘Access-Control-Allow-Origin’ header is present on the requested resource.”</p>
<p>所以，我们要在 Nginx 中为该请求设置一个 header，让他被 Nginx 进行代理转发，实现跨域访问。</p>
<h2 id="基于Nginx配置请求的CORS"><a href="#基于Nginx配置请求的CORS" class="headerlink" title="基于Nginx配置请求的CORS"></a>基于Nginx配置请求的CORS</h2><p><strong>CORS：</strong>全称是“跨域资源共享” (Cross-Origin Resource Sharing)<br>它具有以下三个参数：<br><strong>Access-Control-Allow-Origin：</strong>允许跨域访问的外域地址<br>允许的站点如果是多个，可以设置一个map来存放，或者，使用 * 来代表允许所有域名进行跨域访问。<br><strong>Access-Control-Allow-Credentials：</strong>允许客户端携带证书访问<br><strong>Access-Control-Allow-Methods：</strong>允许客户端跨域访问的方法(GET/POST/DELETE…)</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">map</span> $http_origin $origin_list&#123; </span><br><span class="line">	<span class="attribute">default</span> http://www.xxx.com;</span><br><span class="line">	&quot;~http://www.xxx.com&quot; http://www.xxx.com; </span><br><span class="line">	&quot;~http://xxx.xxx.com&quot; http://xxx.xxx.com; </span><br><span class="line">&#125;</span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">  <span class="attribute">location</span> /xxx &#123;</span><br><span class="line">    <span class="comment">#add_header Access-Control-Allow-Origin *;</span></span><br><span class="line">    <span class="attribute">add_header</span> Access-Control-Allow-Origin $origin_list;</span><br><span class="line">    <span class="attribute">add_header</span> Access-Control-Allow-Credentials <span class="literal">true</span>;</span><br><span class="line">    <span class="attribute">add_header</span> Access-Control-Allow-Methods GET;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaWeb</category>
      </categories>
  </entry>
  <entry>
    <title>JVM内存区域解读</title>
    <url>/2021/04/20/2021420-JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E8%A7%A3%E8%AF%BB/</url>
    <content><![CDATA[<p>JVM 内存区域：堆、方法区、PCR、虚拟机栈、本地方法栈</p>
<span id="more"></span>

<h2 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h2><p>JDK1.8之前：</p>
<p><img src="/images/Java/JVM1_6.png" alt="img"></p>
<p>JDK1.8：</p>
<p><img src="/images/Java/JVM1_8.png" alt="img"></p>
<h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器主要有两个作⽤：</p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从⽽实现代码的流程控制，如：顺序执 ⾏、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器⽤于记录当前线程执⾏的位置，从⽽当线程被切换回来的时 候能够知道该线程上次运⾏到哪⼉了。</li>
</ol>
<p>注意：程序计数器是唯⼀⼀个不会出现 OutOfMemoryError 的内存区域，它的⽣命周期随着线程的创建⽽创建，随着线程的结束⽽死亡。</p>
<h2 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h2><p>与程序计数器⼀样，Java 虚拟机栈也是线程私有的，它的⽣命周期和线程相同，描述的是 Java ⽅法执⾏的内存模型，每次⽅法调⽤的数据都是通过栈传递的。</p>
<p><strong>Java</strong> 虚拟机栈会出现两种错误： <strong>StackOverFlowError</strong> 和 <strong>OutOfMemoryError</strong> 。</p>
<p><strong>StackOverFlowError</strong> ： 若 Java 虚拟机栈的内存⼤⼩不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最⼤深度的时候，就抛出StackOverFlowError 错误。</p>
<p><strong>OutOfMemoryError</strong> ： 若 Java 虚拟机堆中没有空闲内存，并且垃圾回收器也⽆法提供更多内存的话。就会抛出 OutOfMemoryError 错误。</p>
<p>Java 虚拟机栈也是线程私有的，每个线程都有各⾃的 Java 虚拟机栈，⽽且随着线程的创建⽽创建，随着线程的死亡⽽死亡。</p>
<h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>和虚拟机栈所发挥的作⽤⾮常相似，区别是： 虚拟机栈为虚拟机执⾏ Java ⽅法 （也就是字节码）服务，⽽本地⽅法栈则为虚拟机使⽤到的 Native ⽅法服务。</p>
<p>本地⽅法被执⾏的时候，在本地⽅法栈也会创建⼀个栈帧，⽤于存放该本地⽅法的局部变量表、 操作数栈、动态链接、出⼝信息。</p>
<p>⽅法执⾏完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种错误。</p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>Java 虚拟机所管理的内存中最⼤的⼀块，Java 堆是所有线程共享的⼀块内存区域，在虚拟机启动时创建。此内存区域的唯⼀⽬的就是<strong>存放对象实例</strong>，⼏乎所有的对象实例以及数组都在这⾥分 配内存。</p>
<h2 id="方法区和元空间"><a href="#方法区和元空间" class="headerlink" title="方法区和元空间"></a>方法区和元空间</h2><p>⽅法区与 Java 堆⼀样，是各个线程共享的内存区域，它⽤于存储已被虚拟机加载的<strong>类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。</p>
<p>那么，方法区和元空间的关系是什么？</p>
<p>1.方法区是 JVM 规范的一个概念定义，并不是一个具体的实现，每一个 JVM 的实现都可以有各自的实现。</p>
<p>2.在 Java 官方的 HotSpot 虚拟机中，Java8 版本以后，是用元空间来实现的方法区；在 Java8 之前的版本，则是用永久代实现的方法区。</p>
<p>3.“元空间” 和 “方法区”，一个是 HotSpot 的具体实现技术，一个是 JVM 规范的抽象定义。</p>
<p><strong>可以说在 Java 8 之后的 HotSpot 中 ”元空间用来实现了方法区“ 。</strong></p>
<p>Reference:<br><a href="https://www.zhihu.com/question/358312524">Java 8 中的 JVM 元空间是不是方法区</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>垃圾收集算法</title>
    <url>/2021/04/20/2021420-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>在 Java 中是由 JVM 来对“无用”对象执行垃圾的回收</p>
<span id="more"></span>

<h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>该算法分为“标记”和“清除”阶段：⾸先标记出所有不需要回收的对象，在标记完成后统⼀回收掉所有没有被标记的对象。</p>
<p>这个算法有两个缺点：</p>
<p>1.效率问题：每次垃圾回收都要先标记再回收，增加了工作量<br>2.空间问题：标记清除时，标记的对象并不处于连续的内存空间中，所以会产生大量不连续的碎片</p>
<p><img src="/images/JVM/mark_clean.png" alt="img"></p>
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>复制算法将内存分为大小相同的两块，当这一块内存使用完后，将其中存活的对象复制到另一块去，然后再把这一块的内存空间全部清理。</p>
<p><img src="/images/JVM/copy.png" alt="img"></p>
<h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>标记过程与”标记-清除“算法相同，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。</p>
<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>一般将Java堆分为新生代和老年代，根据各个年代的特点选择合适的垃圾回收算法。</p>
<p><img src="/images/JVM/eden_sur.png" alt="img"></p>
<p>过程：</p>
<p>新创建的对象首先分配到 Eden 区，如果 Eden 区空间不足，触发 GC 。</p>
<p>把 Eden 区存活的对象转移到 s1 区，然后清理 Eden 区。</p>
<p>当 Eden 区 和 s1 区空间不足时，将两区存活的对象转移到 s2 区，清理两区，并将 From 和 To 区交换。要始终保持 To 区空间为空。</p>
<p>对象进入老年代的情况：</p>
<p>1.假如进行 Minor GC 时发现，<strong>存活的对象在 To 区中存不下</strong>，那么把存活的对象存入老年代。</p>
<p>2.<strong>大对象直接进入老年代</strong>，假设新创建的对象很大，比如为 5M (这个值可以通过 PretenureSizeThreshold 这个参数进行设置，默认3M)，那么即使 Eden 区有足够的空间来存放，也不会存放在 Eden 区，而是直接存入老年代。</p>
<p>3.<strong>长期存活的对象将进入老年代</strong>，此外，如果对象在 Eden 出生并且经过1次 Minor GC 后仍然存活，并且能被 To 区容纳，那么将被移动到 To 区，并且把对象的年龄设置为1，对象没”熬过”一次 Minor GC (没有被回收，也没有因为 To 区没有空间而被移动到老年代中)，年龄就增加一岁，当它的年龄增加到一定程度(默认15岁，配置参数 -XX:MaxTenuringThreshold)，就会被晋升到老年代中。</p>
<p>4.<strong>动态对象年龄判定</strong>，还有一种情况，如果在 From 空间中，相同年龄所有对象的大小总和大于 From 和 To 空间总和的一半，那么年龄大于等于该年龄的对象就会被移动到老年代，而不用等到 15 岁(默认)。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>Java内部类</title>
    <url>/2021/05/14/2021514-Java%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>内部类一般分为四种：成员内部类、局部内部类、匿名内部类、静态内部类</p>
<span id="more"></span>

<p><img src="/images/Java/innerClass.png" alt="img"></p>
<p>在 Java 中，可以将一个类定义在另一个类里面或者一个方法里边，这样的类称为内部类，广泛意义上的内部类一般包括四种：成员内部类，局部内部类，匿名内部类，静态内部类 。</p>
<p><strong>1.成员内部类</strong></p>
<p>（1）该类像是外部类的一个成员，可以<strong>无条件的访问外部类的所有成员属性和成员方法（包括 private 成员和静态成员）</strong>；</p>
<p>（2）成员内部类拥有与外部类同名的成员变量时，会发生隐藏现象，即默认情况下访问的是成员内部类中的成员。如果要<strong>访问外部类中的成员</strong>，需要以下形式访问：[外部类.this.成员变量 或 外部类.this.成员方法]；</p>
<p>（3）<strong>在外部类中如果要访问成员内部类的成员</strong>，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问；</p>
<p>（4）成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，<strong>前提是必须存在一个外部类的对象</strong>；</p>
<p>（5）<strong>内部类可以拥有 private 访问权限、protected 访问权限、public 访问权限及包访问权限。</strong>如果成员内部类用 private 修饰，则只能在外部类的内部访问；如果用 public 修饰，则任何地方都能访问；如果用 protected 修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。外部类只能被 public 和包访问两种权限修饰。</p>
<p><strong>2.局部内部类</strong></p>
<p>（1）局部内部类是<strong>定义在一个方法或者一个作用域里面的类</strong>，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内；</p>
<p>（2）局部内部类就像是方法里面的一个局部变量一样，是<strong>不能有 public、protected、private 以及 static 修饰符的。</strong></p>
<p><strong>3.匿名内部类</strong></p>
<p>（1）一般使用匿名内部类的方法来<strong>编写事件监听代码</strong>；</p>
<p>（2）匿名内部类是<strong>不能有访问修饰符和 static 修饰符</strong>的；</p>
<p>（3）匿名内部类是<strong>唯一一种没有构造器的类</strong>；</p>
<p>（4）匿名内部类用于<strong>继承其他类或是实现接口</strong>，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p>
<p><strong>4.内部静态类</strong></p>
<p>（1）静态内部类是<strong>不需要依赖于外部类</strong>的，这点和类的静态成员属性有点类似；</p>
<p>（2）<strong>不能使用外部类的非 static 成员变量或者方法</strong>。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>知识整理</category>
      </categories>
  </entry>
  <entry>
    <title>从输入URL到页面加载发生了什么</title>
    <url>/2021/04/22/2021422-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>从解析域名到最终返回页面经历了什么</p>
<span id="more"></span>

<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>总体来说分为以下六个过程：</p>
<p>1.DNS 解析<br>2.TCP 连接<br>3.发送 HTTP 请求<br>4.服务器处理请求并返回 HTTP 报文<br>5.浏览器解析渲染页面<br>6.连接结束</p>
<h2 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h2><p> DNS 解析的过程简单来说就是获取域名对应的 IP 地址。</p>
<p><img src="/images/ComputerNetworks/dns.png" alt="img"><br><a href="https://segmentfault.com/a/1190000006879700">https://segmentfault.com/a/1190000006879700</a></p>
<p>首先在本地域名服务器中查询 IP 地址，如果找不到，本地域名服务器向根域名服务器发送查询请求，如果也找不到，本地域名服务器则向 com 顶级域名服务器发送查询请求，以此类推。直到本地域名服务器查询到IP地址并把它缓存在本地，以备下次使用。</p>
<p>从以上过程可以看出：网址的解析是一个从右向左的过程，并且实际的网址是<a href="www.google.com">www.google.com</a>.，末尾的”.“对应的就是根域名服务器。默认情况下最后一位”.“都省略了。而在浏览器请求 DNS 的时候就会自动加上。所以，网址的解析过程为：. -&gt; .com. -&gt; google.com. -&gt; <a href="www.google.com">www.google.com</a>. 。</p>
<h3 id="DNS-优化"><a href="#DNS-优化" class="headerlink" title="DNS 优化"></a>DNS 优化</h3><p>每次查询域名对应的IP地址都需要繁多的步骤，多次查询域名服务器，需要消耗大量的时间和资源。所以，采用 DNS 缓存策略就可以有效提高查询速度。</p>
<ul>
<li>DNS 缓存<br>DNS 存在多级缓存，按照距离的浏览器远近程度可分为：浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、根域名服务器缓存、顶级域名服务器缓存、主域名服务器缓存。</li>
<li>DNS 负载均衡<br>如果多个用户只能重复请求同一个服务器，那么，该服务器将会承载太大的压力，就需要更高的性能和存储空间。但是，对于用户来说，需要的只是处理他所发出的请求，具体负责处理的服务器并不要求。所以， DNS 就可以根据服务器的负载量，地理位置上的距离等因素来分配合适的服务器为用户服务，这个过程就是 DNS 负载均衡，或者叫 DNS 重定向。例如，CDN 内容分发就是利用 DNS 重定向来分配一个距离用户最近的 IP 地址给用户。</li>
</ul>
<h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h2><p>在通过第一步的 DNS 域名解析后，获取到了服务器的 IP 地址，在获取到 IP 地址后，便会开始建立一次连接，这是由 TCP 协议完成的，主要通过三次握手进行连接。</p>
<p>第一次握手： 建立连接时，客户端发送 syn 包（syn=j）到服务器，并进入 SYN_SENT 状态，等待服务器确认；</p>
<p>第二次握手： 服务器收到 syn 包，必须确认客户的 SYN（ack=j+1），同时自己也发送一个 SYN 包（syn=k），即 SYN+ACK 包，此时服务器进入 SYN_RECV 状态；</p>
<p>第三次握手： 客户端收到服务器的 SYN+ACK 包，向服务器发送确认包 ACK (ack=k+1），此包发送完毕，客户端和服务器进入 ESTABLISHED（TCP连接成功）状态，完成三次握手。</p>
<p>完成三次握手，客户端与服务器开始传送数据。</p>
<h2 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h2><p>HTTP请求报文是由三部分组成: 请求行, 请求报头和请求正文。</p>
<h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p>格式：Method Request-URL HTTP-Version CRLF</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">index.html</span> <span class="meta">HTTP/1.1</span></span><br></pre></td></tr></table></figure>

<h3 id="请求报头"><a href="#请求报头" class="headerlink" title="请求报头"></a>请求报头</h3><p>请求报头允许客户端向服务器传递请求的附加信息和客户端自身的信息。</p>
<p>常见的请求报头有: Accept, Accept-Charset, Accept-Encoding, Accept-Language, Content-Type, Authorization, Cookie, User-Agent 等。</p>
<p>Accept 用于指定客户端用于接受哪些类型的信息，Accept-Encoding 与 Accept 类似，它用于指定接受的编码方式。Connection 设置为 Keep-alive 用于告诉客户端本次 HTTP 请求结束之后并不需要关闭 TCP 连接，这样可以使下次 HTTP 请求使用相同的 TCP 通道，节省 TCP 连接建立的时间。</p>
<h3 id="请求正文"><a href="#请求正文" class="headerlink" title="请求正文"></a>请求正文</h3><p>当使用 POST, PUT 等方法时，通常需要客户端向服务器传递数据。这些数据就储存在请求正文中。在请求包头中有一些与请求正文相关的信息，例如: 现在的 Web 应用通常采用 Rest 架构，请求的数据格式一般为 json。这时就需要设置 Content-Type: application/json。</p>
<h2 id="返回HTTP报文"><a href="#返回HTTP报文" class="headerlink" title="返回HTTP报文"></a>返回HTTP报文</h2><p>HTTP 响应报文也是由三部分组成: 状态码, 响应报头和响应正文。</p>
<h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><p>状态码是由 3 位数组成，第一个数字定义了响应的类别，且有五种可能取值:</p>
<ul>
<li>1xx：指示信息–表示请求已接收，继续处理。</li>
<li>2xx：成功–表示请求已被成功接收、理解、接受。</li>
<li>3xx：重定向–要完成请求必须进行更进一步的操作。</li>
<li>4xx：客户端错误–请求有语法错误或请求无法实现。</li>
<li>5xx：服务器端错误–服务器未能实现合法的请求。</li>
</ul>
<p>平时遇到比较常见的状态码有:200, 204, 301, 302, 304, 400, 401, 403, 404, 422, 500</p>
<h3 id="响应报头"><a href="#响应报头" class="headerlink" title="响应报头"></a>响应报头</h3><p>类似于请求报头，常见的属性：Server、Expires、Connection等。</p>
<h3 id="响应正文"><a href="#响应正文" class="headerlink" title="响应正文"></a>响应正文</h3><p>服务器返回给浏览器的文本信息，通常 HTML, CSS, JS, 图片等文件就放在这一部分。</p>
<h2 id="渲染页面"><a href="#渲染页面" class="headerlink" title="渲染页面"></a>渲染页面</h2><p>浏览器是一个边解析边渲染的过程。首先浏览器解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</p>
<h2 id="连接结束"><a href="#连接结束" class="headerlink" title="连接结束"></a>连接结束</h2><p>通过四次挥手关闭连接</p>
<p>第一次挥手是浏览器发完数据后，发送 FIN 请求断开连接。</p>
<p>第二次挥手是服务器发送 ACK 确认报文，表示同意。</p>
<p>第三次挥手是服务器可能还有数据要发送，并且发送 FIN 释放连接。</p>
<p>第四次挥手是客户端收到连接释放报文后，发出 ACK 确认报文。</p>
<p>服务器收到客户端的确认报文后，立即进入 CLOSED 状态。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>子类父类的代码执行顺序</title>
    <url>/2021/05/11/2021511-%E5%AD%90%E7%B1%BB%E7%88%B6%E7%B1%BB%E7%9A%84%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<p>子类父类的代码执行顺序</p>
<span id="more"></span>

<h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> j = <span class="number">1</span>; <span class="comment">//静态类变量显示赋值代码</span></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类静态代码块&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">	&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类非静态代码块&quot;</span>);    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;父类构造函数&quot;</span>);    </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> j = <span class="number">1</span>; <span class="comment">//静态类变量显示赋值代码</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类静态代码块&quot;</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类非静态代码块&quot;</span>);    </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;子类构造函数&quot;</span>);    </span><br><span class="line">    &#125;  </span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<blockquote>
<p>main 方法所在的类需要先加载和初始化</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">父类静态代码块</span><br><span class="line">子类静态代码块</span><br><span class="line">父类非静态代码块</span><br><span class="line">父类构造函数</span><br><span class="line">子类非静态代码块</span><br><span class="line">子类构造函数</span><br></pre></td></tr></table></figure>

<h2 id="类初始化过程"><a href="#类初始化过程" class="headerlink" title="类初始化过程"></a>类初始化过程</h2><ol>
<li>一个类要创建实例需要先加载并初始化该类<ul>
<li><strong>main 方法</strong>所在的类需要先加载和初始化</li>
</ul>
</li>
<li>一个子类要初始化需要先初始化父类</li>
<li>一个类初始化就是执行 &lt;clinit&gt;() 方法<ul>
<li>&lt;clinit&gt;() 方法由<strong>静态类变量显式赋值代码</strong>和<strong>静态代码块</strong>组成，按照<strong>从上到下的顺序</strong>执行，且<strong>只执行一次</strong></li>
</ul>
</li>
</ol>
<h2 id="实例初始化过程"><a href="#实例初始化过程" class="headerlink" title="实例初始化过程"></a>实例初始化过程</h2><ol>
<li>实例初始化就是执行 &lt;init&gt;() 方法<ul>
<li>&lt;init&gt;() 方法可能重载有多个，<strong>有几个构造器就有几个</strong></li>
<li>&lt;init&gt;() 方法由<strong>非静态实例变量显式赋值代码</strong>和<strong>非静态代码块</strong>、<strong>对应构造器代码</strong>组成</li>
<li>按照从上到下顺序执行，但<strong>构造器代码总是最后执行</strong></li>
<li>每次创建实例对象调用了对应的构造器，就会执行对应的 &lt;init&gt;() 方法</li>
<li>&lt;init&gt;() 方法的<strong>首行是 super() 或 super(args)</strong> ，即对应了父类的 &lt;init&gt;() 方法</li>
</ul>
</li>
</ol>
<h2 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h2><ol>
<li>哪些方法不可以被重写<ul>
<li>final 方法</li>
<li>静态方法</li>
<li>private 修饰后子类中不可见的方法</li>
</ul>
</li>
<li>对象的多态性<ul>
<li>非静态方法前面其实有一个默认的对象 this ，代表了当前正在创建的对象。</li>
<li>这里对应了 son 对象，所以当涉及到父类中被重写的方法时，实际上调用的是被子类重写过后的方法。</li>
</ul>
</li>
</ol>
<h2 id="例子2："><a href="#例子2：" class="headerlink" title="例子2："></a>例子2：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = test();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> j = method();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;(1)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Father()&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;(2)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;(3)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;(4)&quot;</span>);</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;(5)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = test();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> j = method();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;(6)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Son() &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;(7)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;(8)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;(9)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;(10)&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Son s1 = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println();</span><br><span class="line">        Son s2 = <span class="keyword">new</span> Son();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>输出结果：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(<span class="number">5</span>)(<span class="number">1</span>)(<span class="number">10</span>)(<span class="number">6</span>)(<span class="number">9</span>)(<span class="number">3</span>)(<span class="number">2</span>)(<span class="number">9</span>)(<span class="number">8</span>)(<span class="number">7</span>)</span><br><span class="line">(<span class="number">9</span>)(<span class="number">3</span>)(<span class="number">2</span>)(<span class="number">9</span>)(<span class="number">8</span>)(<span class="number">7</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>知识整理</category>
      </categories>
  </entry>
  <entry>
    <title>一条SQL语句在MySQL中如何执行</title>
    <url>/2021/04/24/2021424-%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%E5%9C%A8MySQL%E4%B8%AD%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<p>——摘录自<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485097&idx=1&sn=84c89da477b1338bdf3e9fcd65514ac1&chksm=cea24962f9d5c074d8d3ff1ab04ee8f0d6486e3d015cfd783503685986485c11738ccb542ba7&token=79317275&lang=zh_CN%23rd">一条SQL语句在MySQL中如何执行的</a></p>
<span id="more"></span>

<h2 id="MySQL基础架构分析"><a href="#MySQL基础架构分析" class="headerlink" title="MySQL基础架构分析"></a>MySQL基础架构分析</h2><p><img src="/images/MySQL/construct.png" alt="img"></p>
<ul>
<li>Server 层：<ul>
<li><strong>连接器：身份认证和权限相关</strong>（登录 MySQL 的时候）<br>主要负责用户登录数据库，进行用户的身份认证，包括包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的。</li>
<li><strong>查询缓存：缓存我们执行的SELECT语句以及结果集</strong>（ MySQL 8.0 后删除该功能）<br>连接器建立连接后，执行查询语句时，会先查询缓存中的 K/V 串中是否存在该语句。如果命中，直接返回 Value 给客户端，否则执行后续操作，完成后把结果存入缓存中。但在实际业务中，如果一个表上的数据经常更新的话，就会导致缓存频繁失效。</li>
<li><strong>分析器：分析 SQL 语句是否正确</strong><br>第一步，词法分析，将一条 SQL 语句中的关键字提取出来，例如 select ，查询的表，字段名，查询条件等。<br>第二步，语法分析，分析 SQL 语句的语法是否符合 MySQL 规范。</li>
<li><strong>优化器：按照 MySQL 认为最优的方案去执行</strong><br>涉及到多个索引的时候如何选择索引，多表查询的时候如何选择关联顺序。</li>
<li><strong>执行器：执行语句，然后从存储引擎返回数据</strong><br>首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</li>
<li><strong>Binlog：归档日志模块</strong></li>
</ul>
</li>
<li>存储引擎：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</strong></li>
</ul>
<h2 id="语句分析"><a href="#语句分析" class="headerlink" title="语句分析"></a>语句分析</h2><p>SQL 可以分为查询语句和更新（增删改）语句</p>
<h3 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_student A <span class="keyword">where</span> A.age<span class="operator">=</span><span class="string">&#x27;18&#x27;</span> <span class="keyword">and</span> A.name<span class="operator">=</span><span class="string">&#x27;张三&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>执行流程：<br>1.先<strong>检查该语句是否有权限</strong>，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先<strong>查询缓存</strong>，以这条 SQL 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。<br>2.通过分析器进行<strong>词法分析</strong>，提取 SQL 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id=’1’。然后判断这个 sql 语句<strong>是否有语法错误</strong>，比如关键词是否正确等等，如果检查没问题就执行下一步。<br>3.接下来时优化器<strong>选定执行方案</strong>： a.先查询表中姓名为“张三”的学生，再判断年龄是否为 18 b.先找出表中年龄为 18 岁的学生，然后再选出姓名为“张三”的学生 优化器将根据自己的优化算法选择执行效率最好的一个方案<br>4.进行<strong>权限校验</strong>，如果没有权限就会返回错误信息，如果有权限，<strong>执行器</strong>就会调用数据库引擎接口，返回引擎的执行结果。</p>
<h3 id="更新语句"><a href="#更新语句" class="headerlink" title="更新语句"></a>更新语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">update tb_student A <span class="keyword">set</span> A.age<span class="operator">=</span><span class="string">&#x27;19&#x27;</span> <span class="keyword">where</span> A.name<span class="operator">=</span><span class="string">&#x27; 张三 &#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>实际数据库不设置年龄字段，因为每年的年龄都会增加一，可以设置出生日期字段就可以解决每年一改的问题。 执行更新操作的时候，需要记录日志，用到MySQL自带的 binlog （归档日志），以及 InnoDB 自带的 redo log （重做日志）。</p>
<p>执行流程（InnoDB）：<br>1.先<strong>查询</strong>到张三这条数据。<br>2.把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时<strong>记录 redo log</strong>，此时 <strong>redo log 进入 prepare 状态</strong>，然后告诉执行器，执行完成了，随时可以提交。<br>3.执行器收到通知后<strong>记录 binlog</strong>，然后调用引擎接口，提交 <strong>redo log 为提交状态</strong>。<br>4.更新<strong>完成</strong>。</p>
<h2 id="为什么用两个日志模块（binlog-和-redo-log）"><a href="#为什么用两个日志模块（binlog-和-redo-log）" class="headerlink" title="为什么用两个日志模块（binlog 和 redo log）"></a>为什么用两个日志模块（binlog 和 redo log）</h2><p>使用 redo log 可以使 MySQL 具有 crash-safe 的能力，在数据库发生异常重启的时候，保证之前提交的记录不会丢失，而 binlog 日志只能用来归档。</p>
<p>InnoDB 通过 redo log 来支持事务操作： 先记录 redo log 并进入 prepare 状态，等 binlog 记录完成后，提交 redo log 为提交状态。</p>
<p>如果还没提交 redo log 时，数据库异常重启，出现数据一致性问题，那么 MySQL 进行如下操作：</p>
<ul>
<li>判断 redo log 是否完整，如果判断是完整的，就立即提交。</li>
<li>如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>i=i++的执行过程</title>
    <url>/2021/05/16/2021516-i=i++%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>i=i++ 的执行顺序涉及到了 JVM 的内部原理</p>
<span id="more"></span>

<p>执行以下程序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       i = i++;</span><br><span class="line">       System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>得到结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>

<p>为什么执行了 i++ 之后，i 的值仍然是 0 ？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = i++;</span><br></pre></td></tr></table></figure>

<p>Java 虚拟机栈（JVM Stack）描述的是 Java 方法执行的内存模型，而 JVM 内存模型是基于“栈帧”的，每个栈帧中都有<strong>局部变量表</strong>和<strong>操作数栈</strong>（还有动态链接、return address等），那么 JVM 是如何执行这个语句的呢？通过 javap 大致可以将上面的两行代码翻译成如下的 JVM 指令执行代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: iconst_0</span><br><span class="line"><span class="number">1</span>: istore_1</span><br><span class="line"><span class="number">2</span>: iload_1</span><br><span class="line"><span class="number">3</span>: iinc          <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"><span class="number">6</span>: istore_1</span><br><span class="line"><span class="number">7</span>: iload_1</span><br></pre></td></tr></table></figure>

<p>接下来分析一下 JVM 是如何执行的: </p>
<p><strong>第0：</strong>将 int 类型的 0 入栈，就是放到操作数栈的栈顶<br><strong>第1：</strong>将操作数栈栈顶的值 0 弹出，保存到局部变量表 index（索引）值为 1 的位置。（局部变量表也是从 0 开始的，0 位置一般保存当前实例的 this 引用，当然静态方法例外，因为静态方法是类方法而不是实例方法）<br><strong>第2：</strong>将局部变量表 index 1 位置的值的副本入栈。（这时局部变量表 index 为 1 的值是 0，操作数栈顶的值也是 0）<br><strong>第3：</strong>iinc 是对 int 类型的值进行自增操作，后面第一个数值 1 表示，局部变量表的 index 值，说明要对此值执行 iinc 操作，第二个数值 1 表示要增加的数值。（这时局部变量表 index 为 1 的值因为执行了自增操作变为 1了，但是操作数栈中栈顶的值仍然是 0 ）<br><strong>第6：</strong>将操作数栈顶的值弹出（值 0 ），放到局部变量表 index 为 1 的位置（旧值：1，新值：0），覆盖了上一步局部变量表的计算结果。<br><strong>第7：</strong>将局部变量表 index 1 位置的值的副本入栈。（这时局部变量表 index 为 1 的值是 0，操作数栈顶的值也是 0 ）</p>
<p><strong>总结：</strong>从执行顺序可以看到，这里第 1 和第 6 执行了 2 次将 0 赋值给变量 i 的操作（ = 号赋值），i++ 操作是在这两次操作之间执行的，自增操作是对局部变量表中的值进行自增，而栈顶的值没有发生变化，这里需要注意的是保存这个初始值的地方是操作数栈而不是局部变量表，最后再将栈顶的值覆盖到局部变量表 i 所在的索引位置中去。</p>
<p>当代码修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = ++i;</span><br></pre></td></tr></table></figure>

<p>JVM 指令执行代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: iconst_0</span><br><span class="line"><span class="number">1</span>: istore_1</span><br><span class="line"><span class="number">2</span>: iinc          <span class="number">1</span>, <span class="number">1</span></span><br><span class="line"><span class="number">5</span>: iload_1</span><br><span class="line"><span class="number">6</span>: istore_1</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统的发展过程</title>
    <url>/2021/05/17/2021517-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>操作系统主要分为：单道批处理系统、多道批处理系统、分时系统、实时系统</p>
<span id="more"></span>

<h2 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h2><p>概念：系统对作业的处理都是成批进行的、且内存中始终只保持一道作业，称为单道批处理系统。</p>
<p>主要特征：<br>（1）自动性：一批作业自动逐个运行，无须人工干预<br>（2）顺序性：正常情况下作业按顺序完成<br>（3）单道性：内存中只有一道程序</p>
<p>缺点：<br>（1）CPU 利用率低<br>（2）内存浪费</p>
<h2 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h2><p><strong>多道：</strong></p>
<p>多道的概念：系统中同时驻留多个作业，并使它们交替地运行，保持 CPU 处于忙碌状态。</p>
<p>多道的优点：<br>（1）提高 CPU 利用率<br>（2）提高内存和 I/O 设备利用率<br>（3）提高了系统吞吐量</p>
<p><strong>多道批处理系统：</strong></p>
<p>主要特征：<br>（1）多道性：内存中同时驻留多个程序，并发执行<br>（2）无序性：多个作业完成的先后顺序与它们进入内存顺序无对应关系<br>（3）调度性：完成两次调度 作业调度：从外存中选择若干个作业调入内存 进程调度：分配 CPU </p>
<p>优点：资源利用率高；系统吞吐量大；</p>
<p>缺点：平均周转时间长；无交互能力；</p>
<p>多道批处理系统需解决的问题：</p>
<ul>
<li>处理机管理问题</li>
<li>内存管理问题</li>
<li>I/O管理问题</li>
<li>文件管理问题</li>
<li>作业管理问题</li>
<li>接口管理问题</li>
</ul>
<h2 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h2><p>概念：分时系统指一台主机上连接多个带有显示器和键盘的终端，同时允许多个用户共享主机中的资源，各个用户都可通过自己的终端以交互方式使用计算机。</p>
<p>主要特征：<br> （1）多路性：系统允许将多台终端同时连接到一台主机上<br> （2）独立性：多台终端之间互不干扰<br> （3）及时性：用户的请求能在很短的时间内获得响应<br> （4）交互性：用户可通过终端与系统进行广泛的人机对话</p>
<h2 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h2><p>概念：实时系统(Real-Time System)是指系统能及时(或即时)响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。</p>
<p>分类：<br> （1）周期性实时任务：外部设备周期性地发出激励信号给计算机，要求它按指定周期循环执行，以便周期性地控制某外部设备。<br> （2）非周期性实时任务： 开始截止时间：任务在某时间前必须开始执行。 完成截止时间：任务在某时间前必须完成。<br> （3）硬实时任务：系统必须满足任务对截止时间的要求。<br> （4）软实时任务：系统如果偶尔错过了截止时间，产生的影响不大。</p>
<p>主要特征： （1）多路性 （2）独立性 （3）及时性 （4）交互性 （5）可靠性</p>
<table>
<thead>
<tr>
<th>从系统特征对比</th>
<th>分时系统</th>
<th>实时系统</th>
</tr>
</thead>
<tbody><tr>
<td>多路性</td>
<td>按分时原则为多个终端用户服务</td>
<td>系统周期性地对多路现场信息进行采集，以及对多个对象或执行机构进行控制</td>
</tr>
<tr>
<td>独立性</td>
<td>每个终端用户彼此独立，互不干扰</td>
<td>对信息的采集和对对象的控制也是彼此互不干扰</td>
</tr>
<tr>
<td>及时性</td>
<td>用户角度：以用户所能接受的等待时间确定</td>
<td>程序角度：以控制对象所要求的截止时间确定</td>
</tr>
<tr>
<td>交互性</td>
<td>分时系统一般都是通用性很强的系统，允许系统和用户之间有较强的会话能力，交互性强。</td>
<td>实时系统大都是特殊的专用系统，外界操作是严格控制的，因此交互性弱。</td>
</tr>
<tr>
<td>可靠性</td>
<td>要求系统可靠</td>
<td>要求系统高度可靠</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>Java中的类加载过程</title>
    <url>/2021/05/06/202156-Java%E4%B8%AD%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>摘录自<a href="https://www.nowcoder.com/test/question/done?tid=44153410&qid=26108#summary">牛客网题解</a></p>
<span id="more"></span>

<h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：**加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)<strong>7个阶段。其中验证、准备、解析 3 个部分统称为</strong>连接(Linking)**。</p>
<p><img src="/images/JVM/classLoad.png" alt="img"></p>
<p>加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而<strong>解析阶段</strong>则不一定：它在某些情况下<strong>可以在初始化阶段之后再开始</strong>，这是为了支持 Java 语言的运行时绑定（也称为动态绑定或晚期绑定）。</p>
<h2 id="1加载"><a href="#1加载" class="headerlink" title="1加载"></a>1加载</h2><p>在加载阶段（可以参考java.lang. Class Loader的load Class ()方法），虚拟机需要完成以下3件事情：</p>
<ol>
<li>通过一个类的全限定名来<strong>获取定义此类的二进制字节流</strong>（并没有指明要从一个 Class 文件中获取，可以从其他渠道，譬如：网络、动态生成、数据库等）；</li>
<li>将这个字节流所代表的静态存储结构<strong>转化为方法区的运行时数据结构</strong>；</li>
<li>在内存中<strong>生成一个代表这个类的java.lang. Class 对象</strong>，作为方法区这个类的各种数据的访问入口；</li>
</ol>
<p>加载阶段和连接阶段（Linking）的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的内容，这两个阶段的开始时间仍然保持着固定的先后顺序。</p>
<h2 id="2验证"><a href="#2验证" class="headerlink" title="2验证"></a>2验证</h2><p>验证是连接阶段的第一步，这一阶段的<strong>目的</strong>是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。<br>验证阶段大致会完成4个阶段的检验动作：</p>
<ol>
<li><strong>文件格式验证</strong>：验证字节流是否符合 Class 文件格式的规范；例如：是否以魔术0xCAFEBABE开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型。</li>
<li><strong>元数据验证</strong>：对字节码描述的信息进行语义分析（注意：对比 javac 编译阶段的语义分析），以保证其描述的信息符合Java语言规范的要求；例如：这个类是否有父类，除了 java.lang.Object 之外。</li>
<li><strong>字节码验证</strong>：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li><strong>符号引用验证</strong>：确保解析动作能正确执行。</li>
</ol>
<p>验证阶段是非常重要的，但不是必须的，它对程序运行期没有影响，如果所引用的类经过反复验证，那么可以考虑采用 -Xverifynone 参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h2 id="3准备"><a href="#3准备" class="headerlink" title="3准备"></a>3准备</h2><p>准备阶段是<strong>正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些变量所使用的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在堆中。其次，这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量的定义为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;            </span><br></pre></td></tr></table></figure>

<p><strong>那变量 value 在准备阶段过后的初始值为 0 ,而不是 123 。</strong>因为这时候尚未开始执行任何 java 方法，而把 value 赋值为 123 的 putstatic 指令是程序被编译后，存放于类构造器()方法之中，所以把 value 赋值为 123 的动作将在初始化阶段才会执行。 至于“特殊情况”是指：public static <strong>final</strong> int value = 123，即当类字段的字段属性是 ConstantValue 时，会在准备阶段初始化为指定的值，<strong>所以标注为 final 之后，value的值在准备阶段初始化为 123 而非 0 。</strong></p>
<h2 id="4解析"><a href="#4解析" class="headerlink" title="4解析"></a>4解析</h2><p>解析阶段是<strong>虚拟机将常量池内的符号引用替换为直接引用的过程</strong>。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。</p>
<h2 id="5初始化"><a href="#5初始化" class="headerlink" title="5初始化"></a>5初始化</h2><p>类初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正<strong>开始执行类中定义的 java 程序代码</strong>。在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则根据程序员通过程序制定的计划去初始化类变量和其他资源，或者说：<strong>初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程</strong>。</p>
<p>&lt;clinit&gt;()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块static{}中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统中的各种调度算法</title>
    <url>/2021/05/09/202159-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%90%84%E7%A7%8D%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>操作系统中涉及到的调度算法（作业、进程、空闲分区、页面、磁盘）</p>
<span id="more"></span>

<h2 id="常见的批处理作业调度算法"><a href="#常见的批处理作业调度算法" class="headerlink" title="常见的批处理作业调度算法"></a>常见的批处理作业调度算法</h2><p>1.<strong>先来先服务调度算法（FCFS）</strong>:就是<strong>按照各个作业进入系统的自然次序</strong>来调度作业。这种调度算法的优点是实现简单，公平。其缺点是没有考虑到系统中各种资源的综合使用情况，往往使短作业的用户不满意，因为短作业等待处理的时间可能比实际运行时间长得多。</p>
<p>2.<strong>短作业优先调度算法(SPF)</strong>: 就是<strong>优先调度并处理短作业</strong>，所谓短是指作业的运行时间短。而在作业未投入运行时，并不能知道它实际的运行时间的长短，因此需要用户在提交作业时同时提交作业运行时间的估计值。</p>
<p>3.<strong>最高响应比优先算法(HRN)：</strong>FCFS可能造成短作业用户不满，SPF可能使得长作业用户不满，于是提出HRN，选择<strong>响应比最高的作业</strong>运行。响应比=1+作业等待时间/作业处理时间。</p>
<p>4.<strong>基于优先数调度算法(HPF)<strong>：每一个作业规定一个表示该作业优先级别的整数，当需要将新的作业由输入井调入内存处理时，优先选择</strong>优先数最高</strong>的作业。</p>
<p>5.<strong>均衡调度算</strong>：即多级队列调度算法，具有优先级的就绪队列中按照 RR + FCFS 对队列中的作业进行调度。</p>
<p><strong>6.时间片轮转调度算法(RR)：</strong>系统规定一个时间长度(时间片/时间量)作为允许一个进程运行的时间，如果在这段时间该进程没有执行完，则必须让出CPU等待下一次分配的时间片。</p>
<ul>
<li>相关概念：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作业周转时间（Ti）＝完成时间(Tei)－提交时间(Tsi)</span><br><span class="line">作业平均周转时间(T)＝周转时间/作业个数</span><br><span class="line">作业带权周转时间（Wi）＝周转时间/运行时间</span><br><span class="line">响应比＝（等待时间＋运行时间）/运行时间</span><br></pre></td></tr></table></figure>

<h2 id="进程调度算法"><a href="#进程调度算法" class="headerlink" title="进程调度算法"></a>进程调度算法</h2><p>1.<strong>先进先出算法(FIFO)：</strong>按照进程进入就绪队列的<strong>先后次序</strong>来选择。即每当进入进程调度，总是把就绪队列的队首进程投入运行。</p>
<p>2.<strong>时间片轮转算法(RR)：</strong>分时系统的一种调度算法。轮转的基本思想是，将CPU的处理时间划分成一个个的时间片，就绪队列中的进程<strong>轮流运行一个时间片</strong>。当时间片结束时，就强迫进程让出CPU，该进程进入就绪队列，等待下一次调度，同时，进程调度又去选择就绪队列中的一个进程，分配给它一个时间片，以投入运行。</p>
<p>3.<strong>最高优先级算法(HPF)：</strong>进程调度每次将处理机分配给具有最高优先级的就绪进程。最高优先级算法可与不同的CPU方式结合形成<strong>可抢占式</strong>最高优先级算法和<strong>不可抢占式</strong>最高优先级算法。</p>
<ul>
<li>可抢占式 当出现比当前执行中的进程更高优先级的进程，就将处理机分配给新进程。</li>
<li>不可抢占式 一旦分配处理机给一个优先级最高的进程后，便会一直执行至进程完成。</li>
</ul>
<p>4.<strong>多级队列反馈法：</strong>几种调度算法的结合形式多级队列方式。 设置多个优先级递减、时间片递增的就绪队列，并且每个队列中按照先来先服务（FCFS）进行调度。（最后一个队列采用 RR 算法）</p>
<h2 id="空闲分区分配算法"><a href="#空闲分区分配算法" class="headerlink" title="空闲分区分配算法"></a>空闲分区分配算法</h2><p>1.<strong>首先适应算法(FF)：</strong>当接到内存申请时，查找分区说明表，找到<strong>第一个满足申请长度的空闲区</strong>，将其分割并分配。此算法简单，可以快速做出分配决定。</p>
<p>2.<strong>循环首次适应算法(NF)：</strong>和 FF 算法的区别是，不再是每次都从链首开始查找，而是<strong>从上次找到的空闲分区的下一个空闲分区开始查找</strong>，将其分割并分配。该算法可以使内存中的空闲分区分布得更均匀，从而减少了查找空闲分区时的开销，但这样会缺乏大的空闲分区。</p>
<p>3.<strong>最佳适应算法(BF)：</strong>当接到内存申请时，查找分区说明表，找到第一个<strong>能满足申请长度的最小空闲区</strong>，将其进行分割并分配。此算法最节约空间，因为它尽量不分割到大的空闲区，其缺点是可能会形成很多很小的空闲分区，称为“碎片”。</p>
<p>4.<strong>最坏适应算法(WF)：</strong>当接到内存申请时，查找分区说明表，找到能<strong>满足申请要求的最大的空闲区</strong>。该算法的优点是避免形成碎片，而缺点是分割了大的空闲区后，在遇到较大的程序申请内存时，无法满足的可能性较大。</p>
<h2 id="虚拟页式存储管理中的页面置换算法"><a href="#虚拟页式存储管理中的页面置换算法" class="headerlink" title="虚拟页式存储管理中的页面置换算法"></a>虚拟页式存储管理中的页面置换算法</h2><p>1.<strong>理想页面置换算法(OPT)：</strong>这是一种理想的算法，在实际中不可能实现。该算法的思想是：发生缺页时，选择<strong>以后永不使用或在最长时间内不再被访问</strong>的内存页面予以淘汰。</p>
<p>2.<strong>先进先出页面置换算法(FIFO)：</strong>选择<strong>最先进入内存</strong>的页面予以淘汰。</p>
<p>3.<strong>最近最久未使用算法（LRU）：</strong>选择在最近一段时间内<strong>最久没有使用过</strong>的页，把它淘汰。</p>
<p>4.<strong>最少使用算法（LFU）：</strong>选择到当前时间为止<strong>被访问次数最少</strong>的页转换。</p>
<h2 id="磁盘调度"><a href="#磁盘调度" class="headerlink" title="磁盘调度"></a>磁盘调度</h2><p>1.<strong>先来先服务（FCFS）</strong>：根据请求访问者的<strong>先后次序</strong>，按顺序服务。</p>
<p>2.<strong>最短寻道时间优先（SSTF）</strong>：让<strong>离当前磁道最近的请求访问者</strong>启动磁盘驱动器，即是让查找时间最短的那个作业先执行，而不考虑请求访问者到来的先后次序，这样就克服了先来先服务调度算法中磁臂移动过大的问题</p>
<p>3.<strong>扫描算法（SCAN）或电梯调度算法：</strong>总是从磁臂当前位置开始，沿磁臂的移动方向去选择<strong>离当前磁臂最近的那个柱面的访问者</strong>。如果沿磁臂的方向无请求访问时，就改变磁臂的移动方向。在这种调度方法下磁臂的移动类似于电梯的调度，所以它也称为电梯调度算法。</p>
<p>4.<strong>循环扫描算法（CSCAN）：</strong>循环扫描调度算法是在扫描算法的基础上改进的。磁臂改为单项移动，<strong>由外向里</strong>。当前位置开始沿磁臂的移动方向去选择离当前磁臂最近的哪个柱面的访问者。如果沿磁臂的方向无请求访问时，再回到最外，访问柱面号最小的作业请求。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>操作系统四大特性</title>
    <url>/2021/06/02/202162-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<p>并发、共享、异步、虚拟</p>
<span id="more"></span>

<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>说到并发，就不得不提到另一个相似的概念——并行。<br><strong>并发</strong>是指两个或多个事件在<strong>同一时间间隔内</strong>发生，具体来说，就是在宏观上，这多个事件是在同时发生，而在微观上，这几个事件是交替发生的。<br>而<strong>并行</strong>则是指两个或多个事件在<strong>同一时刻</strong>发生，即不论宏观微观均是同时发生。</p>
<h2 id="共享"><a href="#共享" class="headerlink" title="共享"></a>共享</h2><p>在操作系统中说到的共享也可以称为<strong>资源复用</strong>，是指系统中的资源可供内存中多个并发执行的进程共同使用。<br>目前主要实现资源共享的方式有如下两种：<br>一、互斥共享方式<br>将一段时间内只允许一个进程访问的资源，称为临界资源，保证各进程互斥地访问该资源。<br>二、同时访问方式<br>允许在一段时间内各进程“同时”进行访问，微观上仍然是交替进行的。</p>
<blockquote>
<p>并发和共享是多任务（多用户）OS的两个最基本的特征</p>
</blockquote>
<h2 id="虚拟"><a href="#虚拟" class="headerlink" title="虚拟"></a>虚拟</h2><p>该技术是通过“空分复用”或“时分复用”技术，<strong>将一条物理信道变为若干条逻辑信道</strong>，使原来只能供一对用户通话的物理信道，变为能供多个用户同时通话的逻辑信道。</p>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>操作系统的异步性体现在三个方面：<br>一是<strong>进程的异步性</strong>：进程以人们不可预知的速度向前推进。<br>二是<strong>程序的不可再现性</strong>：即程序执行的结果有时是不确定的。<br>三是<strong>程序执行时间的不可预知性</strong>：即每个程序何时执行，执行顺序以及完成时间是不确定的。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>算法练习</title>
    <url>/2021/06/23/2021623-%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="https://github.com/deepbreath373/Algorithm-learning.git">源码合集</a></p>
<span id="more"></span>

<p>源代码均上传至Github<br>使用<a href="https://github.com/deepbreath373/Algorithm-learning/blob/main/%E9%A2%98%E7%9B%AE.java%E8%AE%BF%E9%97%AE">https://github.com/deepbreath373/Algorithm-learning/blob/main/题目.java访问</a></p>
<p>动态规划：<br>丑数<br>剪绳子<br>把数字翻译成字符串<br>斐波那契数列<br>最长不含重复字符的子字符串<br>礼物的最大值<br>连续子数组的最大和</p>
<p>递归：<br>#DFS<br>字符串的排列<br>机器人的运动范围<br>矩阵中的路径</p>
<p>字符串：<br>替换空格<br>最长公共前缀<br>最长回文串<br>最长回文子串<br>验证回文串</p>
<p>二叉树：<br>#递归、#队列、#栈<br>之字形打印二叉树<br>二叉搜索树与双向链表<br>二叉搜索树的后序遍历序列<br>二叉树中和为某一值的路径<br>二叉树的镜像<br>从上到下打印二叉树<br>分行从上到下打印二叉树<br>对称的二叉树<br>序列化二叉树<br>树的子结构<br>重建二叉树</p>
<p>数组：<br>#排序<br>二维数组中的查找<br>打印从1到最大的n位数<br>找出数组中重复的数字<br>把数组排成最小的数<br>数组中出现次数超过一半的数字<br>旋转数组的最小数字<br>最小的K个数<br>调整数组顺序使奇数位于偶数前面<br>顺时针打印矩阵</p>
<p>数学：<br>#找规律<br>二进制中1的个数<br>数值的整数次方<br>数字序列中某一位的数字<br>整数1_n中1出现的个数<br>正则表达式匹配<br>表示数值的字符串</p>
<p>链表：<br>从尾到头打印链表<br>删除链表的节点<br>反转链表<br>合并两个排序的链表<br>复杂链表的复制<br>链表中倒数第k个节点<br>链表中环的入口节点</p>
<p>栈：<br>包含min函数的栈<br>栈的压入弹出序列<br>用两个栈实现队列</p>
<p>KMP算法：<br>变量名拆分</p>
<p>大小顶堆：<br>数据流中的中位数</p>
<p>HashMap：<br>第一个只出现一次的字符</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>final/finally/finalize</title>
    <url>/2021/06/27/2021627-finalfinallyfinalize/</url>
    <content><![CDATA[<p>final/finally/finalize 的区别</p>
<span id="more"></span>

<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol>
<li><strong>final 用于声明属性、方法和类：</strong><ul>
<li>final 属性不可变，指的是<strong>引用不可变</strong>，而不关心指向对象内容的变化，被final 修饰的变量必须初始化</li>
<li>final 方法不可被子类重写，可以实现 inline (内联)的机制</li>
<li>final 类不可以被继承(如 String 、StringBuffer )，所有的方法不可以被重写，但其内的非 final 变量可以被修改</li>
</ul>
</li>
<li><strong>finally 作为异常处理的一部分</strong>，只能用在 try/catch 语句中，并且附带一个语句块，表示这段语句最终一定被执行(特殊情况不会被执行，如 try 语句前出现异常或 try 语句块中出现的异常没有被捕获)，经常被用在需要释放资源的情况下或是释放锁</li>
<li><strong>finalize 是 Object 类的一个方法</strong>，在垃圾回收器执行时会调用被回收对象的 finalize() 方法，可以覆盖此方法来实现对其他资源的回收(一旦垃圾回收器准备好释放对象占用的空间，将首先调用该方法，并且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存)，从功能上来说，finalize() 方法与 c++ 中的析构函数比较相似，但是 Java 采用的是基于垃圾回收器的自动内存管理机制，所以 finalize() 方法在本质上不同于 C++ 中的析构函数。</li>
</ol>
<h2 id="关于finalize的补充"><a href="#关于finalize的补充" class="headerlink" title="关于finalize的补充"></a><strong>关于finalize的补充</strong></h2><p>判定一个对象 objA 是否可回收，至少要经历两次标记过程：</p>
<ul>
<li>如果对象 objA 到 GC Roots 没有引用链，则进行第一次标记。</li>
<li>进行筛选，判断此对象是否有必要执行 finalize() 方法<ul>
<li>如果对象 objA 没有重写 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，则虚拟机视为“没有必要执行”，objA 被判定为不可触及的。</li>
<li>如果对象 objA 重写了 finalize() 方法，且还未执行过，<strong>那么 objA 会被插入到 F-Queue 队列中，由一个虚拟机自动创建的、低优先级的 Finalizer 线程触发其 finalize() 方法执行。</strong></li>
</ul>
</li>
<li><strong>finalize() 方法是对象逃脱死亡的最后机会</strong>，稍后 GC 会对 F-Queue 队列中的对象进行第二次标记。<strong>如果 objA 在 finalize() 方法中与引用链上的任何一个对象建立了联系</strong>，那么在第二次标记时，objA 会被移出“即将回收”集合。之后，对象会再次出现没有引用存在的情况。在这个情况下，finalize 方法不会被再次调用，对象会直接变成不可触及的状态，也就是说，<strong>一个对象的 finalize 方法只会被调用一次</strong>。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>知识整理</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式——单例模式</title>
    <url>/2021/06/04/202164-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。</p>
<span id="more"></span>

<h2 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于<strong>创建型模式</strong>，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时<strong>确保只有单个对象被创建</strong>。这个类<strong>提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象</strong>。</p>
<p>单例模式分为<strong>饿汉式</strong>和<strong>懒汉式</strong></p>
<h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><ul>
<li>单例类<strong>只能有一个实例</strong></li>
<li>单例类必须<strong>自己创建</strong>自己的唯一实例</li>
<li>单例类必须<strong>给所有其他对象提供</strong>这一实例</li>
</ul>
<h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ul>
<li>在内存里只有<strong>一个实例</strong>，减少了内存的开销，尤其是频繁的创建和销毁实例。</li>
<li>避免对资源的多重占用</li>
</ul>
<h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><ul>
<li>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外部的实例化方法。</li>
</ul>
<h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><ul>
<li>要求生产<strong>唯一序列号</strong>。 </li>
<li>WEB 中的<strong>计数器</strong>，不用每次刷新都在数据库里加一次，用单例先缓存起来。 </li>
<li>创建的一个对象需要<strong>消耗的资源过多</strong>，比如 I/O 与数据库的连接等。 </li>
</ul>
<h2 id="饿汉式："><a href="#饿汉式：" class="headerlink" title="饿汉式："></a>饿汉式：</h2><blockquote>
<p>需不需要该类的实例，其都会被创建</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//首先不能让外部可以对该类进行实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//自己创建一个私有的静态的实例对象，当类被加载的时候就创建出对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">//外部只能通过该方法获取对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//缺陷：如果有一个静态方法，但是即使只调用静态方法的时候，也会自动创建出对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="懒汉式："><a href="#懒汉式：" class="headerlink" title="懒汉式："></a>懒汉式：</h2><blockquote>
<p>当需要该类的实例时才会被创建</p>
</blockquote>
<p>使用<a href="https://deepbreath373.github.io/2021/04/18/2021418-Java%E4%B8%AD%E7%9A%84%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81">双重检查锁</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先不能让外部可以对该类进行实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里使用了双重检查，如果已经存在实例，不需要再去进行加锁操作，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//这一次判断也是必须的，不然会有并发问题</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="嵌套类："><a href="#嵌套类：" class="headerlink" title="嵌套类："></a>嵌套类：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>instance 的实例创建发生在内部类创建的时候，而内部类只有在调用了 getInstance 方法时才会被创建。所以，可以实现一个用时再创建的方式。</p>
<h2 id="枚举："><a href="#枚举：" class="headerlink" title="枚举："></a>枚举：</h2><p>最后，我们说一下枚举，枚举很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    INSTANCE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然我们平时很少看到用枚举来实现单例，但是在 RxJava 的源码中，有很多地方都用了枚举来实现单例。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>与HTTP关系密切的协议:IP、TCP、DNS</title>
    <url>/2021/08/04/202184-%E4%B8%8EHTTP%E5%85%B3%E7%B3%BB%E5%AF%86%E5%88%87%E7%9A%84%E5%8D%8F%E8%AE%AEIP%E3%80%81TCP%E3%80%81DNS/</url>
    <content><![CDATA[<p>针对 TCP/IP 协议族中与 HTTP 密不可分的 3 个协议进行说明</p>
<span id="more"></span>

<h2 id="负责传输的-IP-协议"><a href="#负责传输的-IP-协议" class="headerlink" title="负责传输的 IP 协议"></a>负责传输的 IP 协议</h2><p>IP 即 Internet Protocol （网络协议），TCP/IP 协议族中的 IP 指的就是网际协议，协议名称中占据了一半的位置，其重要性可见一斑。</p>
<p>IP 和 IP 地址有什么区别呢？</p>
<p><code>IP 协议的作用是把各种数据包传送给对方。而要保证确实传送到对方那里，则需要满足各类条件，其中最重要的两个条件是 IP 地址和 MAC 地址。</code></p>
<p><code>IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址可以和 MAC 地址进行配对。IP 地址可变换，但 MAC 地址基本上不会更改。</code></p>
<p><strong>IP 间的通信依赖于 MAC 地址</strong></p>
<p>一般情况下，通信的双方都不在同一个局域网内，通常都需要经过多台计算机和网络设备中转才能连接到对方。要想找到下一个中转目标，就要依靠下一中转设备的 MAC 地址来搜索确定。这时就采用 ARP 协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址。而在中转过程中，只能得到一条粗略的传输路线，这种机制称为路由选择。</p>
<h2 id="确保可靠性的-TCP-协议"><a href="#确保可靠性的-TCP-协议" class="headerlink" title="确保可靠性的 TCP 协议"></a>确保可靠性的 TCP 协议</h2><p>TCP 协议的目的是为了提供可靠的字节流服务，即为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理，并且利用 TCP 协议可以确认数据最终是否送达到对方。</p>
<p>为了准确无误地将数据送达目标处，TCP 协议采用三次握手策略来进行连接，以及四次挥手策略来进行断开。这里先简单说一下三次握手，发送端首先发送一个带有 SYN 标志的数据包给对方，接收端收到后回传给发送端一个带有 SYN/ACK 标志的数据包以示传达确认信息，最后，发送端二次发送给接收端一个带有 ACK 标志的数据包，至此，三次握手结束。</p>
<p><code>flag:有关三次握手和四次挥手的内容，先给自己挖个坑，以后再整理一篇详细的内容。</code></p>
<h2 id="负责域名解析的-DNS-服务"><a href="#负责域名解析的-DNS-服务" class="headerlink" title="负责域名解析的 DNS 服务"></a>负责域名解析的 DNS 服务</h2><p>DNS 提供域名到 IP 地址间的解析服务，我们在访问一个网站的时候，一般都是使用域名来进行访问，因为相对于 IP 地址纯数字的组合，域名字母数字相结合的方式明显更有利于人们进行记忆。但对于计算机而言，处理纯数字似乎它更加擅长，反而对付字母就有些困难了。所以，DNS 服务就是提供通过域名查找 IP 地址，或者从 IP 地址进行反查到域名的服务。</p>
<p>详情可以参考我整理的另一篇<a href="http://deepsea-blog.top/2021/04/22/2021422-%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/">《从输入URL到页面加载发生了什么》</a></p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="/images/ComputerNetworks/HTTP.jpg" alt="HTTP与各协议的联系"></p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>《图解HTTP》著/上野 宣</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>博客搭建第一天</title>
    <url>/2020/05/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/images/Frist.gif"></p>
]]></content>
      <categories>
        <category>随心</category>
      </categories>
  </entry>
  <entry>
    <title>Spring-AOP</title>
    <url>/2020/07/25/2020725-Spring-AOP/</url>
    <content><![CDATA[<p>SpringAOP 指的是面向切面编程，是 Spring 框架的核心特性之一。</p>
<span id="more"></span>

<h1 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h1><p>AOP(Aspect Oriented Programming)：面向切面编程。</p>
<p>可以把我们程序中<strong>重复的代码抽取</strong>出来，在需要执行的时候，使用<strong>动态代理</strong>的技术，在<strong>不修改源码</strong>的基础上，对我们的已有方法进行<strong>增强</strong>。可以提高开发的<strong>效率</strong>，并且便于<strong>维护</strong>。</p>
<h2 id="具体应用"><a href="#具体应用" class="headerlink" title="具体应用"></a>具体应用</h2><h3 id="非Spring中的案例"><a href="#非Spring中的案例" class="headerlink" title="非Spring中的案例"></a>非Spring中的案例</h3><h4 id="案例中的问题"><a href="#案例中的问题" class="headerlink" title="案例中的问题"></a>案例中的问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccountDao</span><span class="params">(IAccountDao accountDao)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.accountDao = accountDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此处的事务默认是自动控制的：connection 对象的 setAutoCommit(true)</p>
<p>如果一次执行多条 sql 语句就会出现问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Account source = accountDao.findByName(sourceName);</span><br><span class="line">Account target = accountDao.findByName(targetName);</span><br><span class="line"><span class="comment">//转出账户减钱，转入账户加钱</span></span><br><span class="line">source.setMoney(source.getMoney() - money);</span><br><span class="line">target.setMoney(target.getMoney() + money);</span><br><span class="line"><span class="comment">//更新两个账户</span></span><br><span class="line">accountDao.update(source);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>/<span class="number">0</span>;<span class="comment">//模拟转账异常</span></span><br><span class="line">accountDao.update(target);</span><br></pre></td></tr></table></figure>

<p>如果中途出现异常，则会出现转账操作的数据错误。这是因为在持久层的方法中，每个方法都是独立的事务，不符合事务的一致性。</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>让业务层来控制事务的提交和回滚，为每个方法加上事务的控制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个DBAssit</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DBAssit dbAssit = <span class="keyword">new</span> DBASSit(C3P0Utils.<span class="function">getDa <span class="title">taSource</span><span class="params">()</span>, <span class="keyword">true</span>)</span>;</span><br><span class="line">    <span class="comment">//开启事务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dbAssit.getCurrentConnection().setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dbAssit.getCurrentConnection().commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回滚事务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        	dbAssi t.getCurrentConnection().rollback();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(SQLException e)&#123;</span><br><span class="line">        	e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">	<span class="comment">//释放资源</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        	dbAssit.releaseConnection();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        	e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就可以在保存操作上加上事务保证数据一致性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TransactionManager.beginTransaction();</span><br><span class="line">        accountDao.save(account);</span><br><span class="line">        TransactionManager.commit();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        TransactionManager.rollback();</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        TransactionManager.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样在出现异常的时候就会进行事务的回滚，恢复正常的数据，保证了事务的一致性。</p>
<h4 id="新问题"><a href="#新问题" class="headerlink" title="新问题"></a>新问题</h4><p>因为要给每个方法都加上事务的控制，就导致整个业务层充斥着大量重复的代码，并且业务层和事务类产生耦合。</p>
<p>这时可以使用动态代理的方式解决。</p>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><ul>
<li>基于接口的动态代理<br>提供者：JDK官方的Proxy类 要求：被代理类最少实现一个接口</li>
<li>基于子类的动态代理<br>提供者：第三方的 CGLib ，如果报 asmxxx 异常，需要导入 asm.jar。<br>要求：被代理类不能用 final 修饰的类。</li>
</ul>
<h5 id="使用JDK官方的Proxy类创建代理对象"><a href="#使用JDK官方的Proxy类创建代理对象" class="headerlink" title="使用JDK官方的Proxy类创建代理对象"></a>使用JDK官方的Proxy类创建代理对象</h5><p>此处我们使用的是一个演员的例子： 在很久以前，演员和剧组都是直接见面联系的。没有中间人环节。 而随着时间的推移，产生了一个新兴职业：<strong>经纪人（中间人）</strong>，这个时候剧组再想找演员就需要通过经纪人来找了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *一个经纪公司的要求:</span></span><br><span class="line"><span class="comment"> *	能做基本的表演和危险的表演</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IActor</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 基本演出</span></span><br><span class="line"><span class="comment">     * @param money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicAct</span> <span class="params">(<span class="keyword">float</span> money)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 危险演出</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dangerAct</span> <span class="params">(<span class="keyword">float</span> money)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *一个演员</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//实现了接口，就表示具有接口中的方法实现。即:符合经纪公司的要求</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Actor</span> <span class="keyword">implements</span> <span class="title">IActor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicAct</span> <span class="params">(<span class="keyword">float</span> money)</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;拿到钱，开始基本的表演:&quot;</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dangerAct</span> <span class="params">(<span class="keyword">float</span> money)</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;拿到钱，开始危险的表演:&quot;</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//一个剧组找演员: </span></span><br><span class="line">	<span class="keyword">final</span> Actor actor = <span class="keyword">new</span> Actor();<span class="comment">//直接</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    代理:</span></span><br><span class="line"><span class="comment">    	间接。</span></span><br><span class="line"><span class="comment">    获取代理对象:</span></span><br><span class="line"><span class="comment">   	 要求:</span></span><br><span class="line"><span class="comment">    	被代理类最少实现一个接口</span></span><br><span class="line"><span class="comment">    创建的方式</span></span><br><span class="line"><span class="comment">    	Proxy. newProxyInstance (三个参数)</span></span><br><span class="line"><span class="comment">    参数含义:</span></span><br><span class="line"><span class="comment">    	ClassLoader:和被代理对象使用相同的类加载器。</span></span><br><span class="line"><span class="comment">        Interfaces:和被代理对象具有相同的行为。实现相同的接口。</span></span><br><span class="line"><span class="comment">        InvocationHandler: 如何代理。</span></span><br><span class="line"><span class="comment">    策略模式:使用场景是: </span></span><br><span class="line"><span class="comment">        数据有了，目的明确。</span></span><br><span class="line"><span class="comment">        如何达成目标，就是策略。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">IActor proxyActor = (IActor) Proxy.newProxyInstance(</span><br><span class="line">                                actor.getClass().getClassLoader(),</span><br><span class="line">                                actor.getClass().getInterfaces(),</span><br><span class="line">                                <span class="keyword">new</span> InvocationHandler()&#123;</span><br><span class="line">                                <span class="comment">//具体代理方法</span></span><br><span class="line">                                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                                    执行被代理对象的任何方法，都会经过该方法。</span></span><br><span class="line"><span class="comment">                                    此方法有拦截的功能。</span></span><br><span class="line"><span class="comment">                                    参数:</span></span><br><span class="line"><span class="comment">                                        proxy:代理对象的引用。不一定每次都用得到</span></span><br><span class="line"><span class="comment">                                        method:当前执行的方法对象</span></span><br><span class="line"><span class="comment">                                        args:执行方法所需的参数</span></span><br><span class="line"><span class="comment">                                    返回值:</span></span><br><span class="line"><span class="comment">                                        当前执行方法的返回值</span></span><br><span class="line"><span class="comment">                                */</span></span><br><span class="line">                                    <span class="meta">@Override</span></span><br><span class="line">                                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                                        String name = method.getName();</span><br><span class="line">                                        Float money = (Float) args[<span class="number">0</span>];</span><br><span class="line">                                        Object rtValue = <span class="keyword">null</span>;</span><br><span class="line">                                        <span class="comment">//每个经纪公司对不同演出收费不一样，此处开始判断</span></span><br><span class="line">                                        <span class="keyword">if</span>(<span class="string">&quot;basicAct&quot;</span>.equals(name))&#123;</span><br><span class="line">                                            <span class="comment">//基本演出，没有2000不演</span></span><br><span class="line">                                            <span class="keyword">if</span> (money &gt; <span class="number">2000</span>) &#123;</span><br><span class="line">                                                <span class="comment">//看上去剧组是给了8000，实际到演员手里只有4000</span></span><br><span class="line">                                                <span class="comment">//这就是我们没有修改原来basicAct方法源码，对方法进行了增强</span></span><br><span class="line">                                                rtValue = method.invoke(actor, money/<span class="number">2</span>);</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="keyword">if</span>(<span class="string">&quot;dangerAct&quot;</span>.equals(name)) &#123;</span><br><span class="line">                                            <span class="comment">//危险演出，没有5000不演</span></span><br><span class="line">                                            <span class="keyword">if</span> (money &gt; <span class="number">5000</span>) &#123;</span><br><span class="line">                                                <span class="comment">//看上去剧组是给了50000，实际到演员手里只有25000</span></span><br><span class="line">                                                <span class="comment">//这就是我们没有修改原来dangerAct方法源码，对方法进行了增强</span></span><br><span class="line">                                                rtValue = method.invoke(actor, money/<span class="number">2</span>);</span><br><span class="line">                                            &#125;</span><br><span class="line">                                        &#125;</span><br><span class="line">                                        <span class="keyword">return</span> rtvalue;</span><br><span class="line">                                   &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//没有经纪公司的时候，直接找演员。</span></span><br><span class="line">actor.basicAct(<span class="number">1000f</span>);</span><br><span class="line">actor.dangerAct(<span class="number">5000f</span>);</span><br><span class="line"><span class="comment">//剧组无法直接联系演员，而是由经纪公司找的演员</span></span><br><span class="line">proxyActor.basicAct(<span class="number">8000f</span>);</span><br><span class="line">proxyActor.dangerAct(<span class="number">50000f</span>);</span><br></pre></td></tr></table></figure>

<h5 id="使用-CGLib-的-Enhancer-类创建代理对象"><a href="#使用-CGLib-的-Enhancer-类创建代理对象" class="headerlink" title="使用 CGLib 的 Enhancer 类创建代理对象"></a>使用 CGLib 的 Enhancer 类创建代理对象</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//没有实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">basicAct</span> <span class="params">(<span class="keyword">float</span> money)</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;拿到钱，开始基本的表演:&quot;</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dangerAct</span> <span class="params">(<span class="keyword">float</span> money)</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;拿到钱，开始危险的表演:&quot;</span>+money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    基于子类的动态代理</span></span><br><span class="line"><span class="comment">   	 要求:</span></span><br><span class="line"><span class="comment">    	被代理对象不能是最终类</span></span><br><span class="line"><span class="comment">    用到的类:</span></span><br><span class="line"><span class="comment">   	 Enhancer</span></span><br><span class="line"><span class="comment">    用到的方法:</span></span><br><span class="line"><span class="comment">   	 create (Class, Callback)</span></span><br><span class="line"><span class="comment">    方法的参数:</span></span><br><span class="line"><span class="comment">   	 Class:被代理对象的字节码</span></span><br><span class="line"><span class="comment">   	 Callback:如何代理</span></span><br><span class="line"><span class="comment">    <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> Actor actor = <span class="keyword">new</span> Actor();</span><br><span class="line">	Actor cglibActor = (Actor) Enhancer.create(actor.getClass(), <span class="keyword">new</span> MethodInterceptor()&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    执行被代理对象的任何方法，都会经过该方法。在此方法内部就可以对被代理对象的任何方法进行增强。</span></span><br><span class="line"><span class="comment">    参数:</span></span><br><span class="line"><span class="comment">        前三个和基于接口的动态代理是一样的。</span></span><br><span class="line"><span class="comment">        MethodProxy:当前执行方法的代理对象。</span></span><br><span class="line"><span class="comment">    返回值:</span></span><br><span class="line"><span class="comment">        当前执行方法的返回值</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> object <span class="title">intercept</span><span class="params">(Object proxy, Method method, object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String name = method.getName();</span><br><span class="line">        Float money = (Float)args[<span class="number">0</span>];</span><br><span class="line">        Object rtValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;basicAct&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="comment">//基本演出</span></span><br><span class="line">            <span class="keyword">if</span> (money &gt; <span class="number">2000</span>) &#123;</span><br><span class="line">            	rtValue = method.invoke(actor, money/<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">if</span>(<span class="string">&quot;dangerAct&quot;</span>.equals(name)) &#123;</span><br><span class="line">            <span class="comment">//危险演出，没有5000不演</span></span><br><span class="line">            <span class="keyword">if</span> (money &gt; <span class="number">5000</span>) &#123;</span><br><span class="line">            rtValue = method.invoke(actor, money/<span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rtvalue;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    cglibActor.basicAct(<span class="number">10000</span>);</span><br><span class="line">    cglibActor.dangerAct(<span class="number">100000</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    创建账户业务层实现类的代理对象</span></span><br><span class="line"><span class="comment">    @return</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IAccountService <span class="title">getAccountService</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//1.定义被代理对象</span></span><br><span class="line">    	<span class="keyword">final</span> IAccountService accountService = <span class="keyword">new</span> AccountServiceImpl();</span><br><span class="line">        <span class="comment">//2.创建代理对象</span></span><br><span class="line">        IAccountService proxyAccountService = (IAccountService)Proxy.newProxyInstance(accountService.getClass().getClassLoader(), accountService.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler()&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        执行被代理对象的任何方法，都会经过该方法。</span></span><br><span class="line"><span class="comment">        此处添加事务控制</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                Object rtValue = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    TransactionManager.beginTransaction();</span><br><span class="line">                    rtValue = method.invoke(accountService, args);</span><br><span class="line">                    TransactionManager.commit();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    TransactionManager.rollback();</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    TransactionManager.release();</span><br><span class="line">                &#125;</span><br><span class="line">            	<span class="keyword">return</span> rtValue;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> proxyAccountService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们对 AccountServiceImpl 类实现了代理，每次执行其中的方法时都会先经过代理类，在代理类中开启事务。</p>
<h2 id="Spring中的AOP"><a href="#Spring中的AOP" class="headerlink" title="Spring中的AOP"></a>Spring中的AOP</h2><h3 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h3><ul>
<li><p>Joinpoint(连接点):<br>所谓连接点是指那些<strong>被拦截到的点</strong>。在 Spring 中,这些点指的是方法,因为 Spring 只支持方法类型的连接点。</p>
</li>
<li><p>Pointcut(切入点):<br>所谓切入点是指我们要对哪些 Joinpoint <strong>进行拦截的定义</strong>。</p>
</li>
<li><p>Advice(通知/增强):<br>所谓通知是指拦截到 Joinpoint <strong>之后所要做的事情</strong>就是通知。 通知的类型：前置通知,后置通知,异常通知,最终通知,环绕通知。</p>
</li>
<li><p>Introduction(引介):<br>引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在<strong>运行期为类动态地添加一些方法或 Field</strong>。</p>
</li>
<li><p>Target(目标对象):<br>代理的<strong>目标对象</strong>。</p>
</li>
<li><p>Weaving(织入):<br>是指把<strong>增强应用到目标对象来创建新的代理对象</strong>的过程。 Spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入。</p>
</li>
<li><p>Proxy（代理）:<br>一个类被 AOP 织入增强后，就产生一个<strong>结果代理类</strong>。</p>
</li>
<li><p>Aspect(切面):<br>是<strong>切入点和通知（引介）的结合</strong>。</p>
</li>
</ul>
<h3 id="基于XML的AOP配置"><a href="#基于XML的AOP配置" class="headerlink" title="基于XML的AOP配置"></a>基于XML的AOP配置</h3><h5 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h5><p>1.导入 jar 包</p>
<p><img src="/images/Spring/jar_ioc_aop.png" alt="image-20200725085033029"></p>
<p>2.创建Spring的配置文件并导入约束</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--此处要导入aop的约束--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>= <span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                    http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">                    http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.配置Spring 的ioc</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置service--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.service.impl.AccountServiceImpl&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;accountDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置dao--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;accountDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dao.impl.AccountDaoImpl&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dbAssit&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dbAssit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置数据库操作对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dbAssit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dbassit.DBAssit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;datasource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定connection和线程绑定--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>= <span class="string">&quot;useCurrentConnection&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>= <span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///spring_day02&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4.抽取公共代码制作成通知</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个DBAssit</span></span><br><span class="line">    <span class="keyword">private</span> DBAssit dbAssit;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDbAssit</span><span class="params">(DBASsit dbAssit)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.dbAssit = dbAssit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//开启事务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dbAssit.getCurrentConnection().setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回滚事务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dbAssit.getCurrentConnection().rollback();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e)</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tyr &#123;</span><br><span class="line">            dbAssit.releaseConnection();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace () ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="具体配置"><a href="#具体配置" class="headerlink" title="具体配置"></a>具体配置</h5><p>1.把通知类用 <strong>bean</strong> 标签配置起来</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置通知--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;txManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.utils.TransactionManager&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dbAssit&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dbAssit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.使用 <strong>aop:config</strong> 声明 aop 配置<br>    作用：用于声明开始 aop 的配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--配置的代码都写在此处--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.使用 <strong>aop:aspect</strong> 配置切面<br>    作用：用于配置切面<br>    属性：<br>        id：给切面提供一个唯一标识<br>        ref：引用配置好的通知类 bean 的 id</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--配置通知的类型要写在这此处--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>4.使用 <strong>aop:pointcut</strong> 配置切入点表达式<br>    作用：用于配置切入点表达式，指定对哪些类的哪些方法进行增强<br>    属性：<br>        expression：用于定义切入点表达式<br>        id：用于给切入点表达式提供一个唯一标识</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">&quot;execution(</span></span></span><br><span class="line"><span class="string"><span class="tag">                          	public void com.itheima.service.impl.AccountServiceImpl.transfer(java.lang.String,java.lang.String,java.lang.Float)</span></span></span><br><span class="line"><span class="string"><span class="tag">                          )&quot;</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    注：通常情况下，我们都是对业务层的方法进行增强，所以切入点表达式都是切换到业务层实现类(com.itheima.service.impl.*.*)</p>
<p>5.使用 aop:xxx 配置对应的通知类型<br>    <strong>aop:before</strong><br>    作用:<br>        用于配置前置通知。指定增强的方法在切入点方法之前执行<br>    属性:<br>        method:用于指定通知类中的增强方法名称<br>        ponitcut-ref:用于指定切入点的表达式的引用<br>        poinitcut:用于指定切入点表达式<br>    执行时间点:<br>        切入点方法执行之前执行</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;beginTransaction&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    <strong>aop:after-returning</strong><br>​    作用:<br>​        用于配置后置通知<br>​    属性:<br>​        method:指定通知中方法的名称。<br>​        pointct:定义切入点表达式<br>​        pointcut-ref:指定切入点表达式的引用<br>​    执行时间点:<br>​        切入点方法正常执行之后。它和异常通知只能有一个执行</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">&quot;commit&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    <strong>aop:after-throwing</strong><br>​    作用:<br>​        用于配置异常通知<br>​    属性:<br>​        method:指定通知中方法的名称。<br>​        pointct:定义切入点表达式<br>​        pointcut-ref:指定切入点表达式的引用<br>​    执行时间点:<br>​        切入点方法执行产生异常后执行。它和后置通知只能执行一个</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">&quot;rollback&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>​    <strong>aop:after</strong><br>​    作用:<br>​        用于配置最终通知<br>​    属性:<br>​        method:指定通知中方法的名称。<br>​        pointct:定义切入点表达式<br>​        pointcut-ref:指定切入点表达式的引用<br>​    执行时间点:<br>​        无论切入点方法执行时是否有异常，它都会在其后面执行。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">&quot;release&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>6.使用 <strong>aop:around</strong> 配置环绕通知<br>    作用:<br>        用于配置环绕通知<br>    属性:<br>        method:指定通知中方法的名称<br>        pointct:定义切入点表达式<br>        pointcut-ref:指定切入点表达式的引用<br>    说明:<br>        它是spring框架为我们提供的一种可以在代码中手动控制增强代码什么时候执行的方式。<br>    注意:<br>        通常情况下，环绕通知都是独立使用的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.itheima.service.impl.*.*(..))&quot;</span> <span class="attr">id</span>=<span class="string">&quot;pt1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--配置环绕通知--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:around</span> <span class="attr">method</span>=<span class="string">&quot;transactionAround&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pt1&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    环绕通知</span></span><br><span class="line"><span class="comment">    @param pjp</span></span><br><span class="line"><span class="comment">    spring框架为我们提供了一个接口:ProceedingJoinPoint,它可以作为环绕通知的方法参数。</span></span><br><span class="line"><span class="comment">    在环绕通知执行时，spring框架会为我们提供该接口的实现类对象，我们直接使用就行。</span></span><br><span class="line"><span class="comment">    @return</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> object <span class="title">transactionAround</span><span class="params">(ProceedingJoinPoint pjp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义返回值</span></span><br><span class="line">    object rtValue = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取方法执行所需的参数</span></span><br><span class="line">        object[] args = pjp.getArgs();</span><br><span class="line">        <span class="comment">//前置通知:开启事务</span></span><br><span class="line">        beginTransaction();</span><br><span class="line">        <span class="comment">//执行方法</span></span><br><span class="line">        rtValue = pip.proceed(args);</span><br><span class="line">        <span class="comment">//后置通知:提交事务</span></span><br><span class="line">        commit();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    <span class="comment">//异常通知:回滚事务</span></span><br><span class="line">        rollback() ;</span><br><span class="line">        e.printStackTrace() ;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//最终通知:释放资源</span></span><br><span class="line">        release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rtValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基于注解的AOP配置"><a href="#基于注解的AOP配置" class="headerlink" title="基于注解的AOP配置"></a>基于注解的AOP配置</h3><h5 id="环境搭建-1"><a href="#环境搭建-1" class="headerlink" title="环境搭建"></a>环境搭建</h5><p>1.导入 jar 包</p>
<p><img src="/images/Spring/jar_ioc_aop.png" alt="jar"></p>
<p>2.在配置文件导入 context 的名称空间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--此处要导入aop的约束--&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>= <span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">                    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                    http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="string"><span class="tag">                    http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                    http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">                    http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置数据库操作对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dbAssit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.itheima.dbassit.DBAssit&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;datasource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定connection和线程绑定--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>= <span class="string">&quot;useCurrentConnection&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置数据源--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>= <span class="string">&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClass&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jdbcUrl&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql:///spring_day02&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1234&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.把资源使用注解配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;accountService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository(&quot;accountDao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DBAssit dbAssit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.在配置文件中指定 Spring 要扫描的包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--告知Spring，在创建容器时要扫描的包--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="具体配置-1"><a href="#具体配置-1" class="headerlink" title="具体配置"></a>具体配置</h5><p>1.把通知类也使用注解配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;txManager&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DBAssit dbAssit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.在通知类上使用**@Aspect** 注解声明为切面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;txManager&quot;)</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DBAssit dbAssit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.在增强的方法上使用注解配置通知<br><strong>@Before</strong><br>    作用：把当前方法看成是前置通知<br>    属性：value：用于指定切入点表达式，还可以指定切入点表达式的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//开启事务</span></span><br><span class="line"><span class="meta">@Before(&quot;execution(* com.itheima.service.impl.*.*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	dbAssit.getCurrentConnection().setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    	e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@AfterReturning</strong><br>作用:把当前方法看成是后置通知。<br>属性:value:用于指定切入点表达式，还可以指定切入点表达式的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提交事务</span></span><br><span class="line"><span class="meta">@AfterReturning(&quot;execution(* com.itheima.service.impl.*.*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	dbAssit.getCurrentConnection().commit();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    	e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@AfterThrowing</strong><br>作用:把当前方法看成是异常通知。<br>属性:value:用于指定切入点表达式，还可以指定切入点表达式的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//回滚事务</span></span><br><span class="line"><span class="meta">@AfterThrowing(&quot;execution(* com.itheima.service.impl.*.*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	dbAssit.getCurrentConnection().rollback();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    	e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>@After</strong><br>作用:把当前方法看成是最终通知。<br>属性:value:用于指定切入点表达式，还可以指定切入点表达式的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//释放资源</span></span><br><span class="line"><span class="meta">@After(&quot;execution(* com.itheima.service.impl.*.*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    	dbAssit.releaseConnection();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    	e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4.在 Spring 配置文件中开启 Spring 对注解 AOP 的支持</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>5.环绕通知<br><strong>@Around</strong><br>作用:把当前方法看成是环绕通知。<br>属性:value:用于指定切入点表达式，还可以指定切入点表达式的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;execution(* com.itheima.service.impl.*.*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> object <span class="title">transactionAround</span><span class="params">(ProceedingJoinPoint pjp)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义返回值</span></span><br><span class="line">    object rtValue = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取方法执行所需的参数</span></span><br><span class="line">        object[] args = pjp.getArgs();</span><br><span class="line">        <span class="comment">//前置通知:开启事务</span></span><br><span class="line">        beginTransaction();</span><br><span class="line">        <span class="comment">//执行方法</span></span><br><span class="line">        rtValue = pip.proceed(args);</span><br><span class="line">        <span class="comment">//后置通知:提交事务</span></span><br><span class="line">        commit();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    <span class="comment">//异常通知:回滚事务</span></span><br><span class="line">        rollback() ;</span><br><span class="line">        e.printStackTrace() ;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//最终通知:释放资源</span></span><br><span class="line">        release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rtValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.切入点表达式注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(* com.itheima.service.impl.*.*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pt1</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在使用切入点表达式的时候可以使用方法名代替</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around(&quot;pt1()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">transactionAround</span><span class="params">(ProceedingJoinPoint pjp)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>7.不使用 XML 的配置方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuraion</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages=&quot;com.itheima&quot;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用Java类代替xml的配置文件</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>Lucene</title>
    <url>/2021/02/01/202121-Lucene/</url>
    <content><![CDATA[<p>Lucene 是一个开源的 Java 全文检索引擎架构，提供了完整的查询引擎和索引引擎</p>
<span id="more"></span>

<h2 id="什么是全文检索"><a href="#什么是全文检索" class="headerlink" title="什么是全文检索"></a>什么是全文检索</h2><ul>
<li>数据分类<br>结构化数据：指具有<strong>固定格式</strong>或<strong>有限长度</strong>的数据，如数据库，元数据等。<br>非结构化数据：指<strong>不定长</strong>或<strong>无固定格式</strong>的数据，如邮件，word文档等磁盘上的文件。</li>
<li>结构化数据搜索<br>通常是使用sql语句对数据库进行查询，而且很快就能得到查询结果。因为数据是定长和有固定格式的。</li>
<li>非结构化数据查询<ul>
<li>顺序扫描法 要找内容包含某一个字符串的文件，就是一个文档一个文档的看，对于每一个文档，从头看到尾。</li>
<li>全文检索（先建立索引，再对索引进行搜索） 将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据（索引）进行搜索，从而达到搜索相对较快的目的。</li>
</ul>
</li>
</ul>
<h2 id="Lucene实现全文检索的流程"><a href="#Lucene实现全文检索的流程" class="headerlink" title="Lucene实现全文检索的流程"></a>Lucene实现全文检索的流程</h2><p>1.索引和搜索流程图</p>
<p><img src="/images/Lucene/process.png" alt="img"></p>
<p>2.创建索引</p>
<p>​    2.1获得原始文档<br>​    原始文档指要索引和搜索的内容。原始内容包括互联网上的网页、数据库中的数据、磁盘上的文件等。</p>
<p>​    2.2创建文档对象<br>​    获取原始内容的目的是为了索引，在索引前需要将原始内容创建成文档（Document），文档中包括一个一个的域（Field），域中存储内容。  将磁盘上的一个文件当成一个Document，Document中包括一些Field(file_name,file_path,file_size,file_content)。 </p>
<p><img src="/images/Lucene/construct.png" alt="img"></p>
<p>PS：每个文档都有一个唯一的编号，文档ID。</p>
<p>2.3分析文档</p>
<p>将原始内容创建为包含域(Field)的文档(document)，需要再对域中的内容进行分析，分析的过程是经过对原始文档提取单词、将字母转为小写、去除标点符号、去除停用词等过程生成最终的语汇单元，可以将语汇单元理解为一个一个的单词。  每一个单词称为一个 Term ，不同的域中拆分出来的相同单词是不同的 Term 。Term 中包含两部分，一部分是文档的域名，另一部分是单词的内容。</p>
<p>2.4创建索引</p>
<p>对所有文档分析得出的词汇单元进行索引，索引的目的是为了搜索，最终要实现只搜索 被索引的语汇单元从而找到Document（文档）。 </p>
<p>PS：创建索引是对语汇单元索引，通过词语找文档，这种索引的结构叫<strong>倒排索引结构</strong>（根据内容找文档）。 </p>
<p><img src="/images/Lucene/index.png" alt="img"></p>
<p>3.查询索引</p>
<p>3.1用户查询接口（自行开发）<br>全文检索系统提供用户搜索的界面供用户提交搜索的关键字，搜索完成展示搜索结果。 （例如，百度搜索引擎的搜索界面）</p>
<p>3.2创建查询<br>用户输入查询关键字执行搜索之前需要先构建一个查询对象，查询对象中可以指定查询 要搜索的 Field 文档域、查询关键字等，查询对象会生成具体的查询语法。</p>
<p>3.3执行查询<br>根据查询语法在倒排索引字典表中分别找出对应搜索词的索引，从而找到索引所链接的文档链表。</p>
<p>3.4渲染结果<br>以一个友好的界面将查询结果展示给用户。</p>
<h2 id="配置开发环境"><a href="#配置开发环境" class="headerlink" title="配置开发环境"></a>配置开发环境</h2><p>1.Lucene下载</p>
<p>官方网站：<a href="http://lucene.apache.org/">http://lucene.apache.org/</a> 下载之后解压 </p>
<p><img src="/images/Lucene/download.png" alt="img"></p>
<p><img src="/images/Lucene/zip.png" alt="img"></p>
<p><img src="/images/Lucene/mirror_url.png" alt="img"></p>
<p>从镜像地址中任选其一进行下载 </p>
<p><img src="/images/Lucene/folder.png" alt="img"></p>
<p>2.使用的jar包<br>lucene-8.7.0\core\lucene-core-8.7.0.jar</p>
<p>lucene-8.7.0\analysis\common\lucene-analyzers-common-8.7.0.jar </p>
<p>将以上jar包拷入项目中即可</p>
<h2 id="入门程序"><a href="#入门程序" class="headerlink" title="入门程序"></a>入门程序</h2><h3 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a>1.需求</h3><p>实现一个文件的搜索功能，通过关键字搜索文件，凡是文件名或文件内容包括关键字的文件 都需要找出来。还可以根据中文词语进行查询，并且需要支持多个条件查询。</p>
<h3 id="2-创建索引"><a href="#2-创建索引" class="headerlink" title="2.创建索引"></a>2.创建索引</h3><p>2.1实现步骤<br>第一步：创建一个 java 工程，并导入 jar 包。<br>第二步：创建一个 indexwriter 对象。<br>        1）指定索引库的存放位置 Directory 对象<br>        2）指定一个 IndexWriterConfig 对象。<br>第三步：创建 document 对象。<br>第四步：创建 field 对象，将 field 添加到 document 对象 中。<br>第五步：使用 indexwriter 对象将 document 对象写入索 引库，此过程进行索引创建。并将索引和 document 对象 写入索引库。<br>第六步：关闭 IndexWriter 对象。</p>
<p>2.2代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建索引 </span></span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createIndex</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; <span class="comment">//指定索引库存放的路径 </span></span><br><span class="line">    <span class="comment">//D:\temp\index </span></span><br><span class="line">    Directory directory = FSDirectory.open(<span class="keyword">new</span> File(<span class="string">&quot;D:\\temp\\index&quot;</span>).toPath()); </span><br><span class="line">    <span class="comment">//索引库还可以存放到内存中 </span></span><br><span class="line">    <span class="comment">//Directory directory = new RAMDirectory(); </span></span><br><span class="line">    <span class="comment">//创建 indexwriterCofig 对象 </span></span><br><span class="line">    IndexWriterConfig config = <span class="keyword">new</span> IndexWriterConfig(); </span><br><span class="line">    <span class="comment">//创建 indexwriter 对象</span></span><br><span class="line">    IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(directory, config); </span><br><span class="line">    <span class="comment">//原始文档的路径 </span></span><br><span class="line">    File dir = <span class="keyword">new</span> File(<span class="string">&quot;D:\\temp\\searchsource&quot;</span>); </span><br><span class="line">    <span class="keyword">for</span> (File f : dir.listFiles()) &#123; </span><br><span class="line">        <span class="comment">//文件名 </span></span><br><span class="line">        String fileName = f.getName(); </span><br><span class="line">        <span class="comment">//文件内容 </span></span><br><span class="line">        String fileContent = FileUtils.readFileToString(f); </span><br><span class="line">        <span class="comment">//文件路径 </span></span><br><span class="line">        String filePath = f.getPath(); </span><br><span class="line">        <span class="comment">//文件的大小 </span></span><br><span class="line">        <span class="keyword">long</span> fileSize = FileUtils.sizeOf(f); </span><br><span class="line">        <span class="comment">//创建文件名域 </span></span><br><span class="line">        <span class="comment">//第一个参数：域的名称</span></span><br><span class="line">        <span class="comment">//第二个参数：域的内容 </span></span><br><span class="line">        <span class="comment">//第三个参数：是否存储 </span></span><br><span class="line">        Field fileNameField = <span class="keyword">new</span> TextField(<span class="string">&quot;filename&quot;</span>, fileName, Field.Store.YES); </span><br><span class="line">        <span class="comment">//文件内容域 </span></span><br><span class="line">        Field fileContentField = <span class="keyword">new</span> TextField(<span class="string">&quot;content&quot;</span>, fileContent, Field.Store.YES); </span><br><span class="line">        <span class="comment">//文件路径域（不分析、不索引、只存储） </span></span><br><span class="line">        Field filePathField = <span class="keyword">new</span> TextField(<span class="string">&quot;path&quot;</span>, filePath, Field.Store.YES);     <span class="comment">//文件大小域 </span></span><br><span class="line">        Field fileSizeField = <span class="keyword">new</span> TextField(<span class="string">&quot;size&quot;</span>, fileSize + <span class="string">&quot;&quot;</span>, Field.Store.YES); </span><br><span class="line">        <span class="comment">//创建 document 对象 </span></span><br><span class="line">        Document document = <span class="keyword">new</span> Document();         </span><br><span class="line">        document.add(fileNameField);                </span><br><span class="line">        document.add(fileContentField);             </span><br><span class="line">        document.add(filePathField);                </span><br><span class="line">        document.add(fileSizeField); </span><br><span class="line">        <span class="comment">//创建索引，并写入索引库 </span></span><br><span class="line">        indexWriter.addDocument(document); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭 indexwriter </span></span><br><span class="line">    indexWriter.close(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.3使用Luke工具查看索引文件</p>
<p><img src="/images/Lucene/luke.png" alt="img"></p>
<h3 id="3-查询索引"><a href="#3-查询索引" class="headerlink" title="3.查询索引"></a>3.查询索引</h3><p>3.1实现步骤<br>第一步：创建一个 Directory 对象，也就是索引库存放的位置。<br>第二步：创建一个 indexReader 对象，需要指定 Directory 对象。<br>第三步：创建一个 indexSearcher 对象，需要指定 indexReader 对象。<br>第四步：创建一个  Term Query 对象，指定查询的域和查询的关键词。<br>第五步：执行查询。<br>第六步：返回查询结果。遍历查询结果并输出。<br>第七步：关闭 IndexReader 对象</p>
<p>3.2代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询索引库 </span></span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">searchIndex</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">    <span class="comment">//指定索引库存放的路径 </span></span><br><span class="line">    <span class="comment">//D:\temp\index </span></span><br><span class="line">    Directory directory = FSDirectory.open(<span class="keyword">new</span> File(<span class="string">&quot;D:\\temp\\index&quot;</span>).toPath()); </span><br><span class="line">    <span class="comment">//创建 indexReader 对象 </span></span><br><span class="line">    IndexReader indexReader = DirectoryReader.open(directory); </span><br><span class="line">    <span class="comment">//创建 indexsearcher 对象 </span></span><br><span class="line">    IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(indexReader); </span><br><span class="line">    <span class="comment">//创建查询 </span></span><br><span class="line">    Query query = <span class="keyword">new</span>  <span class="function">Term <span class="title">Query</span><span class="params">(new  Term (<span class="string">&quot;filename&quot;</span>, <span class="string">&quot;apache&quot;</span>)</span>)</span>; </span><br><span class="line">    <span class="comment">//执行查询</span></span><br><span class="line">    <span class="comment">//第一个参数是查询对象，第二个参数是查询结果返回的最大值 </span></span><br><span class="line">    TopDocs topDocs = indexSearcher.search(query, <span class="number">10</span>); </span><br><span class="line">    <span class="comment">//查询结果的总条数 </span></span><br><span class="line">    System.out.println(<span class="string">&quot;查询结果的总条数：&quot;</span>+ topDocs.totalHits); </span><br><span class="line">    <span class="comment">//遍历查询结果 </span></span><br><span class="line">    <span class="comment">//topDocs.scoreDocs 存储了 document 对象的 id </span></span><br><span class="line">    <span class="keyword">for</span> (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123; </span><br><span class="line">        <span class="comment">//scoreDoc.doc 属性就是 document 对象的 id </span></span><br><span class="line">        <span class="comment">//根据 document 的 id 找到 document 对象 </span></span><br><span class="line">        Document document = indexSearcher.doc(scoreDoc.doc); </span><br><span class="line">        System.out.println(document.get(<span class="string">&quot;filename&quot;</span>)); </span><br><span class="line">        <span class="comment">//System.out.println(document.get(&quot;content&quot;)); </span></span><br><span class="line">        System.out.println(document.get(<span class="string">&quot;path&quot;</span>)); </span><br><span class="line">        System.out.println(document.get(<span class="string">&quot;size&quot;</span>)); </span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------------&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭 indexreader 对象 </span></span><br><span class="line">    indexReader.close(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h2><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查看标准分析器的分词效果</span></span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTokenStream</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">    <span class="comment">//创建一个标准分析器对象 </span></span><br><span class="line">    Analyzer analyzer = <span class="keyword">new</span> StandardAnalyzer(); </span><br><span class="line">    <span class="comment">//获得 tokenStream 对象 </span></span><br><span class="line">    <span class="comment">//第一个参数：域名，可以随便给一个 </span></span><br><span class="line">    <span class="comment">//第二个参数：要分析的文本内容 </span></span><br><span class="line">    TokenStream tokenStream = analyzer.tokenStream(<span class="string">&quot;test&quot;</span>, <span class="string">&quot;The Spring Framework provides a comprehensive programming and configuration model.&quot;</span>); </span><br><span class="line">    <span class="comment">//添加一个引用，可以获得每个关键词 </span></span><br><span class="line">    Char Term Attribute <span class="keyword">char</span> Term Attribute = tokenStream.addAttribute(Char Term Attribute.class);</span><br><span class="line">    <span class="comment">//添加一个偏移量的引用，记录了关键词的开始位置以及结束位置 </span></span><br><span class="line">    OffsetAttribute offsetAttribute = tokenStream.addAttribute(OffsetAttribute.class); </span><br><span class="line">    <span class="comment">//将指针调整到列表的头部 </span></span><br><span class="line">    tokenStream.reset(); </span><br><span class="line">    <span class="comment">//遍历关键词列表，通过 incrementToken 方法判断列表是否结束 </span></span><br><span class="line">    <span class="keyword">while</span>(tokenStream.incrementToken()) &#123; </span><br><span class="line">        <span class="comment">//关键词的起始位置 </span></span><br><span class="line">        System.out.println(<span class="string">&quot;start-&gt;&quot;</span> + offsetAttribute.startOffset()); </span><br><span class="line">        <span class="comment">//取关键词 </span></span><br><span class="line">        System.out.println(<span class="keyword">char</span> Term Attribute); </span><br><span class="line">        <span class="comment">//结束位置 </span></span><br><span class="line">        System.out.println(<span class="string">&quot;end-&gt;&quot;</span> + offsetAttribute.endOffset()); </span><br><span class="line">    &#125;</span><br><span class="line">    tokenStream.close(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中文分析器"><a href="#中文分析器" class="headerlink" title="中文分析器"></a>中文分析器</h3><p>1.Lucene自带中文分词器</p>
<ul>
<li>StandardAnalyzer：单字分词</li>
<li>SmartChineseAnalyzer：支持中文词语识别，但扩展性差</li>
</ul>
<p>2.IKAnalyzer </p>
<p>使用方法：<br>第一步：将jar包拷贝到工程中 IK-Analyzer-1.0-SNAPSHOT.jar<br>第二步：把配置文件和扩展词典以及停用词词典添加到classpath下<br>PS：hotword.dic 和 ext_stopword.dic 文件的格式为 UTF-8，注意是无 BOM 的 UTF-8 编码。 也就是说禁止使用 windows 记事本编辑扩展词典文件</p>
<p><img src="/images/Lucene/dic.png" alt="img"></p>
<p>3.使用自定义分析器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDocument</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">    <span class="comment">//索引库存放路径 </span></span><br><span class="line">    Directory directory = FSDirectory.open(<span class="keyword">new</span> File(<span class="string">&quot;D:\\temp\\index&quot;</span>).toPath()); </span><br><span class="line">    <span class="comment">//添加自定义分词器</span></span><br><span class="line">    IndexWriterConfig config = <span class="keyword">new</span> IndexWriterConfig(<span class="keyword">new</span> IKAnalyzer()); </span><br><span class="line">    <span class="comment">//创建一个 indexwriter 对象 </span></span><br><span class="line">    IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(directory, config); </span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="索引库的维护"><a href="#索引库的维护" class="headerlink" title="索引库的维护"></a>索引库的维护</h2><h3 id="索引库的添加"><a href="#索引库的添加" class="headerlink" title="索引库的添加"></a>索引库的添加</h3><p>1.Field域的属性<br>是否分析：是否对域的内容进行分词处理。前提是我们要对域的内容进行查询。<br>是否索引：将 Field 分析后的词或整个 Field 值进行索引，只有索引方可搜索到。<br>        比如：商品名称、商品简介分析后进行索引，订单号、身份证号不用分析但也要索引，这些将来都要作为查询条件。<br>是否存储：将 Field 值存储在文档中，存储在文档中的 Field 才可以从 Document 中获取。<br>        比如：商品名称、订单号，凡是将来要从 Document 中获取的 Field 都要存储。</p>
<p><img src="/images/Lucene/field.png" alt="img"></p>
<p>2.添加文档代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//添加索引 </span></span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDocument</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">    <span class="comment">//索引库存放路径 </span></span><br><span class="line">    Directory directory = FSDirectory.open(<span class="keyword">new</span> File(<span class="string">&quot;D:\\temp\\index&quot;</span>).toPath()); </span><br><span class="line">    IndexWriterConfig config = <span class="keyword">new</span> IndexWriterConfig(<span class="keyword">new</span> IKAnalyzer()); </span><br><span class="line">    <span class="comment">//创建一个 indexwriter 对象 </span></span><br><span class="line">    IndexWriter indexWriter = <span class="keyword">new</span> IndexWriter(directory, config);</span><br><span class="line">    <span class="comment">//创建一个 Document 对象 </span></span><br><span class="line">    Document document = <span class="keyword">new</span> Document(); </span><br><span class="line">    <span class="comment">//向 document 对象中添加域。 </span></span><br><span class="line">    <span class="comment">//不同的 document 可以有不同的域，同一个 document 可以有相同的域。 </span></span><br><span class="line">    document.add(<span class="keyword">new</span> TextField(<span class="string">&quot;filename&quot;</span>, <span class="string">&quot;新添加的文档&quot;</span>, Field.Store.YES)); </span><br><span class="line">    document.add(<span class="keyword">new</span> TextField(<span class="string">&quot;content&quot;</span>, <span class="string">&quot;新添加的文档的内容&quot;</span>, Field.Store.NO)); </span><br><span class="line">    <span class="comment">//LongPoint 创建索引 </span></span><br><span class="line">    document.add(<span class="keyword">new</span> LongPoint(<span class="string">&quot;size&quot;</span>, <span class="number">1000l</span>)); </span><br><span class="line">    <span class="comment">//StoreField 存储数据 </span></span><br><span class="line">    document.add(<span class="keyword">new</span> StoredField(<span class="string">&quot;size&quot;</span>, <span class="number">1000l</span>)); </span><br><span class="line">    <span class="comment">//不需要创建索引的就使用 StoreField 存储 </span></span><br><span class="line">    document.add(<span class="keyword">new</span> StoredField(<span class="string">&quot;path&quot;</span>, <span class="string">&quot;d:/temp/1.txt&quot;</span>)); </span><br><span class="line">    <span class="comment">//添加文档到索引库 </span></span><br><span class="line">    indexWriter.addDocument(document); </span><br><span class="line">    <span class="comment">//关闭 indexwriter </span></span><br><span class="line">    indexWriter.close(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="索引库的删除"><a href="#索引库的删除" class="headerlink" title="索引库的删除"></a>索引库的删除</h3><p>1.删除全部（慎用）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除全部索引 </span></span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteAllIndex</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">    IndexWriter indexWriter = getIndexWriter(); </span><br><span class="line">    <span class="comment">//删除全部索引 </span></span><br><span class="line">    indexWriter.deleteAll(); </span><br><span class="line">    <span class="comment">//关闭 indexwriter </span></span><br><span class="line">    indexWriter.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.指定查询条件删除</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据查询条件删除索引 </span></span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteIndexByQuery</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">    IndexWriter indexWriter = getIndexWriter(); </span><br><span class="line">    <span class="comment">//创建一个查询条件 </span></span><br><span class="line">    Query query = <span class="keyword">new</span>  <span class="function">Term <span class="title">Query</span><span class="params">(new  Term (<span class="string">&quot;filename&quot;</span>, <span class="string">&quot;apache&quot;</span>)</span>)</span>; </span><br><span class="line">    <span class="comment">//根据查询条件删除 </span></span><br><span class="line">    indexWriter.deleteDocuments(query); </span><br><span class="line">    <span class="comment">//关闭 indexwriter </span></span><br><span class="line">    indexWriter.close(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="索引库的修改"><a href="#索引库的修改" class="headerlink" title="索引库的修改"></a>索引库的修改</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改索引库(即先删除后添加) </span></span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateIndex</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">    IndexWriter indexWriter = getIndexWriter(); </span><br><span class="line">    <span class="comment">//创建一个 Document 对象 </span></span><br><span class="line">    Document document = <span class="keyword">new</span> Document(); </span><br><span class="line">    <span class="comment">//向 document 对象中添加域。 </span></span><br><span class="line">    <span class="comment">//不同的 document 可以有不同的域，同一个 document 可以有相同的域。 </span></span><br><span class="line">    document.add(<span class="keyword">new</span> TextField(<span class="string">&quot;filename&quot;</span>, <span class="string">&quot;要更新的文档&quot;</span>, Field.Store.YES)); </span><br><span class="line">    document.add(<span class="keyword">new</span> TextField(<span class="string">&quot;content&quot;</span>, <span class="string">&quot; Lucene 简介 Lucene 是一个基于 Java 的全文信息检索工具包,&quot;</span> + <span class="string">&quot;它不是一个完整的搜索应用程序,而是为你的应用程序提供索 引和搜索功能。&quot;</span>,Field.Store.YES)); </span><br><span class="line">    indexWriter.updateDocument(<span class="keyword">new</span>  Term (<span class="string">&quot;content&quot;</span>, <span class="string">&quot;java&quot;</span>), document); </span><br><span class="line">    <span class="comment">//关闭 indexWriter </span></span><br><span class="line">    indexWriter.close(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lucene索引库查询"><a href="#Lucene索引库查询" class="headerlink" title="Lucene索引库查询"></a>Lucene索引库查询</h2><p>对要搜索的信息创建 Query 查询对象，Lucene 会根据Query 查询对象生成最终的查询语法。</p>
<h3 id="Term-Query"><a href="#Term-Query" class="headerlink" title="Term Query"></a>Term Query</h3><p>该查询对象不使用分析器所以建议匹配不分词的Field域查询，比如订单号、分类ID号等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用  Term query 查询 </span></span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> test Term <span class="title">Query</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">    Directory directory = FSDirectory.open(<span class="keyword">new</span> File(<span class="string">&quot;D:\\temp\\index&quot;</span>).toPath()); </span><br><span class="line">    IndexReader indexReader = DirectoryReader.open(directory); </span><br><span class="line">    IndexSearcher indexSearcher = <span class="keyword">new</span> IndexSearcher(indexReader); </span><br><span class="line">    <span class="comment">//创建查询对象 </span></span><br><span class="line">    Query query = <span class="keyword">new</span>  <span class="function">Term <span class="title">Query</span><span class="params">(new  Term (<span class="string">&quot;content&quot;</span>, <span class="string">&quot;lucene&quot;</span>)</span>)</span>; </span><br><span class="line">    <span class="comment">//执行查询 </span></span><br><span class="line">    TopDocs topDocs = indexSearcher.search(query, <span class="number">10</span>); </span><br><span class="line">    <span class="comment">//共查询到的 document 个数 </span></span><br><span class="line">    System.out.println(<span class="string">&quot;查询结果总数量：&quot;</span> + topDocs.totalHits); </span><br><span class="line">    <span class="comment">//遍历查询结果 </span></span><br><span class="line">    <span class="keyword">for</span> (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123; </span><br><span class="line">        Document document = indexSearcher.doc(scoreDoc.doc); </span><br><span class="line">        System.out.println(document.get(<span class="string">&quot;filename&quot;</span>)); </span><br><span class="line">        <span class="comment">//System.out.println(document.get(&quot;content&quot;));</span></span><br><span class="line">        System.out.println(document.get(<span class="string">&quot;path&quot;</span>)); </span><br><span class="line">        System.out.println(document.get(<span class="string">&quot;size&quot;</span>)); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭 indexreader </span></span><br><span class="line">    indexSearcher.getIndexReader().close(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数值范围查询"><a href="#数值范围查询" class="headerlink" title="数值范围查询"></a>数值范围查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRangeQuery</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">    IndexSearcher indexSearcher = getIndexSearcher(); </span><br><span class="line">    Query query = LongPoint.newRangeQuery(<span class="string">&quot;size&quot;</span>, <span class="number">0l</span>, <span class="number">10000l</span>); </span><br><span class="line">    printResult(query, indexSearcher); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用queryparser查询"><a href="#使用queryparser查询" class="headerlink" title="使用queryparser查询"></a>使用queryparser查询</h3><p>通过 QueryParser 也可以创建 Query，QueryParser 提供一个 Parse 方法，此方法可以直接根据查询语法来查询。 建议创建索引时使用的分析器和查询索引时使用的分析器要一致。</p>
<p> 导入相关依赖jar包 lucene-queryparser-7.4.0.jar</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryParser</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">    IndexSearcher indexSearcher = getIndexSearcher(); </span><br><span class="line">    <span class="comment">//创建 queryparser 对象 </span></span><br><span class="line">    <span class="comment">//第一个参数默认搜索的域 </span></span><br><span class="line">    <span class="comment">//第二个参数就是分析器对象 </span></span><br><span class="line">    QueryParser queryParser = <span class="keyword">new</span> QueryParser(<span class="string">&quot;content&quot;</span>, <span class="keyword">new</span> IKAnalyzer()); </span><br><span class="line">    Query query = queryParser.parse(<span class="string">&quot;Lucene 是 java 开发的&quot;</span>); </span><br><span class="line">    <span class="comment">//执行查询 </span></span><br><span class="line">    printResult(query, indexSearcher); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printResult</span><span class="params">(Query query, IndexSearcher indexSearcher)</span> <span class="keyword">throws</span> Exception </span>&#123; </span><br><span class="line">    <span class="comment">//执行查询 </span></span><br><span class="line">    TopDocs topDocs = indexSearcher.search(query, <span class="number">10</span>); </span><br><span class="line">    <span class="comment">//共查询到的 document 个数 </span></span><br><span class="line">    System.out.println(<span class="string">&quot;查询结果总数量：&quot;</span> + topDocs.totalHits); </span><br><span class="line">    <span class="comment">//遍历查询结果</span></span><br><span class="line">    <span class="keyword">for</span> (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123; </span><br><span class="line">        Document document = indexSearcher.doc(scoreDoc.doc);</span><br><span class="line">        System.out.println(document.get(<span class="string">&quot;filename&quot;</span>)); </span><br><span class="line">        <span class="comment">//System.out.println(document.get(&quot;content&quot;)); </span></span><br><span class="line">        System.out.println(document.get(<span class="string">&quot;path&quot;</span>)); </span><br><span class="line">        System.out.println(document.get(<span class="string">&quot;size&quot;</span>)); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭 indexreader </span></span><br><span class="line">    indexSearcher.getIndexReader().close(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>搜索技术</category>
      </categories>
  </entry>
  <entry>
    <title>ElasticSearch(一)</title>
    <url>/2021/02/02/202122-ElasticSearch(%E4%B8%80)/</url>
    <content><![CDATA[<p>ElasticSearch 是一个开源的高扩展的分布式全文检索引擎</p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="What？"><a href="#What？" class="headerlink" title="What？"></a>What？</h3><p>简称es，es是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。es也使用Java开发并使用Lucene作为其核心来实现所有索引和搜索的功能，但是它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得简单。</p>
<h3 id="对比Solr"><a href="#对比Solr" class="headerlink" title="对比Solr"></a>对比Solr</h3><table>
<thead>
<tr>
<th>es</th>
<th>solr</th>
</tr>
</thead>
<tbody><tr>
<td>自身带有分布式协调管理功能</td>
<td>利用zookeeper进行分布式管理</td>
</tr>
<tr>
<td>仅支持json文件格式</td>
<td>支持更多格式</td>
</tr>
<tr>
<td>高级功能由第三方插件提供</td>
<td>官方提供功能较多</td>
</tr>
<tr>
<td>实时搜索较好</td>
<td>传统搜索较好</td>
</tr>
</tbody></table>
<h2 id="安装与启动"><a href="#安装与启动" class="headerlink" title="安装与启动"></a>安装与启动</h2><p>1.下载es压缩包<br>官方地址：<a href="https://www.elastic.co/products/elasticsearch">https://www.elastic.co/products/elasticsearch</a></p>
<p><img src="/images/ES/download.png" alt="es_download"></p>
<p>2.安装es服务<br>解压后即安装完毕</p>
<p><img src="/images/ES/folder.png" alt="img"></p>
<p>修改config/elasticsearch.yml，增加以下两句命令：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">http.cors.enabled:true</span></span><br><span class="line"><span class="string">http.cors.allow-origin:&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<p>PS：此步为允许elasticsearch跨越访问，如果不安装后面的elasticsearch-head是可以不修改，直接启动。</p>
<p>3.启动es服务<br>启动bin/elasticsearch.bat </p>
<p><img src="/images/ES/es_bat.png" alt="img"></p>
<p> PS：9300是tcp通讯端口，集群间和TCPClient都执行该端口，9200是http协议的RESTful接口 。</p>
<p>通过浏览器访问ElasticSearch服务器，看到如下返回的json信息，代表服务启动成功：</p>
<p><img src="/images/ES/es_json.png" alt="img"></p>
<p>4.安装es的图形化界面插件<br>以通过安装ElasticSearch的head插件，完成图形化界面的效 果，完成索引数据的查看。<br>elasticsearch-5-*以上版本安装head需要安装node和grunt。<br>1）下载head插件：<a href="https://github.com/mobz/elasticsearch-head">https://github.com/mobz/elasticsearch-head</a><br>2）将 elasticsearch-head-master 压缩包解压到任意目录，但是要和 elasticsearch 的安装目录区别开。<br>3）下载nodejs：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a> 安装完毕后可以在 cmd 控制台输入：node -v查看版本号<br>4）将grunt安装为全局命令 ，Grunt 是基于 Node.js 的项目构建工具</p>
<p>在cmd控制台中输入如下执行命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g grunt-cli</span><br></pre></td></tr></table></figure>

<p>5）进入elasticsearch-head-master目录启动head，在命令提示符下输入命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install</span><br><span class="line">grunt server</span><br></pre></td></tr></table></figure>

<p>6）打开浏览器，输入cmd中的地址 </p>
<p><img src="/images/ES/es_head.png" alt="img"></p>
<p>PS：如果不能成功连接到es服务，需要修改ElasticSearch的config目录下的配置文件：config/elasticsearch.yml，增加以下两句命令：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后重新启动ElasticSearch服务。</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Elasticsearch是面向文档(document oriented)的，这意味着它可以存储整个对象或文档(document)。然而它不仅仅是存储，还会索引(index)每个文档的内容使之可以被搜索。在Elasticsearch中，你可以对文档（而非成行成列的数据）进行索引、搜索、排序、过滤。Elasticsearch比传统关系型数据库如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; Columns</span><br><span class="line">Elasticsearch -&gt; Indices   -&gt; Types  -&gt; Documents -&gt; Fields</span><br></pre></td></tr></table></figure>

<h3 id="核心术语"><a href="#核心术语" class="headerlink" title="核心术语"></a>核心术语</h3><h4 id="索引-index"><a href="#索引-index" class="headerlink" title="索引 index"></a>索引 index</h4><p>一个索引就是一个拥有几分相似特征的文档的集合。比如说，你可以有一个客户数据的索引，另一个产品目录的索引，还有一个订单数据的索引。一个索引由一个名字来标识（必须全部是小写字母的），并且当我们要对对应于这个索引中的文档进行索引、搜索、更新和删除的时候，都要使用到这个名字。在一个集群中，可以定义任意多的索引。</p>
<h4 id="类型-type"><a href="#类型-type" class="headerlink" title="类型 type"></a>类型 type</h4><p>在一个索引中，你可以定义一种或多种类型。一个类型是你的索引的一个逻辑上的分类/分区，其语义完全由你来定。通常，会为具有一组共同字段的文档定义一个类型。比如说，我们假设你运营一个博客平台并且将你所有的数据存储到一个索引中。在这个索引中，你可以为用户数据定义一个类型，为博客数据定义另一个类型，当然，也可以为评论数据定义另一个类型。</p>
<h4 id="字段Field"><a href="#字段Field" class="headerlink" title="字段Field"></a>字段Field</h4><p>相当于是数据表的字段，对文档数据根据不同属性进行的分类标识</p>
<h4 id="映射-mapping"><a href="#映射-mapping" class="headerlink" title="映射 mapping"></a>映射 mapping</h4><p>mapping是处理数据的方式和规则方面做一些限制，如某个字段的数据类型、默认值、分析器、是否被索引等等，这些都是映射里面可以设置的，其它就是处理es里面数据的一些使用规则设置也叫做映射，按着最优规则处理数据对性能提高很大，因此才需要建立映射，并且需要思考如何建立映射才能对性能更好。</p>
<h4 id="文档-document"><a href="#文档-document" class="headerlink" title="文档 document"></a>文档 document</h4><p>一个文档是一个可被索引的基础信息单元。比如，你可以拥有某一个客户的文档，某一个产品的一个文档，当然，也可以拥有某个订单的一个文档。文档以JSON（Javascript Object Notation）格式来表示，而JSON是一个到处存在的互联网数据交互格式。</p>
<p>在一个index/type里面，你可以存储任意多的文档。注意，尽管一个文档，物理上存在于一个索引之中，但文档必须被索引/赋予一个索引的type。</p>
<h4 id="接近实时-NRT"><a href="#接近实时-NRT" class="headerlink" title="接近实时 NRT"></a>接近实时 NRT</h4><p>Elasticsearch是一个接近实时的搜索平台。这意味着，从索引一个文档直到这个文档能够被搜索到有一个轻微的延迟（通常是1秒以内）</p>
<h4 id="集群-cluster"><a href="#集群-cluster" class="headerlink" title="集群 cluster"></a>集群 cluster</h4><p>一个集群就是由一个或多个节点组织在一起，它们共同持有整个的数据，并一起提供索引和搜索功能。一个集群由一个唯一的名字标识，这个名字默认就是“elasticsearch”。这个名字是重要的，因为一个节点只能通过指定某个集群的名字，来加入这个集群</p>
<h4 id="节点-node"><a href="#节点-node" class="headerlink" title="节点 node"></a>节点 node</h4><p>一个节点是集群中的一个服务器，作为集群的一部分，它存储数据，参与集群的索引和搜索功能。和集群类似，一个节点也是由一个名字来标识的，默认情况下，这个名字是一个随机的漫威漫画角色的名字，这个名字会在启动的时候赋予节点。这个名字对于管理工作来说挺重要的，因为在这个管理过程中，你会去确定网络中的哪些服务器对应于Elasticsearch集群中的哪些节点。</p>
<p>一个节点可以通过配置集群名称的方式来加入一个指定的集群。默认情况下，每个节点都会被安排加入到一个叫做“elasticsearch”的集群中，这意味着，如果你在你的网络中启动了若干个节点，并假定它们能够相互发现彼此，它们将会自动地形成并加入到一个叫做“elasticsearch”的集群中。</p>
<p>在一个集群里，只要你想，可以拥有任意多个节点。而且，如果当前你的网络中没有运行任何Elasticsearch节点，这时启动一个节点，会默认创建并加入一个叫做“elasticsearch”的集群。</p>
<h4 id="分片和复制-shards-amp-replicas"><a href="#分片和复制-shards-amp-replicas" class="headerlink" title="分片和复制 shards&amp;replicas"></a>分片和复制 shards&amp;replicas</h4><p>一个索引可以存储超出单个结点硬件限制的大量数据。比如，一个具有10亿文档的索引占据1TB的磁盘空间，而任一节点都没有这样大的磁盘空间；或者单个节点处理搜索请求，响应太慢。为了解决这个问题，Elasticsearch提供了<strong>将索引划分成多份的能力，这些份就叫做分片</strong>。当你创建一个索引的时候，你可以指定你想要的分片的数量。每个分片本身也是一个功能完善并且独立的“索引”，这个“索引”可以被放置到集群中的任何节点上。分片很重要，主要有两方面的原因： 1）允许你水平分割/扩展你的内容容量。 2）允许你在分片（潜在地，位于多个节点上）之上进行分布式的、并行的操作，进而提高性能/吞吐量。</p>
<p>至于一个分片怎样分布，它的文档怎样聚合回搜索请求，是完全由Elasticsearch管理的，对于作为用户的你来说，这些都是透明的。</p>
<p>在一个网络/云的环境里，失败随时都可能发生，在某个分片/节点不知怎么的就处于离线状态，或者由于任何原因消失了，这种情况下，有一个故障转移机制是非常有用并且是强烈推荐的。为此目的，Elasticsearch<strong>允许你创建分片的一份或多份拷贝，这些拷贝叫做复制分片，或者直接叫复制</strong>。</p>
<p>复制之所以重要，有两个主要原因： 在分片/节点失败的情况下，提供了高可用性。因为这个原因，注意到复制分片从不与原/主要（original/primary）分片置于同一节点上是非常重要的。扩展你的搜索量/吞吐量，因为搜索可以在所有的复制上并行运行。总之，每个索引可以被分成多个分片。一个索引也可以被复制0次（意思是没有复制）或多次。一旦复制了，每个索引就有了主分片（作为复制源的原来的分片）和复制分片（主分片的拷贝）之别。分片和复制的数量可以在索引创建的时候指定。在索引创建之后，你可以在任何时候动态地改变复制的数量，但是你事后不能改变分片的数量。</p>
<p>默认情况下，Elasticsearch中的每个索引被分片5个主分片和1个复制，这意味着，如果你的集群中至少有两个节点，你的索引将会有5个主分片和另外5个复制分片（1个完全拷贝），这样的话每个索引总共就有10个分片。</p>
<h2 id="客户端操作"><a href="#客户端操作" class="headerlink" title="客户端操作"></a>客户端操作</h2><p>1.下载和安装postman工具 Postman中文版是postman这款强大网页调试工具的windows客户端，提供功能强大的Web API &amp; HTTP 请求调试。 postman官网：<a href="https://www.getpostman.com/">https://www.getpostman.com</a> 注册postman工具  </p>
<p><img src="/images/ES/pm_login.png" alt="img"></p>
<p><img src="/images/ES/pm_start.png" alt="img"></p>
<p>2.使用postman工具进行restful接口访问<br>2.1elasticsearch的接口语法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">curl -X&lt;VERB&gt; &#x27;&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;&#x27; -d &#x27;&lt;BODY&gt;&#x27;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>VERB</code></td>
<td>适当的 HTTP <em>方法</em> 或 <em>谓词</em> : <code>GET</code>、 <code>POST</code>、 <code>PUT</code>、 <code>HEAD</code> 或者 <code>DELETE</code>。</td>
</tr>
<tr>
<td><code>PROTOCOL</code></td>
<td><code>http</code> 或者 <code>https</code>（如果你在 Elasticsearch 前面有一个 <code>https</code> 代理）</td>
</tr>
<tr>
<td><code>HOST</code></td>
<td>Elasticsearch 集群中任意节点的主机名，或者用 <code>localhost</code> 代表本地机器上的节点。</td>
</tr>
<tr>
<td><code>PORT</code></td>
<td>运行 Elasticsearch HTTP 服务的端口号，默认是 <code>9200</code> 。</td>
</tr>
<tr>
<td><code>PATH</code></td>
<td>API 的终端路径（例如 <code>_count</code> 将返回集群中文档数量）。Path 可能包含多个组件，例如：<code>_cluster/stats</code> 和 <code>_nodes/stats/jvm</code> 。</td>
</tr>
<tr>
<td><code>QUERY_STRING</code></td>
<td>任意可选的查询字符串参数 (例如 <code>?pretty</code> 将格式化地输出 JSON 返回值，使其更容易阅读)</td>
</tr>
<tr>
<td><code>BODY</code></td>
<td>一个 JSON 格式的请求体 (如果请求需要的话)</td>
</tr>
</tbody></table>
<p>2.2创建index和mapping请求url：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">PUT     localhost:9200/blog1</span><br></pre></td></tr></table></figure>

<p>请求体：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;article&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;id&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;store&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">&quot;index&quot;</span>:<span class="string">&quot;not_analyzed&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;title&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;store&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">&quot;index&quot;</span>:<span class="string">&quot;analyzed&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;analyzer&quot;</span>:<span class="string">&quot;standard&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;content&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;store&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">&quot;index&quot;</span>:<span class="string">&quot;analyzed&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;analyzer&quot;</span>:<span class="string">&quot;standard&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>postman截图： </p>
<p><img src="/images/ES/pm_index.png" alt="img"></p>
<p>elasticsearch-head查看： </p>
<p><img src="/images/ES/head_index.png" alt="img"></p>
<p>2.3创建索引后设置mapping</p>
<p>我们可以在创建索引时设置mapping信息，当然也可以先创建索引然后再设置mapping。</p>
<p>在上一个步骤中不设置maping信息，直接使用put方法创建一个索引，然后设置mapping信息。</p>
<p>请求的url：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST    http://127.0.0.1:9200/blog2/hello/_mapping</span><br></pre></td></tr></table></figure>

<p>请求体：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;hello&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;id&quot;</span>:&#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;long&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;store&quot;</span>:<span class="literal">true</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;title&quot;</span>:&#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;store&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">&quot;index&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">&quot;analyzer&quot;</span>:<span class="string">&quot;standard&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;content&quot;</span>:&#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>:<span class="string">&quot;text&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;store&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">&quot;index&quot;</span>:<span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">&quot;analyzer&quot;</span>:<span class="string">&quot;standard&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/ES/head_mapping.png" alt="img"></p>
<p>2.4删除索引index 请求url：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">DELETE      localhost:9200/blog1</span><br></pre></td></tr></table></figure>

<p><img src="/images/ES/head_delete.png" alt="img"></p>
<p>2.5创建文档document 请求url：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST    localhost:9200/blog1/article/1</span><br></pre></td></tr></table></figure>

<p>请求体：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;ElasticSearch是一个基于Lucene的搜索服务器&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;content&quot;</span>:<span class="string">&quot;它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/ES/head_doc.png" alt="img"></p>
<p><img src="/images/ES/head_data.png" alt="img"></p>
<p>2.6修改文档document 请求url：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST    localhost:9200/blog1/article/1</span><br></pre></td></tr></table></figure>

<p>请求体：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;【修改】ElasticSearch是一个基于Lucene的搜索服务器&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;content&quot;</span>:<span class="string">&quot;【修改】它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/ES/head_update.png" alt="img"></p>
<p><img src="/images/ES/head_data2.png" alt="img"></p>
<p>2.7删除文档document</p>
<p>请求url：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">DELETE  localhost:9200/blog1/article/1</span><br></pre></td></tr></table></figure>

<p>postman截图： </p>
<p><img src="/images/ES/del_doc.png" alt="img"></p>
<p>2.8查询文档-根据id查询 请求url：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">GET localhost:9200/blog1/article/1</span><br></pre></td></tr></table></figure>

<p>postman截图：</p>
<p><img src="/images/ES/get_doc.png" alt="img"></p>
<p>2.9查询文档-querystring查询 请求url：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST    localhost:9200/blog1/article/_search</span><br></pre></td></tr></table></figure>

<p>请求体：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;query_string&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;default_field&quot;</span>: <span class="string">&quot;title&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;query&quot;</span>: <span class="string">&quot;搜索服务器&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/ES/pm_search.png" alt="img"></p>
<p>2.10查询文档-term查询 请求url：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST    localhost:9200/blog1/article/_search</span><br></pre></td></tr></table></figure>

<p>请求体：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;query&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;term&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;搜索&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/ES/term_query.png" alt="img"></p>
<h2 id="IK分词器集成使用"><a href="#IK分词器集成使用" class="headerlink" title="IK分词器集成使用"></a>IK分词器集成使用</h2><p>1.集成IK分词器</p>
<p>1）下载地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik/releases">https://github.com/medcl/elasticsearch-analysis-ik/releases</a> 2）解压至elasticsearch-x.x.x\plugins下，并重命名为analysis-ik 3）重启elasticsearch</p>
<p>2.IK分词器测试 IK提供了两个分词算法ik_smart和ik_max_word ik_smart最少切分 例如：在浏览器地址栏输入地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:9200/_analyze?analyzer=ik_smart&amp;pretty=true&amp;text=我是程序员</span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;我&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_CHAR&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;是&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_CHAR&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;程序员&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">5</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_WORD&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ik_max_word最细粒度划分 例如：在浏览器地址栏输入地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:9200/_analyze?analyzer=ik_max_word&amp;pretty=true&amp;text=我是程序员</span><br></pre></td></tr></table></figure>

<p>输出的结果为：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;tokens&quot;</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;我&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">0</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_CHAR&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;是&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">1</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_CHAR&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;程序员&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">5</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_WORD&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;程序&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">2</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">4</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_WORD&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">3</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">&quot;token&quot;</span> : <span class="string">&quot;员&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;start_offset&quot;</span> : <span class="number">4</span>,</span><br><span class="line">      <span class="attr">&quot;end_offset&quot;</span> : <span class="number">5</span>,</span><br><span class="line">      <span class="attr">&quot;type&quot;</span> : <span class="string">&quot;CN_CHAR&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;position&quot;</span> : <span class="number">4</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.修改索引映射mapping 重建索引删除原有blog1索引</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">DELETE      localhost:9200/blog1</span><br></pre></td></tr></table></figure>

<p>创建blog1索引，此时分词器使用ik_max_word</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">PUT     localhost:<span class="number">9200</span>/blog1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;article&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;id&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;store&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">&quot;index&quot;</span>:<span class="string">&quot;not_analyzed&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;title&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;store&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">&quot;index&quot;</span>:<span class="string">&quot;analyzed&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;analyzer&quot;</span>:<span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;content&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;store&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">&quot;index&quot;</span>:<span class="string">&quot;analyzed&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;analyzer&quot;</span>:<span class="string">&quot;ik_max_word&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建文档</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST    localhost:9200/blog1/article/1</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;ElasticSearch是一个基于Lucene的搜索服务器&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;content&quot;</span>:<span class="string">&quot;它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ElasticSearch集群"><a href="#ElasticSearch集群" class="headerlink" title="ElasticSearch集群"></a>ElasticSearch集群</h2><p>ES集群是一个 P2P类型(使用 gossip 协议)的分布式系统，除了集群状态管理以外，其他所有的请求都可以发送到集群内任意一台节点上，这个节点可以自己找到需要转发给哪些节点，并且直接跟这些节点通信。</p>
<p><strong>集群的搭建</strong></p>
<p>1.准备三台elasticsearch服务器 创建elasticsearch-cluster文件夹，在内部复制三个elasticsearch服务 2.修改每台服务器的配置 打开elasticsearch-cluster\node\config\elasticsearch.yml<br>node1节点:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#节点1的配置信息：</span></span><br><span class="line"><span class="comment">#集群名称，保证唯一</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">my-elasticsearch</span></span><br><span class="line"><span class="comment">#节点名称，必须不一样</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node-1</span></span><br><span class="line"><span class="comment">#必须为本机的ip地址</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="comment">#服务端口号，在同一机器下必须不一样</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9200</span></span><br><span class="line"><span class="comment">#集群间通信端口号，在同一机器下必须不一样</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9300</span></span><br><span class="line"><span class="comment">#设置集群自动发现机器ip集合</span></span><br><span class="line"><span class="attr">discovery.zen.ping.unicast.hosts:</span> [<span class="string">&quot;127.0.0.1:9300&quot;</span>,<span class="string">&quot;127.0.0.1:9301&quot;</span>,<span class="string">&quot;127.0.0.1:9302&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>node2节点：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#节点2的配置信息：</span></span><br><span class="line"><span class="comment">#集群名称，保证唯一</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">my-elasticsearch</span></span><br><span class="line"><span class="comment">#节点名称，必须不一样</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node-2</span></span><br><span class="line"><span class="comment">#必须为本机的ip地址</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="comment">#服务端口号，在同一机器下必须不一样</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9201</span></span><br><span class="line"><span class="comment">#集群间通信端口号，在同一机器下必须不一样</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9301</span></span><br><span class="line"><span class="comment">#设置集群自动发现机器ip集合</span></span><br><span class="line"><span class="attr">discovery.zen.ping.unicast.hosts:</span> [<span class="string">&quot;127.0.0.1:9300&quot;</span>,<span class="string">&quot;127.0.0.1:9301&quot;</span>,<span class="string">&quot;127.0.0.1:9302&quot;</span>]</span><br></pre></td></tr></table></figure>

<p>node3节点：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#节点3的配置信息：</span></span><br><span class="line"><span class="comment">#集群名称，保证唯一</span></span><br><span class="line"><span class="attr">cluster.name:</span> <span class="string">my-elasticsearch</span></span><br><span class="line"><span class="comment">#节点名称，必须不一样</span></span><br><span class="line"><span class="attr">node.name:</span> <span class="string">node-3</span></span><br><span class="line"><span class="comment">#必须为本机的ip地址</span></span><br><span class="line"><span class="attr">network.host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="comment">#服务端口号，在同一机器下必须不一样</span></span><br><span class="line"><span class="attr">http.port:</span> <span class="number">9202</span></span><br><span class="line"><span class="comment">#集群间通信端口号，在同一机器下必须不一样</span></span><br><span class="line"><span class="attr">transport.tcp.port:</span> <span class="number">9302</span></span><br><span class="line"><span class="comment">#设置集群自动发现机器ip集合</span></span><br><span class="line"><span class="attr">discovery.zen.ping.unicast.hosts:</span> [<span class="string">&quot;127.0.0.1:9300&quot;</span>,<span class="string">&quot;127.0.0.1:9301&quot;</span>,<span class="string">&quot;127.0.0.1:9302&quot;</span>]</span><br></pre></td></tr></table></figure>

<p><strong>启动各个节点服务器</strong></p>
<p>启动elasticsearch-cluster\node\bin\elasticsearch.bat</p>
<p><strong>集群测试</strong></p>
<p>添加索引和映射</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">PUT     localhost:9200/blog1</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;mappings&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;article&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;properties&quot;</span>: &#123;</span><br><span class="line">                <span class="attr">&quot;id&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;long&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;store&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">&quot;index&quot;</span>:<span class="string">&quot;not_analyzed&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;title&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;store&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">&quot;index&quot;</span>:<span class="string">&quot;analyzed&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;analyzer&quot;</span>:<span class="string">&quot;standard&quot;</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="attr">&quot;content&quot;</span>: &#123;</span><br><span class="line">                    <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;text&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;store&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="attr">&quot;index&quot;</span>:<span class="string">&quot;analyzed&quot;</span>,</span><br><span class="line">                    <span class="attr">&quot;analyzer&quot;</span>:<span class="string">&quot;standard&quot;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加文档</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">POST    localhost:9200/blog1/article/1</span><br></pre></td></tr></table></figure>

<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;id&quot;</span>:<span class="number">1</span>,</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>:<span class="string">&quot;ElasticSearch是一个基于Lucene的搜索服务器&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;content&quot;</span>:<span class="string">&quot;它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用elasticsearch-header查看集群情况</p>
<p><img src="/images/ES/head_cluster.png" alt="img"></p>
]]></content>
      <categories>
        <category>搜索技术</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Boot</title>
    <url>/2021/02/12/2021212-Spring-Boot/</url>
    <content><![CDATA[<p> Spring Boot不是对 Spring 功能上的增强，而是提供了一种快速使用 Spring 的方式，为基于 Spring 的开发提供更快的入门体验</p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="1-Spring-优缺点"><a href="#1-Spring-优缺点" class="headerlink" title="1. Spring 优缺点"></a>1. Spring 优缺点</h3><p><strong>1.1优点</strong><br> Spring 是Java企业版（Java Enterprise Edition，JEE，也称J2EE）的轻量级代替品。无需开发重量级的Enterprise JavaBean（EJB）， Spring 为企业级Java开发提供了一种相对简单的方法，通过依赖注入和面向切面编程，用简单的Java对象（Plain Old Java Object，POJO）实现了EJB的功能。<br><strong>1.2缺点</strong><br>虽然 Spring 的组件代码是轻量级的，但它的配置却是重量级的。一开始， Spring 用XML配置，而且是很多XML配置。 Spring  2.5引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式XML配置。 Spring  3.0引入了基于Java的配置，这是一种类型安全的可重构配置方式，可以代替XML。<br>除此之外，项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发进度。</p>
<h3 id="2-Spring-Boot概述"><a href="#2-Spring-Boot概述" class="headerlink" title="2. Spring Boot概述"></a>2. Spring Boot概述</h3><p><strong>1.优化</strong>  </p>
<p>Spring Boot针对上述spring缺点进行改善和优化，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度上缩短了项目周期。</p>
<p><strong>2.特点</strong></p>
<ul>
<li>为基于 Spring 的开发提供更快的入门体验</li>
<li>开箱即用，没有代码生成，也无需XML配置。同时也可以修改默认值来满足特定的需求</li>
<li>提供了一些大型项目中常见的非功能性特性，如嵌入式服务器、安全、指标，健康检测、外部配置等</li>
<li> Spring Boot不是对 Spring 功能上的增强，而是提供了一种快速使用 Spring 的方式</li>
</ul>
<p><strong>3.核心</strong></p>
<ul>
<li>起步依赖 Spring Boot 将具备某种功能的坐标全部打包在一起，共同提供某种功能。</li>
<li>自动配置 Spring Boot 自动决定 Spring 配置的使用。</li>
</ul>
<h2 id="Spring-Boot快速入门"><a href="#Spring-Boot快速入门" class="headerlink" title="Spring Boot快速入门"></a>Spring Boot快速入门</h2><h3 id="1-代码实现"><a href="#1-代码实现" class="headerlink" title="1.代码实现"></a>1.代码实现</h3><p>1.1创建Maven工程</p>
<p><img src="/images/SpringBoot/maven_project.png" alt="img"></p>
<p>1.2添加起步依赖 Spring Boot 要求，项目要继承spring-boot-starter-parent</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">arxmltifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p> Spring Boot要集成 Spring MVC进行Controller的开发，所以项目要导入web的启动依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>1.3编写引导类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima; </span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication; </span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication; </span><br><span class="line"><span class="meta">@SpringBootApplication</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySpringBootApplication</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">         SpringApplication.run(MySpringBootApplication.class); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.4编写Controller<br>在引导类 MySpringBootApplication 同级包或者子级包中创建 QuickStartController</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.controller; </span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller; </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping; </span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseBody; </span><br><span class="line"><span class="meta">@Controller</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickStartController</span> </span>&#123; </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/quick&quot;)</span> </span><br><span class="line">    <span class="meta">@ResponseBody</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">quick</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springboot 访问成功!&quot;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>1.5测试<br>执行起步类的主方法</p>
<p><img src="http://www.deepsea-blog.top/wp-content/uploads/2021/02/image-20210206094334341.png" alt="img"></p>
<p>访问：<a href="http://localhost:8080/quick">http://localhost:8080/quick</a> 浏览器返回 “ springboot 访问成功！”</p>
<h3 id="2-搭建优化"><a href="#2-搭建优化" class="headerlink" title="2.搭建优化"></a>2.搭建优化</h3><p>1.注解说明</p>
<p>@SpringBootApplication：标注 Spring Boot的启动类。<br>SpringApplication.run(MySpringBootApplication.class)代表运行 Spring Boot 的启动类，参数为 Spring  Boot启动类的字节码对象。</p>
<p>2.工程热部署<br>设置代码修改后不重启就生效，在pom.xml中添加如下配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--热部署配置--&gt; </span><br><span class="line">&lt;dependency&gt; </span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; </span><br><span class="line">    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>PS：IDEA遇到热部署失败 出现这种情况，因为IDEA默认情况下不会自动编译，需要配置</p>
<p><img src="/images/SpringBoot/set_auto.png" alt="img"></p>
<p>然后shift+ctrl+alt+/，选择Registry</p>
<p><img src="/images/SpringBoot/registry.png" alt="img"></p>
<p>4.使用idea快速创建springboot项目</p>
<p><img src="/images/SpringBoot/new_module.png" alt="img"></p>
<p><img src="/images/SpringBoot/settings.png" alt="img"></p>
<p><img src="/images/SpringBoot/dependencies.png" alt="img"></p>
<p><img src="/images/SpringBoot/module_name.png" alt="img"></p>
<p><img src="/images/SpringBoot/construct.png" alt="img"></p>
<p>通过idea创建的springboot项目的pom.xml中已经导入了我们选择的web相关坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot_quick2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>springboot_quick2<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for  Spring  Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>9<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><h3 id="1-起步依赖分析"><a href="#1-起步依赖分析" class="headerlink" title="1.起步依赖分析"></a>1.起步依赖分析</h3><p>1.1spring-boot-starter-parent 进入该依赖的源码配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">relativePath</span>&gt;</span>../../spring-boot-dependencies<span class="tag">&lt;/<span class="name">relativePath</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>进入dependencies的源码配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">activemq.version</span>&gt;</span>5.15.3<span class="tag">&lt;/<span class="name">activemq.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">antlr2.version</span>&gt;</span>2.7.7<span class="tag">&lt;/<span class="name">antlr2.version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">appengine-sdk.version</span>&gt;</span>1.9.63<span class="tag">&lt;/<span class="name">appengine-sdk.version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artemis.version</span>&gt;</span>2.4.0<span class="tag">&lt;/<span class="name">artemis.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aspectj.version</span>&gt;</span>1.8.13<span class="tag">&lt;/<span class="name">aspectj.version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">assertj.version</span>&gt;</span>3.9.1<span class="tag">&lt;/<span class="name">assertj.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">atomikos.version</span>&gt;</span>4.0.6<span class="tag">&lt;/<span class="name">atomikos.version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bitronix.version</span>&gt;</span>2.1.4<span class="tag">&lt;/<span class="name">bitronix.version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">build-helper-maven-plugin.version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">build-helper-maven-plugin.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">byte-buddy.version</span>&gt;</span>1.7.11<span class="tag">&lt;/<span class="name">byte-buddy.version</span>&gt;</span> </span><br><span class="line">    ... ... ... </span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        ... ... ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jetbrains.kotlin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>kotlin-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;kotlin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jooq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jooq-codegen-maven<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;jooq.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span> </span><br><span class="line">            ... ... ... </span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看出在依赖的底层已经配置好了一些必要的基础依赖，经过依赖的传递，在仅仅配置了parent依赖后，就可以实现基础依赖的导入。</p>
<p>1.2spring-boot-starter-web 同理，进入源码配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 </span></span></span><br><span class="line"><span class="string"><span class="tag">                             http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> </span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starters<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span> Spring  Boot Web Starter<span class="tag">&lt;/<span class="name">name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate.validator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.9.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-自动配置"><a href="#2-自动配置" class="headerlink" title="2.自动配置"></a>2.自动配置</h3><p>按住Ctrl点击查看启动类MySpringBootApplication上的注解@SpringBootApplication</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySpringBootApplication</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">         SpringApplication.run(MySpringBootApplication.class);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解@SpringBootApplication的源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span> </span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span> </span><br><span class="line"><span class="meta">@Documented</span> </span><br><span class="line"><span class="meta">@Inherited</span> </span><br><span class="line"><span class="meta">@SpringBootConfiguration</span> </span><br><span class="line"><span class="meta">@EnableAutoConfiguration</span> </span><br><span class="line"><span class="meta">@ComponentScan(excludeFilters = &#123; </span></span><br><span class="line"><span class="meta">    @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), </span></span><br><span class="line"><span class="meta">    @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SpringBootApplication &#123; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Exclude specific auto-configuration classes such that they will never be applied.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the classes to exclude </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="meta">@AliasFor(annotation = EnableAutoConfiguration.class)</span> Class&lt;?&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    ... ... ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@SpringBootConfiguration：等同与@Configuration，既标注该类是 Spring 的一个配置类 @EnableAutoConfiguration： SpringBoot 自动配置功能开启</p>
<p>按住Ctrl点击查看注解@EnableAutoConfiguration</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.TYPE)</span> </span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Documented</span> </span><br><span class="line"><span class="meta">@Inherited</span> </span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span> </span><br><span class="line"><span class="meta">@Import(AutoConfigurationImportSelector.class)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123; </span><br><span class="line">    ... ... ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按住Ctrl点击查看AutoConfigurationImportSelector源码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123; </span><br><span class="line">    ... ... ... </span><br><span class="line">        List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); </span><br><span class="line">    configurations = removeDuplicates(configurations); </span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); </span><br><span class="line">    checkExcludedClasses(configurations, exclusions); </span><br><span class="line">    configurations.removeAll(exclusions); configurations = filter(configurations, autoConfigurationMetadata); </span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions); </span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(configurations); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123; </span><br><span class="line">    List&lt;String&gt; configurations =  Spring FactoriesLoader.loadFactoryNames( <span class="function">get Spring <span class="title">FactoriesLoaderFactoryClass</span><span class="params">()</span>, <span class="title">getBeanClassLoader</span><span class="params">()</span>)</span>; </span><br><span class="line">    <span class="keyword">return</span> configurations; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中， Spring FactoriesLoader.loadFactoryNames 方法的作用就是从META-INF/spring.factories文件中读取指定类对应的类名称列表</p>
<p><img src="/images/SpringBoot/auto_config.png" alt="img"></p>
<p>spring.factories 文件中有关自动配置的配置信息如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">... ... ... </span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConf iguration,\ </span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration ,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfigu ration,\ </span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\ </span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\ </span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\ </span><br><span class="line">... ... ...</span><br></pre></td></tr></table></figure>

<p>上面配置文件存在大量的以Configuration为结尾的类名称，这些类就是存有自动配置信息的类，而 Spring Application在获取这些类名后再加载</p>
<p>我们以ServletWebServerFactoryAutoConfiguration为例来分析源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span> </span><br><span class="line"><span class="meta">@ConditionalOnClass(ServletRequest.class)</span> </span><br><span class="line"><span class="meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span> </span><br><span class="line"><span class="meta">@EnableConfigurationProperties(ServerProperties.class)</span> </span><br><span class="line"><span class="meta">@Import(&#123; ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class, </span></span><br><span class="line"><span class="meta">         ServletWebServerFactoryConfiguration.EmbeddedTomcat.class, </span></span><br><span class="line"><span class="meta">         ServletWebServerFactoryConfiguration.EmbeddedJetty.class, </span></span><br><span class="line"><span class="meta">         ServletWebServerFactoryConfiguration.EmbeddedUndertow.class &#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletWebServerFactoryAutoConfiguration</span> </span>&#123; </span><br><span class="line">    ... ... ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，@EnableConfigurationProperties(ServerProperties.class) 代表加载ServerProperties服务器配置属性类</p>
<p>进入ServerProperties.class源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;server&quot;, ignoreUnknownFields = true)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerProperties</span> </span>&#123; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Server HTTP port. </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="keyword">private</span> Integer port; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Network address to which the server should bind. </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    <span class="keyword">private</span> InetAddress address; </span><br><span class="line">    ... ... ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中， prefix = “server” 表示 Spring Boot配置文件中的前缀， Spring Boot会将配置文件中以server开始的属性映射到该类的字段中。映射关系如下：</p>
<p><img src="/images/SpringBoot/map.png" alt="img"></p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="1-类型"><a href="#1-类型" class="headerlink" title="1.类型"></a>1.类型</h3><p>1.1类型和作用</p>
<p>想要自定义配置文件替换默认配置，可以使用 application.properties 或者 application.yml 进行配置。  springboot 默认会从 resources 目录下加载相应配置文件</p>
<p>1.2application.yml配置文件</p>
<ul>
<li><p>**普通数据 **<br>语法：key: value<br>eg：name: test<br>注意：value之前有一个空格</p>
</li>
<li><p>**对象、Map数据 **<br>语法： key: key1: value1 key2: value2 </p>
<pre><code>      或者： key:&#123;key1: value1,key2: value2&#125; 
</code></pre>
<p>eg:<br>person:<br>   name: test<br>   age: 10<br>   addr: beijing<br>#或者<br>person: {name: test,age: 10,addr: beijing}<br>注意：key1前面的空格个数不限定，在yml语法中，相同缩进代表同一个级别</p>
</li>
<li><p>**数组（List、Set）数据 **<br>语法：<br>key:</p>
<p>  value1</p>
<p>  value2<br>或者： key:[value1,value2]<br>eg:</p>
<p>city:</p>
<p>- beijing</p>
<p>- tianjin</p>
<p>- shanghai</p>
<p>- chongqing</p>
<p>#或者</p>
<p>city: [beijing,tianjin,shanghai,chongqing]</p>
<p>#集合中的元素是对象形式</p>
<p>student:</p>
<p>- name: zhangsan</p>
<p>  age: 18</p>
<p>  score: 100</p>
<p>- name: lisi</p>
<p>  age: 28</p>
<p>  score: 88</p>
<p>- name: wangwu</p>
<p>  age: 38</p>
<p>  score: 90<br>注意：value1与之间的 - 之间存在一个空格</p>
</li>
</ul>
<p>1.3配置信息的查询<br>配置信息key字段文档： <a href="https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#common-application-properties">https://docs.spring.io/spring-boot/docs/2.0.1.RELEASE/reference/htmlsingle/#common-application-properties</a></p>
<h3 id="2-配置文件与配置类的属性映射方式"><a href="#2-配置文件与配置类的属性映射方式" class="headerlink" title="2.配置文件与配置类的属性映射方式"></a>2.配置文件与配置类的属性映射方式</h3><p>1.使用注解@Value映射 将配置文件中的值映射到一个spring管理的bean的字段上 例如： application.properties：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">person.name</span>: <span class="string">zhangsan </span></span><br><span class="line"><span class="meta">person.age</span>: <span class="string">18</span></span><br></pre></td></tr></table></figure>

<p>application.yml：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">person:</span> </span><br><span class="line">    <span class="attr">name:</span> <span class="string">zhangsan</span> </span><br><span class="line">    <span class="attr">age:</span> <span class="number">18</span></span><br></pre></td></tr></table></figure>

<p>实体Bean：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickStartController</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;person.name&#125;&quot;)</span> </span><br><span class="line">    <span class="keyword">private</span> String name; </span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;person.age&#125;&quot;)</span> </span><br><span class="line">    <span class="keyword">private</span> Integer age; </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/quick&quot;)</span> </span><br><span class="line">    <span class="meta">@ResponseBody</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">quick</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;springboot 访问成功! name=&quot;</span>+name+<span class="string">&quot;,age=&quot;</span>+age; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.使用注解@ConfigurationProperties映射 通过注解@ConfigurationProperties(prefix=”配置文件中的key的前缀”)可以将配置文件中的配置自动与实体进行映射</p>
<p><img src="/images/SpringBoot/yml_map.png" alt="img"></p>
<h2 id="整合其他技术"><a href="#整合其他技术" class="headerlink" title="整合其他技术"></a>整合其他技术</h2><h3 id="整合Mybatis"><a href="#整合Mybatis" class="headerlink" title="整合Mybatis"></a>整合Mybatis</h3><p>1.添加起步依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis起步依赖--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.添加数据库驱动</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MySQL连接驱动 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.添加数据库连接信息 在application.properties中添加</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#DB Configuration: </span></span><br><span class="line"><span class="meta">spring.datasource.driverClassName</span>=<span class="string">com.mysql.jdbc.Driver </span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/test? useUnicode=true&amp;characterEncoding=utf8 </span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root </span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure>

<p>4.创建user表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ---------------------------- </span></span><br><span class="line"><span class="comment">-- Table structure for `user` -- </span></span><br><span class="line"><span class="comment">---------------------------- </span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `<span class="keyword">user</span>`; </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` ( </span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT, </span><br><span class="line">    `username` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">    `password` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">    `name` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>, </span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`) </span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">10</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8; </span><br><span class="line"><span class="comment">-- ---------------------------- </span></span><br><span class="line"><span class="comment">-- Records of user </span></span><br><span class="line"><span class="comment">-- ---------------------------- </span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;张三&#x27;</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` <span class="keyword">VALUES</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;123&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>5.创建实体Bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 主键 </span></span><br><span class="line">    <span class="keyword">private</span> Long id; </span><br><span class="line">    <span class="comment">// 用户名 </span></span><br><span class="line">    <span class="keyword">private</span> String username; </span><br><span class="line">    <span class="comment">// 密码 </span></span><br><span class="line">    <span class="keyword">private</span> String password; </span><br><span class="line">    <span class="comment">// 姓名 </span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">//此处省略getter和setter方法 .. .. </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.编写Mapper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">queryUserList</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：@Mapper标记该类是一个mybatis的mapper接口，可以被spring boot自动扫描到spring上下文中</p>
<p>7.配置Mapper映射文件 在src\main\resources\mapper路径下加入UserMapper.xml配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span> </span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.mapper.UserMapper&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;queryUserList&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span> select * from user <span class="tag">&lt;/<span class="name">select</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>8.添加Mybatis信息 在application.properties中添加</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#spring集成Mybatis环境 </span></span><br><span class="line"><span class="comment">#pojo别名扫描包 </span></span><br><span class="line"><span class="meta">mybatis.type-aliases-package</span>=<span class="string">com.itheima.domain </span></span><br><span class="line"><span class="comment">#加载Mybatis映射文件 </span></span><br><span class="line"><span class="meta">mybatis.mapper-locations</span>=<span class="string">classpath:mapper/*Mapper.xml</span></span><br></pre></td></tr></table></figure>

<p>9.编写Controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperController</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper; </span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/queryUser&quot;)</span> </span><br><span class="line">    <span class="meta">@ResponseBody</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">queryUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;User&gt; users = userMapper.queryUserList(); </span><br><span class="line">        <span class="keyword">return</span> users;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>10.测试</p>
<p><img src="/images/SpringBoot/test.png" alt="img"></p>
<h3 id="整合Junit"><a href="#整合Junit" class="headerlink" title="整合Junit"></a>整合Junit</h3><p>1.添加Junit依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--测试的起步依赖--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.编写测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.test; </span><br><span class="line"><span class="keyword">import</span> com.itheima.MySpringBootApplication; </span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.User; </span><br><span class="line"><span class="keyword">import</span> com.itheima.mapper.UserMapper; </span><br><span class="line"><span class="keyword">import</span> org.junit.Test; </span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith; </span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired; </span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context. Spring BootTest; </span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4. Spring Runner; </span><br><span class="line"><span class="keyword">import</span> java.util.List; </span><br><span class="line"><span class="meta">@RunWith( Spring Runner.class)</span> </span><br><span class="line">@ <span class="function">Spring <span class="title">BootTest</span><span class="params">(classes = MySpringBootApplication.class)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class MapperTest </span>&#123; </span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper; </span><br><span class="line">    <span class="meta">@Test</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        List&lt;User&gt; users = userMapper.queryUserList(); </span><br><span class="line">        System.out.println(users); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，  Spring Runner继承自 Spring JUnit4ClassRunner，使用哪一个 Spring 提供的测试测试引擎都可以 @ Spring BootTest的属性指定的是引导类的字节码对象</p>
<p>3.控制台打印信息</p>
<p><img src="/images/SpringBoot/console.png" alt="img"></p>
<h3 id="整合-Spring-DataJPA"><a href="#整合-Spring-DataJPA" class="headerlink" title="整合 Spring DataJPA"></a>整合 Spring DataJPA</h3><p>1.添加SDJPA的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- springBoot JPA的起步依赖 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.添加数据库驱动依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MySQL连接驱动 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.配置数据库和jpa的相关属性 在application.properties中</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#DB Configuration: </span></span><br><span class="line"><span class="meta">spring.datasource.driverClassName</span>=<span class="string">com.mysql.jdbc.Driver </span></span><br><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=utf8 </span></span><br><span class="line"><span class="meta">spring.datasource.username</span>=<span class="string">root </span></span><br><span class="line"><span class="meta">spring.datasource.password</span>=<span class="string">root </span></span><br><span class="line"><span class="comment">#JPA Configuration: </span></span><br><span class="line"><span class="meta">spring.jpa.database</span>=<span class="string">MySQL </span></span><br><span class="line"><span class="meta">spring.jpa.show-sql</span>=<span class="string">true </span></span><br><span class="line"><span class="meta">spring.jpa.generate-ddl</span>=<span class="string">true </span></span><br><span class="line"><span class="meta">spring.jpa.hibernate.ddl-auto</span>=<span class="string">update </span></span><br><span class="line"><span class="meta">spring.jpa.hibernate.naming_strategy</span>=<span class="string">org.hibernate.cfg.ImprovedNamingStrategy</span></span><br></pre></td></tr></table></figure>

<p>4.创建实体类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 主键 </span></span><br><span class="line">    <span class="meta">@Id</span> </span><br><span class="line">    <span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span></span><br><span class="line">    <span class="keyword">private</span> Long id; </span><br><span class="line">    <span class="comment">// 用户名 </span></span><br><span class="line">    <span class="keyword">private</span> String username; </span><br><span class="line">    <span class="comment">// 密码</span></span><br><span class="line">    <span class="keyword">private</span> String password; </span><br><span class="line">    <span class="comment">// 姓名 </span></span><br><span class="line">    <span class="keyword">private</span> String name; </span><br><span class="line">    <span class="comment">//此处省略setter和getter方法... ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.编写UserRepository</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>,<span class="title">Long</span>&gt;</span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findAll</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.编写测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith( Spring Runner.class)</span> </span><br><span class="line">@ <span class="function">Spring <span class="title">BootTest</span><span class="params">(classes=MySpringBootApplication.class)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class JpaTest </span>&#123; </span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; </span><br><span class="line">    <span class="meta">@Test</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123; </span><br><span class="line">        List&lt;User&gt; users = userRepository.findAll(); </span><br><span class="line">        System.out.println(users); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>7.控制台打印信息</p>
<p><img src="/images/SpringBoot/console2.png" alt="img"></p>
<p>注意:如果是jdk9,执行报错：</p>
<p><img src="/images/SpringBoot/jaxbException.png" alt="img"></p>
<p>因为jdk9缺少相关的jar包</p>
<p>导入jar包即可：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--jdk9需要导入如下坐标--&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.xml.bind<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxb-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="整合Redis"><a href="#整合Redis" class="headerlink" title="整合Redis"></a>整合Redis</h3><p>1.添加redis的依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置使用redis启动器 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.配置redis的连接信息</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Redis </span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1 </span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br></pre></td></tr></table></figure>

<p>3.注入RedisTemplate测试redis操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith( Spring Runner.class)</span> </span><br><span class="line">@ <span class="function">Spring <span class="title">BootTest</span><span class="params">(classes =  Spring bootJpaApplication.class)</span> </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class RedisTest </span>&#123; </span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; </span><br><span class="line">    <span class="meta">@Autowired</span> </span><br><span class="line">    <span class="keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate; </span><br><span class="line">    <span class="meta">@Test</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> JsonProcessingException </span>&#123; </span><br><span class="line">        <span class="comment">//从redis缓存中获得指定的数据 </span></span><br><span class="line"></span><br><span class="line">        String userListData = redisTemplate.boundValueOps(<span class="string">&quot;user.findAll&quot;</span>).get(); </span><br><span class="line">        <span class="comment">//如果redis中没有数据的话 </span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>==userListData)&#123; </span><br><span class="line">            <span class="comment">//查询数据库获得数据 </span></span><br><span class="line">            List&lt;User&gt; all = userRepository.findAll(); </span><br><span class="line">            <span class="comment">//转换成json格式字符串 </span></span><br><span class="line">            ObjectMapper om = <span class="keyword">new</span> ObjectMapper(); </span><br><span class="line">            userListData = om.writeValueAsString(all); </span><br><span class="line">            <span class="comment">//将数据存储到redis中，下次在查询直接从redis中获得数据，不用在查询数据库 </span></span><br><span class="line">            redisTemplate.boundValueOps(<span class="string">&quot;user.findAll&quot;</span>).set(userListData); </span><br><span class="line">            System.out.println(<span class="string">&quot;===============从数据库获得数据===============&quot;</span>); </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;===============从redis缓存中获得数据===============&quot;</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(userListData); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
  </entry>
  <entry>
    <title>SpringData JPA(一)</title>
    <url>/2021/02/05/202125-SpringData-JPA(%E4%B8%80)/</url>
    <content><![CDATA[<p>JPA 即 Java Persistence API，Java持久化API</p>
<span id="more"></span>

<h2 id="ORM-概述"><a href="#ORM-概述" class="headerlink" title="ORM 概述"></a>ORM 概述</h2><p> ORM 表示对象关系映射，在面向对象的软件开发中，通过 ORM 就可以把对象映射到关系型数据库中。只要有一套程序能够做到建立对象与数据库的关联，操作对象就可以直接操作数据库数据，就可以说这套程序实现了 ORM 。</p>
<p>总结： ORM 就是建立实体类和数据库表之间的关系，从而达到操作实体类就相当于操作数据库表的目的。</p>
<p>1.为什么使用 ORM  编写访问数据库的代码时，从数据库保存、修改、删除数据，有大量重复的代码，而使用 ORM 会大大地减少重复性代码。</p>
<p>2.常见 ORM 框架 Mybatis(ibatis); Hibernate; JPA</p>
<h2 id="hibernate与JPA的概述"><a href="#hibernate与JPA的概述" class="headerlink" title="hibernate与JPA的概述"></a>hibernate与JPA的概述</h2><p>**1.hibernate概述 **<br>hibernate 是一个开放源代码的对象关系映射框架，它对 JDBC 进行了非常轻量级的对象封装，它将 POJO 与数据库表建立映射关系，可以自动生成 SQL 语句，自动执行。</p>
<p><strong>2.JPA概述</strong><br>Java Persistence API，Java持久化API，内部是由一系列的接口和抽象类构成。 JPA通过JDK5.0注解描述<strong>对象–关系表</strong>的映射关系，并将运行期的实体对象持久化到数据库中。</p>
<p><strong>3.JPA的优势</strong></p>
<ul>
<li>标准化</li>
<li>容器级特性的支持</li>
<li>简单方便</li>
<li>查询能力</li>
<li>高级特性</li>
</ul>
<p><strong>4.JPA与hibernate的关系</strong></p>
<p><img src="http://www.deepsea-blog.top/wp-content/uploads/2021/02/image-20210204150706752.png" alt="img"></p>
<h2 id="JPA的入门案例"><a href="#JPA的入门案例" class="headerlink" title="JPA的入门案例"></a>JPA的入门案例</h2><p>1.导入hibernate的jar包 官方：<a href="http://sourceforge.net/projects/hibernate/files/hibernate-orm/">http://sourceforge.net/projects/hibernate/files/hibernate-orm/</a></p>
<ul>
<li>使用maven导入依赖</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">project.hibernate.version</span>&gt;</span>5.0.7.Final<span class="tag">&lt;/<span class="name">project.hibernate.version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- junit --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- hibernate对jpa的支持包 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-entitymanager<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.hibernate.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- c3p0 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;project.hibernate.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- log日志 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.17<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- Mysql and MariaDB --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.创建客户的数据库表和实体类</p>
<ul>
<li>数据库表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*创建客户表*/</span> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cst_customer ( </span><br><span class="line">    cust_id <span class="type">bigint</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;客户编号(主键)&#x27;</span>, </span><br><span class="line">    cust_name <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;客户名称(公司名称)&#x27;</span>, </span><br><span class="line">    cust_source <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;客户信息来源&#x27;</span>, </span><br><span class="line">    cust_industry <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;客户所属行业&#x27;</span>, </span><br><span class="line">    cust_level <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;客户级别&#x27;</span>, </span><br><span class="line">    cust_address <span class="type">varchar</span>(<span class="number">128</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;客户联系地址&#x27;</span>, </span><br><span class="line">    cust_phone <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;客户联系电话&#x27;</span>, </span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`cust_id`) </span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">1</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure>

<ul>
<li>实体类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> Long custId;</span><br><span class="line">    <span class="keyword">private</span> String custName; </span><br><span class="line">    <span class="keyword">private</span> String custSource;</span><br><span class="line">    <span class="keyword">private</span> String custIndustry;</span><br><span class="line">    <span class="keyword">private</span> String custLevel; </span><br><span class="line">    <span class="keyword">private</span> String custAddress; </span><br><span class="line">    <span class="keyword">private</span> String custPhone;</span><br><span class="line">    getter/setter</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.编写实体类和数据库表的映射配置</p>
<ul>
<li>使用JPA注解配置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* * 所有的注解都是使用 JPA 的规范提供的注解， </span></span><br><span class="line"><span class="comment">* * 所以在导入注解包的时候，一定要导入 javax.persistence 下的 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">@Entity</span> <span class="comment">//声明实体类 </span></span><br><span class="line"><span class="meta">@Table(name=&quot;cst_customer&quot;)</span> </span><br><span class="line"><span class="comment">//建立实体类和表的映射关系 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Id</span><span class="comment">//声明当前私有属性为主键 </span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy=GenerationType.IDENTITY)</span> <span class="comment">//配置主键的生成策略 </span></span><br><span class="line">    <span class="meta">@Column(name=&quot;cust_id&quot;)</span> <span class="comment">//指定和表中 cust_id 字段的映射关系 </span></span><br><span class="line">    <span class="keyword">private</span> Long custId; </span><br><span class="line">    <span class="meta">@Column(name=&quot;cust_name&quot;)</span> <span class="comment">//指定和表中 cust_name 字段的映射关系 </span></span><br><span class="line">    <span class="keyword">private</span> String custName; </span><br><span class="line">    <span class="meta">@Column(name=&quot;cust_source&quot;)</span><span class="comment">//指定和表中 cust_source 字段的映射关系 </span></span><br><span class="line">    <span class="keyword">private</span> String custSource; </span><br><span class="line">    <span class="meta">@Column(name=&quot;cust_industry&quot;)</span><span class="comment">//指定和表中 cust_industry 字段的映射关系 </span></span><br><span class="line">    <span class="keyword">private</span> String custIndustry; </span><br><span class="line">    <span class="meta">@Column(name=&quot;cust_level&quot;)</span><span class="comment">//指定和表中 cust_level 字段的映射关系 </span></span><br><span class="line">    <span class="keyword">private</span> String custLevel; </span><br><span class="line">    <span class="meta">@Column(name=&quot;cust_address&quot;)</span><span class="comment">//指定和表中 cust_address 字段的映射关系 </span></span><br><span class="line">    <span class="keyword">private</span> String custAddress; </span><br><span class="line">    <span class="meta">@Column(name=&quot;cust_phone&quot;)</span><span class="comment">//指定和表中 cust_phone 字段的映射关系 </span></span><br><span class="line">    <span class="keyword">private</span> String custPhone;</span><br><span class="line">    getter/setter</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注解说明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Entity </span><br><span class="line">    作用：指定当前类是实体类。 </span><br><span class="line">@Table </span><br><span class="line">    作用：指定实体类和表之间的对应关系。 </span><br><span class="line">    属性：name：指定数据库表的名称 </span><br><span class="line">@Id </span><br><span class="line">    作用：指定当前字段是主键。 </span><br><span class="line">@GeneratedValue </span><br><span class="line">    作用：指定主键的生成方式。。 </span><br><span class="line">    属性：strategy ：指定主键生成策略。 </span><br><span class="line">@Column </span><br><span class="line">    作用：指定实体类属性和数据库表之间的对应关系 </span><br><span class="line">    属性：</span><br><span class="line">        name：指定数据库表的列名称。 </span><br><span class="line">        unique：是否唯一 </span><br><span class="line">        nullable：是否可以为空 </span><br><span class="line">        inserttable：是否可以插入 </span><br><span class="line">        updateable：是否可以更新 </span><br><span class="line">        columnDefinition: 定义建表时创建此列的 DDL </span><br><span class="line">        secondaryTable: 从表名。如果此列不建在主表上（默认建在主表），该属性定义该列所在从表的名字搭建开发环境[重点]</span><br></pre></td></tr></table></figure>

<p>4.配置JPA的核心配置文件 创建文件：src/META-INF/persistence.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">persistence</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/persistence&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd&quot;</span> <span class="attr">version</span>=<span class="string">&quot;2.0&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置持久化单元 </span></span><br><span class="line"><span class="comment">    name：持久化单元名称 </span></span><br><span class="line"><span class="comment">    transaction-type：事务类型 </span></span><br><span class="line"><span class="comment">    RESOURCE_LOCAL：本地事务管理 </span></span><br><span class="line"><span class="comment">    JTA：分布式事务管理 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">persistence-unit</span> <span class="attr">name</span>=<span class="string">&quot;myJpa&quot;</span> <span class="attr">transaction-type</span>=<span class="string">&quot;RESOURCE_LOCAL&quot;</span>&gt;</span> </span><br><span class="line">        <span class="comment">&lt;!--配置 JPA 规范的服务提供商 --&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span>&gt;</span>org.hibernate.jpa.HibernatePersistenceProvider<span class="tag">&lt;/<span class="name">provider</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">properties</span>&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- 数据库驱动 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javax.persistence.jdbc.driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- 数据库地址 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javax.persistence.jdbc.url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/ssh&quot;</span> /&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!-- 数据库用户名 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javax.persistence.jdbc.user&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 数据库密码 --&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;javax.persistence.jdbc.password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;111111&quot;</span> /&gt;</span> </span><br><span class="line">            <span class="comment">&lt;!--jpa 提供者的可选配置：我们的 JPA 规范的提供者为hibernate，所以 jpa 的核心配置中兼容 hibernate 的配置 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.show_sql&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.format_sql&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span> /&gt;</span> </span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;hibernate.hbm2ddl.auto&quot;</span> <span class="attr">value</span>=<span class="string">&quot;create&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">persistence-unit</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persistence</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>5.实现保存操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建实体管理类工厂，借助 Persistence 的静态方法获取 </span></span><br><span class="line"><span class="comment">    * 其中传递的参数为持久化单元名称，需要 jpa 配置文件中指定</span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    EntityManagerFactory factory = Persistence.createEntityManagerFactory(<span class="string">&quot;myJpa&quot;</span>); </span><br><span class="line">    <span class="comment">//创建实体管理类</span></span><br><span class="line">    EntityManager em = factory.createEntityManager(); </span><br><span class="line">    <span class="comment">//获取事务对象</span></span><br><span class="line">    EntityTransaction tx = em.getTransaction(); </span><br><span class="line">    <span class="comment">//开启事务 </span></span><br><span class="line">    tx.begin(); </span><br><span class="line">    Customer c = <span class="keyword">new</span> Customer(); </span><br><span class="line">    c.setCustName(<span class="string">&quot;传智播客&quot;</span>); </span><br><span class="line">    <span class="comment">//保存操作 </span></span><br><span class="line">    em.persist(c); </span><br><span class="line">    <span class="comment">//提交事务 </span></span><br><span class="line">    tx.commit(); </span><br><span class="line">    <span class="comment">//释放资源 </span></span><br><span class="line">    em.close(); </span><br><span class="line">    factory.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JPA中的主键生成策略"><a href="#JPA中的主键生成策略" class="headerlink" title="JPA中的主键生成策略"></a>JPA中的主键生成策略</h2><p>JPA提供了四种模式生成主键</p>
<ul>
<li>IDENTITY：主键由数据库自动生成（主要是自动增长型） 用法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Id</span> </span><br><span class="line"><span class="meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span> </span><br><span class="line"><span class="keyword">private</span> Long custId;</span><br></pre></td></tr></table></figure>

<ul>
<li>SEQUENCE：根据底层数据库的序列来生成主键，条件是数据库支持序列 用法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Id</span> </span><br><span class="line"><span class="meta">@GeneratedValue(strategy = GenerationType.SEQUENCE,generator=&quot;payablemoney_seq&quot;)</span> </span><br><span class="line"><span class="meta">@SequenceGenerator(name=&quot;payablemoney_seq&quot;, sequenceName=&quot;seq_payment&quot;)</span> </span><br><span class="line"><span class="keyword">private</span> Long custId;</span><br><span class="line"><span class="comment">//@SequenceGenerator 源码中的定义 </span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, METHOD, FIELD&#125;)</span> </span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SequenceGenerator &#123; </span><br><span class="line">    <span class="comment">//表示该表主键生成策略的名称，它被引用在@GeneratedValue 中设置的“generator”值中 </span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">//属性表示生成策略用到的数据库序列名称。 </span></span><br><span class="line">    <span class="function">String <span class="title">sequenceName</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>; </span><br><span class="line">    <span class="comment">//表示主键初识值，默认为 0 </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">initialValue</span><span class="params">()</span> <span class="keyword">default</span> 0</span>; </span><br><span class="line">    <span class="comment">//表示每次主键值增加的大小，例如设置 1，则表示每次插入新记录后自动加 1，默认为 50 </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">allocationSize</span><span class="params">()</span> <span class="keyword">default</span> 50</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>AUTO：主键由程序控制 用法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Id</span> </span><br><span class="line"><span class="meta">@GeneratedValue(strategy = GenerationType.AUTO)</span> </span><br><span class="line"><span class="keyword">private</span> Long custId;</span><br></pre></td></tr></table></figure>

<ul>
<li>TABLE：使用一个特定的数据库表格来保存主键 用法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Id</span> </span><br><span class="line"><span class="meta">@GeneratedValue(strategy = GenerationType.TABLE, generator=&quot;payablemoney_gen&quot;)</span> </span><br><span class="line"><span class="meta">@TableGenerator(name = &quot;pk_gen&quot;, </span></span><br><span class="line"><span class="meta">                table=&quot;tb_generator&quot;, </span></span><br><span class="line"><span class="meta">                pkColumnName=&quot;gen_name&quot;, </span></span><br><span class="line"><span class="meta">                valueColumnName=&quot;gen_value&quot;, </span></span><br><span class="line"><span class="meta">                pkColumnValue=&quot;PAYABLEMOENY_PK&quot;, </span></span><br><span class="line"><span class="meta">                allocationSize=1 </span></span><br><span class="line"><span class="meta">               )</span></span><br><span class="line"><span class="keyword">private</span> Long custId; </span><br><span class="line"><span class="comment">//@TableGenerator 的定义： </span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, METHOD, FIELD&#125;)</span> </span><br><span class="line"><span class="meta">@Retention(RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> TableGenerator &#123; </span><br><span class="line">    <span class="comment">//表示该表主键生成策略的名称，它被引用在@GeneratedValue 中设置的“generator”值中</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span></span>; </span><br><span class="line">    <span class="comment">//表示表生成策略所持久化的表名，例如，这里表使用的是数据库中的“tb_generator”。 </span></span><br><span class="line">    <span class="function">String <span class="title">table</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">    <span class="comment">//catalog 和 schema 具体指定表所在的目录名或是数据库名 </span></span><br><span class="line">    <span class="function">String <span class="title">catalog</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>; </span><br><span class="line">    <span class="function">String <span class="title">schema</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>; </span><br><span class="line">    <span class="comment">//属性的值表示在持久化表中，该主键生成策略所对应键值的名称。例如在“tb_generator”中将 “gen_name”作为主键的键值 </span></span><br><span class="line">    <span class="function">String <span class="title">pkColumnName</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>; </span><br><span class="line">    <span class="comment">//属性的值表示在持久化表中，该主键当前所生成的值，它的值将会随着每次创建累加。例如，在 “tb_generator”中将“gen_value”作为主键的值 </span></span><br><span class="line">    <span class="function">String <span class="title">valueColumnName</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>; </span><br><span class="line">    <span class="comment">//属性的值表示在持久化表中，该生成策略所对应的主键。例如在“tb_generator”表中，将“gen_name” 的值为“CUSTOMER_PK”。 </span></span><br><span class="line">    <span class="function">String <span class="title">pkColumnValue</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>; </span><br><span class="line">    <span class="comment">//表示主键初识值，默认为 0。 </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">initialValue</span><span class="params">()</span> <span class="keyword">default</span> 0</span>; </span><br><span class="line">    <span class="comment">//表示每次主键值增加的大小，例如设置成 1，则表示每次创建新记录后自动加 1，默认为 50。 </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">allocationSize</span><span class="params">()</span> <span class="keyword">default</span> 50</span>; </span><br><span class="line">    UniqueConstraint[] uniqueConstraints() <span class="keyword">default</span> &#123;&#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span>这里应用表 tb_generator，定义为 ： </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tb_generator ( </span><br><span class="line">    id NUMBER <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">    gen_name VARCHAR2(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">    gen_value NUMBER <span class="keyword">NOT</span> <span class="keyword">NULL</span>, </span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY(id)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="JPA的API介绍"><a href="#JPA的API介绍" class="headerlink" title="JPA的API介绍"></a>JPA的API介绍</h2><p>1.Persistence对象 Persistence 对象主要作用是用于获取 EntityManagerFactory 对象的 。通过调用该类的 createEntityManagerFactory 静态方法 ， 根据配置文件中持久化单元名称创建 EntityManagerFactory。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 创建 EntitymanagerFactory </span></span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line">String unitName = <span class="string">&quot;myJpa&quot;</span>; </span><br><span class="line">EntityManagerFactory factory= Persistence.createEntityManagerFactory(unitName);</span><br></pre></td></tr></table></figure>

<p>2.EntityManagerFactory EMF接口主要用来创建EntityManager实例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建实体管理类 </span></span><br><span class="line">EntityManager em = factory.createEntityManager();</span><br></pre></td></tr></table></figure>

<p>由于 EntityManagerFactory 是一个线程安全的对象（即多个线程访问同一个 EntityManagerFactory 对象不会有线程安全问题），并且 EntityManagerFactory 的创建极其浪费资源，所以在使用 JPA 编程时，我们可以对 EntityManagerFactory 的创建进行优化，<strong>只需要做到一个工程只存在一个 EntityManagerFactory 即可</strong>。</p>
<p>3.EntityManager EM 是完成持久化操作的核心对象。实体类作为普通 java 对象， 只有在调用 EntityManager 将其持久化后才会变成持久化对象。EntityManager 对象在一组实体类与底层数据源之间进行 O/R 映射的管理。它可以用来管理和更新 Entity Bean, 根椐主键查找 Entity Bean, 还可以通过 JPQL 语句查询实体。我们可以通过<strong>调用 EntityManager 的方法完成获取事务</strong>，以及持久化数据库的操作。</p>
<p>方法说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">getTransaction : 获取事务对象 </span><br><span class="line">persist ： 保存操作 </span><br><span class="line">merge ： 更新操作 </span><br><span class="line">remove ： 删除操作 </span><br><span class="line">find/getReference ： 根据 id 查询</span><br></pre></td></tr></table></figure>

<p>4.EntityTransaction 在 JPA 规范中, EntityTransaction 是完<strong>成事务操作的核心对象</strong>，对于 EntityTransaction 在我们的 java 代码中承接的功能比较简单。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin：开启事务 </span><br><span class="line">commit：提交事务 </span><br><span class="line">rollback：回滚事务</span><br></pre></td></tr></table></figure>

<h2 id="抽取JPAUtil工具类"><a href="#抽取JPAUtil工具类" class="headerlink" title="抽取JPAUtil工具类"></a>抽取JPAUtil工具类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.itcast.dao; </span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManager; </span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManagerFactory; </span><br><span class="line"><span class="keyword">import</span> javax.persistence.Persistence; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">JPAUtil</span> </span>&#123; </span><br><span class="line">    <span class="comment">// JPA的实体管理器工厂：相当于Hibernate的SessionFactory </span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EntityManagerFactory em; </span><br><span class="line">    <span class="comment">// 使用静态代码块赋值 </span></span><br><span class="line">    <span class="keyword">static</span> &#123; </span><br><span class="line">        <span class="comment">// 注意：该方法参数必须和persistence.xml中persistence-unit标签name属性取值一致 </span></span><br><span class="line">        em = Persistence.createEntityManagerFactory(<span class="string">&quot;myPersistUnit&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 使用管理器工厂生产一个管理器对象 </span></span><br><span class="line"><span class="comment">    ** <span class="doctag">@return</span> */</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EntityManager <span class="title">getEntityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> em.createEntityManager(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用JPA完成增删改查操作"><a href="#使用JPA完成增删改查操作" class="headerlink" title="使用JPA完成增删改查操作"></a>使用JPA完成增删改查操作</h2><h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 保存一个实体</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义对象 </span></span><br><span class="line">    Customer c = <span class="keyword">new</span> Customer(); </span><br><span class="line">    c.setCustName(<span class="string">&quot;软件学院&quot;</span>); </span><br><span class="line">    c.setCustLevel(<span class="string">&quot;VIP客户&quot;</span>); </span><br><span class="line">    c.setCustSource(<span class="string">&quot;网络&quot;</span>); </span><br><span class="line">    c.setCustIndustry(<span class="string">&quot;IT教育&quot;</span>); </span><br><span class="line">    c.setCustAddress(<span class="string">&quot;北京&quot;</span>); </span><br><span class="line">    c.setCustPhone(<span class="string">&quot;1234567890&quot;</span>); </span><br><span class="line">    EntityManager em = <span class="keyword">null</span>; </span><br><span class="line">    EntityTransaction tx = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取实体管理对象 </span></span><br><span class="line">        em = JPAUtil.getEntityManager(); </span><br><span class="line">        <span class="comment">// 获取事务对象 </span></span><br><span class="line">        tx = em.getTransaction(); </span><br><span class="line">        <span class="comment">// 开启事务 </span></span><br><span class="line">        tx.begin(); </span><br><span class="line">        <span class="comment">// 执行操作 </span></span><br><span class="line">        em.persist(c); </span><br><span class="line">        <span class="comment">// 提交事务 </span></span><br><span class="line">        tx.commit(); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        <span class="comment">// 回滚事务 </span></span><br><span class="line">        tx.rollback(); </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        <span class="comment">// 释放资源 </span></span><br><span class="line">        em.close(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMerge</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="comment">//定义对象 </span></span><br><span class="line">    EntityManager em=<span class="keyword">null</span>; </span><br><span class="line">    EntityTransaction tx=<span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">try</span>&#123; </span><br><span class="line">        <span class="comment">//获取实体管理对象 </span></span><br><span class="line">        em=JPAUtil.getEntityManager(); </span><br><span class="line">        <span class="comment">//获取事务对象 </span></span><br><span class="line">        tx=em.getTransaction(); </span><br><span class="line">        <span class="comment">//开启事务 </span></span><br><span class="line">        tx.begin(); </span><br><span class="line">        <span class="comment">//执行操作 </span></span><br><span class="line">        <span class="comment">//根据主键查询</span></span><br><span class="line">        Customer c1 = em.find(Customer.class, <span class="number">6L</span>); </span><br><span class="line">        c1.setCustName(<span class="string">&quot;江苏传智学院&quot;</span>); </span><br><span class="line">        em.clear();</span><br><span class="line">        <span class="comment">//把c1对象从缓存中清除出去 </span></span><br><span class="line">        em.merge(c1); </span><br><span class="line">        <span class="comment">//提交事务 </span></span><br><span class="line">        tx.commit(); </span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123; </span><br><span class="line">        <span class="comment">//回滚事务 </span></span><br><span class="line">        tx.rollback(); </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123; </span><br><span class="line">        <span class="comment">//释放资源 </span></span><br><span class="line">        em.close();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 删除 */</span> </span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRemove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义对象 </span></span><br><span class="line">    EntityManager em = <span class="keyword">null</span>; </span><br><span class="line">    EntityTransaction tx = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取实体管理对象 </span></span><br><span class="line">        em = JPAUtil.getEntityManager(); </span><br><span class="line">        <span class="comment">// 获取事务对象 </span></span><br><span class="line">        tx = em.getTransaction(); </span><br><span class="line">        <span class="comment">// 开启事务</span></span><br><span class="line">        tx.begin(); </span><br><span class="line">        <span class="comment">// 执行操作 </span></span><br><span class="line">        Customer c1 = em.find(Customer.class, <span class="number">6L</span>); </span><br><span class="line">        em.remove(c1); </span><br><span class="line">        <span class="comment">// 提交事务 </span></span><br><span class="line">        tx.commit(); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        <span class="comment">// 回滚事务 </span></span><br><span class="line">        tx.rollback();</span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        <span class="comment">// 释放资源 </span></span><br><span class="line">        em.close(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 查询一个： 使用立即加载的策略 */</span> </span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetOne</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 定义对象 </span></span><br><span class="line">    EntityManager em = <span class="keyword">null</span>; </span><br><span class="line">    EntityTransaction tx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取实体管理对象 </span></span><br><span class="line">        em = JPAUtil.getEntityManager(); </span><br><span class="line">        <span class="comment">// 获取事务对象</span></span><br><span class="line">        tx = em.getTransaction(); </span><br><span class="line">        <span class="comment">// 开启事务 </span></span><br><span class="line">        tx.begin();</span><br><span class="line">        <span class="comment">// 执行操作</span></span><br><span class="line">        Customer c1 = em.find(Customer.class, <span class="number">1L</span>); </span><br><span class="line">        <span class="comment">// 提交事务 </span></span><br><span class="line">        tx.commit(); </span><br><span class="line">        System.out.println(c1); </span><br><span class="line">        <span class="comment">// 输出查询对象</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        <span class="comment">// 回滚事务 </span></span><br><span class="line">        tx.rollback(); </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        <span class="comment">// 释放资源 </span></span><br><span class="line">        em.close(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询实体的缓存问题 </span></span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGetOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义对象 </span></span><br><span class="line">    EntityManager em = <span class="keyword">null</span>; </span><br><span class="line">    EntityTransaction tx = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取实体管理对象 </span></span><br><span class="line">        em = JPAUtil.getEntityManager(); </span><br><span class="line">        <span class="comment">// 获取事务对象 </span></span><br><span class="line">        tx = em.getTransaction(); </span><br><span class="line">        <span class="comment">// 开启事务 </span></span><br><span class="line">        tx.begin(); </span><br><span class="line">        <span class="comment">// 执行操作 </span></span><br><span class="line">        Customer c1 = em.find(Customer.class, <span class="number">1L</span>);</span><br><span class="line">        Customer c2 = em.find(Customer.class, <span class="number">1L</span>); </span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">        <span class="comment">// 输出结果是true，EntityManager也有缓存 </span></span><br><span class="line">        <span class="comment">// 提交事务 </span></span><br><span class="line">        tx.commit(); </span><br><span class="line">        System.out.println(c1);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        <span class="comment">// 回滚事务 </span></span><br><span class="line">        tx.rollback(); </span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        <span class="comment">// 释放资源 </span></span><br><span class="line">        em.close(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 延迟加载策略的方法： </span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 查询一个： 使用延迟加载策略 */</span> </span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLoadOne</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 定义对象 </span></span><br><span class="line">    EntityManager em = <span class="keyword">null</span>; </span><br><span class="line">    EntityTransaction tx = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获取实体管理对象 </span></span><br><span class="line">        em = JPAUtil.getEntityManager(); </span><br><span class="line">        <span class="comment">// 获取事务对象 </span></span><br><span class="line">        tx = em.getTransaction();</span><br><span class="line">        <span class="comment">// 开启事务 </span></span><br><span class="line">        tx.begin();</span><br><span class="line">        <span class="comment">// 执行操作 </span></span><br><span class="line">        Customer c1 = em.getReference(Customer.class, <span class="number">1L</span>); </span><br><span class="line">        <span class="comment">// 提交事务 </span></span><br><span class="line">        tx.commit(); </span><br><span class="line">        System.out.println(c1);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        <span class="comment">// 回滚事务 </span></span><br><span class="line">        tx.rollback();</span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        em.close(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂查询"><a href="#复杂查询" class="headerlink" title="复杂查询"></a>复杂查询</h3><p>Java 持久化查询语言(JPQL)是一种可移植的查询语言，旨在以面向对象表达式语言的表达式，将 SQL 语法和简单查询语义绑定在一起使用这种语言编写的查询是可移植的，可以被编译成所有主流数据库服务器上的 SQL。</p>
<ul>
<li>查询全部</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询所有客户 </span></span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAll</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    EntityManager em = <span class="keyword">null</span>; </span><br><span class="line">    EntityTransaction tx = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取实体管理对象 </span></span><br><span class="line">        em = JPAUtil.getEntityManager(); </span><br><span class="line">        <span class="comment">//获取事务对象 </span></span><br><span class="line">        tx = em.getTransaction(); </span><br><span class="line">        tx.begin(); </span><br><span class="line">        <span class="comment">// 创建query对象 </span></span><br><span class="line">        String jpql = <span class="string">&quot;from Customer&quot;</span>;</span><br><span class="line">        Query query = em.createQuery(jpql);</span><br><span class="line">        <span class="comment">// 查询并得到返回结果</span></span><br><span class="line">        List list = query.getResultList(); </span><br><span class="line">        <span class="comment">// 得到集合返回类型</span></span><br><span class="line">        <span class="keyword">for</span> (Object object : list) &#123; </span><br><span class="line">            System.out.println(object); </span><br><span class="line">        &#125;</span><br><span class="line">        tx.commit();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        <span class="comment">// 回滚事务 </span></span><br><span class="line">        tx.rollback(); </span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        <span class="comment">// 释放资源 </span></span><br><span class="line">        em.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>分页查询</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//分页查询客户 </span></span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findPaged</span> <span class="params">()</span> </span>&#123; </span><br><span class="line">    EntityManager em = <span class="keyword">null</span>; </span><br><span class="line">    EntityTransaction tx = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取实体管理对象</span></span><br><span class="line">        em = JPAUtil.getEntityManager(); </span><br><span class="line">        <span class="comment">//获取事务对象 </span></span><br><span class="line">        tx = em.getTransaction(); </span><br><span class="line">        tx.begin();</span><br><span class="line">        <span class="comment">//创建query对象 </span></span><br><span class="line">        String jpql = <span class="string">&quot;from Customer&quot;</span>; </span><br><span class="line">        Query query = em.createQuery(jpql); </span><br><span class="line">        <span class="comment">//起始索引 </span></span><br><span class="line">        query.setFirstResult(<span class="number">0</span>); </span><br><span class="line">        <span class="comment">//每页显示条数 </span></span><br><span class="line">        query.setMaxResults(<span class="number">2</span>); </span><br><span class="line">        <span class="comment">//查询并得到返回结果 </span></span><br><span class="line">        List list = query.getResultList(); </span><br><span class="line">        <span class="comment">//得到集合返回类型 </span></span><br><span class="line">        <span class="keyword">for</span> (Object object : list) &#123; </span><br><span class="line">            System.out.println(object); </span><br><span class="line">        &#125;</span><br><span class="line">        tx.commit(); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        <span class="comment">// 回滚事务 </span></span><br><span class="line">        tx.rollback(); </span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        <span class="comment">// 释放资源 </span></span><br><span class="line">        em.close(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>条件查询</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//条件查询 </span></span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findCondition</span> <span class="params">()</span> </span>&#123; </span><br><span class="line">    EntityManager em = <span class="keyword">null</span>; </span><br><span class="line">    EntityTransaction tx = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取实体管理对象 </span></span><br><span class="line">        em = JPAUtil.getEntityManager(); </span><br><span class="line">        <span class="comment">//获取事务对象</span></span><br><span class="line">        tx = em.getTransaction(); </span><br><span class="line">        tx.begin();</span><br><span class="line">        <span class="comment">//创建query对象 </span></span><br><span class="line">        String jpql = <span class="string">&quot;from Customer where custName like ? &quot;</span>; </span><br><span class="line">        Query query = em.createQuery(jpql);</span><br><span class="line">        <span class="comment">//对占位符赋值，从1开始 </span></span><br><span class="line">        query.setParameter(<span class="number">1</span>, <span class="string">&quot;传智播客%&quot;</span>); </span><br><span class="line">        <span class="comment">//查询并得到返回结果</span></span><br><span class="line">        Object object = query.getSingleResult(); </span><br><span class="line">        <span class="comment">//得到唯一的结果集对象 </span></span><br><span class="line">        System.out.println(object); </span><br><span class="line">        tx.commit(); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        <span class="comment">// 回滚事务</span></span><br><span class="line">        tx.rollback(); </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        em.close();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>排序查询</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据客户id倒序查询所有客户 </span></span><br><span class="line"><span class="comment">//查询所有客户 </span></span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testOrder</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    EntityManager em = <span class="keyword">null</span>; </span><br><span class="line">    EntityTransaction tx = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取实体管理对象 </span></span><br><span class="line">        em = JPAUtil.getEntityManager(); </span><br><span class="line">        <span class="comment">//获取事务对象 </span></span><br><span class="line">        tx = em.getTransaction(); </span><br><span class="line">        tx.begin();</span><br><span class="line">        <span class="comment">// 创建query对象 </span></span><br><span class="line">        String jpql = <span class="string">&quot;from Customer order by custId desc&quot;</span>;</span><br><span class="line">        Query query = em.createQuery(jpql);</span><br><span class="line">        <span class="comment">// 查询并得到返回结果 </span></span><br><span class="line">        List list = query.getResultList();</span><br><span class="line">        <span class="comment">// 得到集合返回类型 </span></span><br><span class="line">        <span class="keyword">for</span> (Object object : list) &#123; </span><br><span class="line">            System.out.println(object); </span><br><span class="line">        &#125;</span><br><span class="line">        tx.commit(); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// 回滚事务 </span></span><br><span class="line">        tx.rollback(); </span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        <span class="comment">// 释放资源 </span></span><br><span class="line">        em.close(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>统计查询</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//统计查询 </span></span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findCount</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    EntityManager em = <span class="keyword">null</span>; </span><br><span class="line">    EntityTransaction tx = <span class="keyword">null</span>; </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取实体管理对象 </span></span><br><span class="line">        em = JPAUtil.getEntityManager(); </span><br><span class="line">        <span class="comment">//获取事务对象 </span></span><br><span class="line">        tx = em.getTransaction(); </span><br><span class="line">        tx.begin();</span><br><span class="line">        <span class="comment">// 查询全部客户</span></span><br><span class="line">        <span class="comment">// 1.创建query对象 </span></span><br><span class="line">        String jpql = <span class="string">&quot;select count(custId) from Customer&quot;</span>; </span><br><span class="line">        Query query = em.createQuery(jpql); </span><br><span class="line">        <span class="comment">// 2.查询并得到返回结果 </span></span><br><span class="line">        Object count = query.getSingleResult(); </span><br><span class="line">        <span class="comment">// 得到集合返回类型 </span></span><br><span class="line">        System.out.println(count); </span><br><span class="line">        tx.commit(); </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        <span class="comment">// 回滚事务 </span></span><br><span class="line">        tx.rollback(); </span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123; </span><br><span class="line">        <span class="comment">// 释放资源 </span></span><br><span class="line">        em.close(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>SpringData JPA</category>
      </categories>
  </entry>
  <entry>
    <title>SpringData JPA(三)</title>
    <url>/2021/02/06/202126-SpringData-JPA(%E4%B8%89)/</url>
    <content><![CDATA[<p>利用 SpringData JPA 进行多表查询</p>
<span id="more"></span>

<h2 id="Specifications动态查询"><a href="#Specifications动态查询" class="headerlink" title="Specifications动态查询"></a>Specifications动态查询</h2><ul>
<li>条件查询</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//依赖注入customerDao </span></span><br><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line"><span class="keyword">private</span> CustomerDao customerDao; </span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSpecifications</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">//使用匿名内部类的方式，创建一个Specification的实现类，并实现toPredicate方法 </span></span><br><span class="line">    Specification &lt;Customer&gt; spec = <span class="keyword">new</span> Specification&lt;Customer&gt;() &#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Predicate <span class="title">toPredicate</span><span class="params">(Root&lt;Customer&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb)</span> </span>&#123; </span><br><span class="line">            <span class="comment">//cb:构建查询，添加查询方式 like：模糊匹配 </span></span><br><span class="line">            <span class="comment">//root：从实体Customer对象中按照custName属性进行查询 </span></span><br><span class="line">            <span class="keyword">return</span> cb.like(root.get(<span class="string">&quot;custName&quot;</span>).as(String.class), <span class="string">&quot;传智播客%&quot;</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Customer customer = customerDao.findOne(spec); </span><br><span class="line">    System.out.println(customer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>分页查询</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPage</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="comment">//构造查询条件 </span></span><br><span class="line">    Specification&lt;Customer&gt; spec = <span class="keyword">new</span> Specification&lt;Customer&gt;() &#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Predicate <span class="title">toPredicate</span><span class="params">(Root&lt;Customer&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb)</span> </span>&#123; </span><br><span class="line">            <span class="keyword">return</span> cb.like(root.get(<span class="string">&quot;custName&quot;</span>).as(String.class), <span class="string">&quot;传智%&quot;</span>); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 构造分页参数 </span></span><br><span class="line"><span class="comment">* Pageable : 接口 </span></span><br><span class="line"><span class="comment">* PageRequest实现了Pageable接口，调用构造方法的形式构造 </span></span><br><span class="line"><span class="comment">* 第一个参数：页码（从0开始）</span></span><br><span class="line"><span class="comment">* 第二个参数：每页查询条数 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line">    Pageable pageable = <span class="keyword">new</span> PageRequest(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 分页查询，封装为Spring Data Jpa 内部的page bean </span></span><br><span class="line"><span class="comment">    * 此重载的findAll方法为分页方法需要两个参数 </span></span><br><span class="line"><span class="comment">    * 第一个参数：查询条件Specification </span></span><br><span class="line"><span class="comment">    * 第二个参数：分页参数 </span></span><br><span class="line"><span class="comment">    */</span> </span><br><span class="line">    Page&lt;Customer&gt; page = customerDao.findAll(spec,pageable); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分页查询返回一个pageBean对象，方法说明：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取总页数 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getTotalPages</span><span class="params">()</span></span>; </span><br><span class="line"><span class="comment">//获取总记录数 </span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getTotalElements</span><span class="params">()</span></span>; </span><br><span class="line"><span class="comment">//获取列表数据 </span></span><br><span class="line"><span class="function">List&lt;T&gt; <span class="title">getContent</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法对应关系</li>
</ul>
<p><img src="/images/SpringDataJPA/method_sql.png" alt="img"></p>
<h2 id="JPA中的一对多"><a href="#JPA中的一对多" class="headerlink" title="JPA中的一对多"></a>JPA中的一对多</h2><h3 id="1-样例分析"><a href="#1-样例分析" class="headerlink" title="1.样例分析"></a>1.样例分析</h3><p>公司（客户）和员工（联系人）的关系为一对多</p>
<h3 id="2-表关系建立"><a href="#2-表关系建立" class="headerlink" title="2.表关系建立"></a>2.表关系建立</h3><p>在一对多中，我们习惯把一的一方称之为主表，把多的一方称之为从表。在数据库中建立一对多的关系，需要用到外键约束。 即从表中有一列，取值参照主表的主键，这一列就是外键。</p>
<p><img src="/images/SpringDataJPA/table.png" alt="img"></p>
<h3 id="3-实体类关系建立以及映射配置"><a href="#3-实体类关系建立以及映射配置" class="headerlink" title="3.实体类关系建立以及映射配置"></a>3.实体类关系建立以及映射配置</h3><p>实体类要体现出客户中有多个联系人的信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 客户的实体类 </span></span><br><span class="line"><span class="comment">* 明确使用的注解都是JPA规范的 </span></span><br><span class="line"><span class="comment">* 所以导包都要导入javax.persistence包下的 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="comment">//表示当前类是一个实体类 </span></span><br><span class="line"><span class="meta">@Table(name=&quot;cst_customer&quot;)</span></span><br><span class="line"><span class="comment">//建立当前实体类和表之间的对应关系 </span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="comment">//表明当前私有属性是主键 </span></span><br><span class="line">    <span class="meta">@GeneratedValue(strategy=GenerationType.IDENTITY)</span><span class="comment">//指定主键的生成策略 </span></span><br><span class="line">    <span class="meta">@Column(name=&quot;cust_id&quot;)</span><span class="comment">//指定和数据库表中的cust_id列对应 private Long custId; </span></span><br><span class="line">    <span class="meta">@Column(name=&quot;cust_name&quot;)</span><span class="comment">//指定和数据库表中的cust_name列对应 </span></span><br><span class="line">    <span class="keyword">private</span> String custName; </span><br><span class="line">    <span class="meta">@Column(name=&quot;cust_source&quot;)</span><span class="comment">//指定和数据库表中的cust_source列对应 </span></span><br><span class="line">    <span class="keyword">private</span> String custSource; </span><br><span class="line">    <span class="meta">@Column(name=&quot;cust_industry&quot;)</span><span class="comment">//指定和数据库表中的cust_industry列对应 </span></span><br><span class="line">    <span class="keyword">private</span> String custIndustry; </span><br><span class="line">    <span class="meta">@Column(name=&quot;cust_level&quot;)</span><span class="comment">//指定和数据库表中的cust_level列对应 </span></span><br><span class="line">    <span class="keyword">private</span> String custLevel; </span><br><span class="line">    <span class="meta">@Column(name=&quot;cust_address&quot;)</span><span class="comment">//指定和数据库表中的cust_address列对应 </span></span><br><span class="line">    <span class="keyword">private</span> String custAddress; </span><br><span class="line">    <span class="meta">@Column(name=&quot;cust_phone&quot;)</span><span class="comment">//指定和数据库表中的cust_phone列对应 </span></span><br><span class="line">    <span class="keyword">private</span> String custPhone; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//配置客户和联系人的一对多关系 </span></span><br><span class="line">    <span class="meta">@OneToMany(targetEntity=LinkMan.class)</span> <span class="comment">//声明一对多关系</span></span><br><span class="line">    <span class="meta">@JoinColumn(name=&quot;lkm_cust_id&quot;,referencedColumnName=&quot;cust_id&quot;)</span> <span class="comment">//声明外键约束 </span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;LinkMan&gt; linkmans = <span class="keyword">new</span> HashSet&lt;LinkMan&gt;(<span class="number">0</span>);</span><br><span class="line">    getter/setter/toString...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于联系人是多的一方，在实体类中要体现出，每个联系人只能对应一个客户</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 联系人的实体类（数据模型） </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">@Entity</span> </span><br><span class="line"><span class="meta">@Table(name=&quot;cst_linkman&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkMan</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Id</span> </span><br><span class="line">    <span class="meta">@GeneratedValue(strategy=GenerationType.IDENTITY)</span> </span><br><span class="line">    <span class="meta">@Column(name=&quot;lkm_id&quot;)</span> </span><br><span class="line">    <span class="keyword">private</span> Long lkmId; </span><br><span class="line">    <span class="meta">@Column(name=&quot;lkm_name&quot;)</span> </span><br><span class="line">    <span class="keyword">private</span> String lkmName; </span><br><span class="line">    <span class="meta">@Column(name=&quot;lkm_gender&quot;)</span> </span><br><span class="line">    <span class="keyword">private</span> String lkmGender; </span><br><span class="line">    <span class="meta">@Column(name=&quot;lkm_phone&quot;)</span> </span><br><span class="line">    <span class="keyword">private</span> String lkmPhone; </span><br><span class="line">    <span class="meta">@Column(name=&quot;lkm_mobile&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String lkmMobile; </span><br><span class="line">    <span class="meta">@Column(name=&quot;lkm_email&quot;)</span> </span><br><span class="line">    <span class="keyword">private</span> String lkmEmail; </span><br><span class="line">    <span class="meta">@Column(name=&quot;lkm_position&quot;)</span> </span><br><span class="line">    <span class="keyword">private</span> String lkmPosition; </span><br><span class="line">    <span class="meta">@Column(name=&quot;lkm_memo&quot;)</span> </span><br><span class="line">    <span class="keyword">private</span> String lkmMemo; </span><br><span class="line">    <span class="comment">//多对一关系映射：多个联系人对应客户 </span></span><br><span class="line">    <span class="meta">@ManyToOne(targetEntity=Customer.class)</span></span><br><span class="line">    <span class="meta">@JoinColumn(name=&quot;lkm_cust_id&quot;,referencedColumnName=&quot;cust_id&quot;)</span> </span><br><span class="line">    <span class="keyword">private</span> Customer customer;<span class="comment">//用它的主键，对应联系人表中的外键</span></span><br><span class="line">    getter/setter/toString...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-注解说明"><a href="#4-注解说明" class="headerlink" title="4.注解说明"></a>4.注解说明</h3><p><strong>@OneToMany</strong><br>作用：建立一对多的关系映射<br>属性：<br>    targetEntityClass：指定多的多方的类的字节码<br>    mappedBy：指定从表实体类中引用主表对象的名称。<br>    cascade：指定要使用的级联操作<br>    fetch：指定是否采用延迟加载<br>    orphanRemoval：是否使用孤儿删除<br><strong>@ManyToOne</strong><br>作用：建立多对一的关系<br>属性：<br>    targetEntityClass：指定一的一方实体类字节码<br>    cascade：指定要使用的级联操作<br>    fetch：指定是否采用延迟加载<br>    optional：关联是否可选。如果设置为 false，则必须始终存在非空关系。<br><strong>@JoinColumn</strong><br>作用：用于定义主键字段和外键字段的对应关系。<br>属性：<br>    name：指定外键字段的名称<br>    referencedColumnName：指定引用主表的主键字段名称<br>    unique：是否唯一。默认值不唯一<br>    nullable：是否允许为空。默认值允许。<br>    insertable：是否允许插入。默认值允许。<br>    updatable：是否允许更新。默认值允许。<br>    columnDefinition：列的定义信息。</p>
<h3 id="5-具体操作"><a href="#5-具体操作" class="headerlink" title="5.具体操作"></a>5.具体操作</h3><ul>
<li>添加</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span> </span><br><span class="line"><span class="meta">@ContextConfiguration(locations=&quot;classpath:applicationContext.xml&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OneToManyTest</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Autowired</span> <span class="keyword">private</span> CustomerDao customerDao; </span><br><span class="line">    <span class="meta">@Autowired</span> <span class="keyword">private</span> LinkManDao linkManDao; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 保存操作 </span></span><br><span class="line"><span class="comment">    * 需求: </span></span><br><span class="line"><span class="comment">    * 保存一个客户和一个联系人 </span></span><br><span class="line"><span class="comment">    * 要求： </span></span><br><span class="line"><span class="comment">    * 创建一个客户对象和一个联系人对象 </span></span><br><span class="line"><span class="comment">    * 建立客户和联系人之间关联关系（双向一对多的关联关系） </span></span><br><span class="line"><span class="comment">    * 先保存客户，再保存联系人 </span></span><br><span class="line"><span class="comment">    * 问题： </span></span><br><span class="line"><span class="comment">    * 当我们建立了双向的关联关系之后，先保存主表，再保存从表时： </span></span><br><span class="line"><span class="comment">    * 会产生2条insert和1条update. </span></span><br><span class="line"><span class="comment">    * 而实际开发中我们只需要2条insert。 </span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span> </span><br><span class="line">    <span class="meta">@Transactional</span> </span><br><span class="line">    <span class="comment">//开启事务 </span></span><br><span class="line">    <span class="meta">@Rollback(false)</span></span><br><span class="line">    <span class="comment">//设置为不回滚 </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        Customer c = <span class="keyword">new</span> Customer(); </span><br><span class="line">        c.setCustName(<span class="string">&quot;客户1&quot;</span>); </span><br><span class="line">        c.setCustLevel(<span class="string">&quot;VIP客户&quot;</span>); </span><br><span class="line">        c.setCustSource(<span class="string">&quot;网络&quot;</span>); </span><br><span class="line">        c.setCustIndustry(<span class="string">&quot;商业办公&quot;</span>); </span><br><span class="line">        c.setCustAddress(<span class="string">&quot;中国&quot;</span>); </span><br><span class="line">        c.setCustPhone(<span class="string">&quot;010-87654321&quot;</span>);</span><br><span class="line">        LinkMan l = <span class="keyword">new</span> LinkMan(); </span><br><span class="line">        l.setLkmName(<span class="string">&quot;联系人1&quot;</span>); </span><br><span class="line">        l.setLkmGender(<span class="string">&quot;male&quot;</span>); </span><br><span class="line">        l.setLkmMobile(<span class="string">&quot;13811111111&quot;</span>); </span><br><span class="line">        l.setLkmPhone(<span class="string">&quot;+812345678&quot;</span>); </span><br><span class="line">        l.setLkmEmail(<span class="string">&quot;987654321@qq.com&quot;</span>); </span><br><span class="line">        l.setLkmPosition(<span class="string">&quot;老师&quot;</span>); </span><br><span class="line">        l.setLkmMemo(<span class="string">&quot;行&quot;</span>); </span><br><span class="line">        c.getLinkMans().add(l); </span><br><span class="line">        l.setCustomer(c); </span><br><span class="line">        customerDao.save(c); </span><br><span class="line">        linkManDao.save(l); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过保存的案例，我们可以发现在设置了双向关系之后，会发送两条 insert 语句，一条多余的 update 语句，那我们的解决是思路很简单，就是一的一方放弃维护权。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/***放弃外键维护权的配置将如下配置改为 */</span> </span><br><span class="line"><span class="comment">//@OneToMany(targetEntity=LinkMan.class) </span></span><br><span class="line"><span class="comment">//@JoinColumn(name=&quot;lkm_cust_id&quot;,referencedColumnName=&quot;cust_id&quot;)</span></span><br><span class="line"><span class="comment">//设置为 </span></span><br><span class="line"><span class="meta">@OneToMany(mappedBy=&quot;customer&quot;)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line"><span class="keyword">private</span> CustomerDao customerDao; </span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="meta">@Transactional</span> </span><br><span class="line"><span class="meta">@Rollback(false)</span></span><br><span class="line"><span class="comment">//设置为不回滚 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    customerDao.delete(<span class="number">1l</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>删除说明：</strong><br><strong>删除从表数据：</strong>可以随时任意删除。<br><strong>删除主表数据：</strong><br>有从表数据<br>1、在默认情况下，它会把外键字段置为 null，然后删除 主表数据。如果在数据库的表结构上，外键字段有非空约束，默认情况就会报错了。<br>2、如果配置了放弃维护关联关系的权利，则不能删除 （与外键字段是否允许为 null， 没有关系）因为在删除 时，它根本不会去更新从表的外键字段了。<br>3、如果还想删除，使用级联删除引用<br>没有从表数据引用：随便删<br>在实际开发中，级联删除请慎用！(在一对多的情况下)</p>
<ul>
<li>级联操作<br>指操作一个对象同时操作它的关联对象 使用时，在操作主体的注解上配置cascade</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* cascade:配置级联操作 </span></span><br><span class="line"><span class="comment">* CascadeType.MERGE 级联更新 </span></span><br><span class="line"><span class="comment">* CascadeType.PERSIST 级联保存：</span></span><br><span class="line"><span class="comment">* CascadeType.REFRESH 级联刷新： </span></span><br><span class="line"><span class="comment">* CascadeType.REMOVE 级联删除： </span></span><br><span class="line"><span class="comment">* CascadeType.ALL 包含所有 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">@OneToMany(mappedBy=&quot;customer&quot;,cascade=CascadeType.ALL)</span></span><br></pre></td></tr></table></figure>

<h2 id="JPA中的多对多"><a href="#JPA中的多对多" class="headerlink" title="JPA中的多对多"></a>JPA中的多对多</h2><h3 id="1-样例分析-1"><a href="#1-样例分析-1" class="headerlink" title="1.样例分析"></a>1.样例分析</h3><p>用户（同学）和角色（身份）的关系为多对多</p>
<h3 id="2-表关系建立-1"><a href="#2-表关系建立-1" class="headerlink" title="2.表关系建立"></a>2.表关系建立</h3><p>多对多的表关系建立靠的是中间表，其中用户表和中间表的关系是一对多，角色表和中间表的关系也是一对多。</p>
<p><img src="/images/SpringDataJPA/many_to_many.png" alt="img"></p>
<h3 id="3-实体类关系建立以及映射配置-1"><a href="#3-实体类关系建立以及映射配置-1" class="headerlink" title="3.实体类关系建立以及映射配置"></a>3.实体类关系建立以及映射配置</h3><p>一个用户可以具有多个角色，所以在用户实体类中应该包含多个角色的信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 用户的数据模型 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">@Entity</span> </span><br><span class="line"><span class="meta">@Table(name=&quot;sys_user&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysUser</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Id</span> </span><br><span class="line">    <span class="meta">@GeneratedValue(strategy=GenerationType.IDENTITY)</span> </span><br><span class="line">    <span class="meta">@Column(name=&quot;user_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long userId; </span><br><span class="line">    <span class="meta">@Column(name=&quot;user_code&quot;)</span> </span><br><span class="line">    <span class="keyword">private</span> String userCode; </span><br><span class="line">    <span class="meta">@Column(name=&quot;user_name&quot;)</span> </span><br><span class="line">    <span class="keyword">private</span> String userName; </span><br><span class="line">    <span class="meta">@Column(name=&quot;user_password&quot;)</span> </span><br><span class="line">    <span class="keyword">private</span> String userPassword; </span><br><span class="line">    <span class="meta">@Column(name=&quot;user_state&quot;)</span> </span><br><span class="line">    <span class="keyword">private</span> String userState; </span><br><span class="line">    <span class="comment">//多对多关系映射 </span></span><br><span class="line">    <span class="meta">@ManyToMany(mappedBy=&quot;users&quot;)</span> </span><br><span class="line">    <span class="keyword">private</span> Set&lt;SysRole&gt; roles = <span class="keyword">new</span> HashSet&lt;SysRole&gt;(<span class="number">0</span>);</span><br><span class="line">    getter/setter/toString...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个角色可以赋予多个用户，所以在角色实体类中应该包含多个用户的信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 角色的数据模型 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">@Entity</span> </span><br><span class="line"><span class="meta">@Table(name=&quot;sys_role&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SysRole</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Id</span> </span><br><span class="line">    <span class="meta">@GeneratedValue(strategy=GenerationType.IDENTITY)</span> </span><br><span class="line">    <span class="meta">@Column(name=&quot;role_id&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Long roleId; </span><br><span class="line">    <span class="meta">@Column(name=&quot;role_name&quot;)</span> </span><br><span class="line">    <span class="keyword">private</span> String roleName; </span><br><span class="line">    <span class="meta">@Column(name=&quot;role_memo&quot;)</span> </span><br><span class="line">    <span class="keyword">private</span> String roleMemo; </span><br><span class="line">    <span class="comment">//多对多关系映射 </span></span><br><span class="line">    <span class="meta">@ManyToMany</span> </span><br><span class="line">    <span class="meta">@JoinTable(name=&quot;user_role_rel&quot;,//中间表的名称 </span></span><br><span class="line"><span class="meta">               //中间表user_role_rel字段关联sys_role表的主键字段role_id </span></span><br><span class="line"><span class="meta">               joinColumns=&#123;@JoinColumn(name=&quot;role_id&quot;,referencedColumnName=&quot;role_id&quot;)&#125;, </span></span><br><span class="line"><span class="meta">               //中间表user_role_rel的字段关联sys_user表的主键user_id </span></span><br><span class="line"><span class="meta">               inverseJoinColumns=&#123;@JoinColumn(name=&quot;user_id&quot;,referencedColumnName=&quot;user_id&quot;)&#125; )</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;SysUser&gt; users = <span class="keyword">new</span> HashSet&lt;SysUser&gt;(<span class="number">0</span>);</span><br><span class="line">    getter/setter/toString...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-注解说明-1"><a href="#4-注解说明-1" class="headerlink" title="4.注解说明"></a>4.注解说明</h3><p><strong>@ManyToMany</strong> 作用：用于映射多对多关系 属性： cascade：配置级联操作。 fetch：配置是否采用延迟加载。 targetEntity：配置目标的实体类。映射多对多的时候不用写。</p>
<p><strong>@JoinTable</strong> 作用：针对中间表的配置 属性： name：配置中间表的名称 joinColumns：中间表的外键字段关联当前实体类所对应表的主键字段 inverseJoinColumn：中间表的外键字段关联对方表的主键字段</p>
<p><strong>@JoinColumn</strong> 作用：用于定义主键字段和外键字段的对应关系。 属性： name：指定外键字段的名称 referencedColumnName：指定引用主表的主键字段名称 unique：是否唯一。默认值不唯一 nullable：是否允许为空。默认值允许。 insertable：是否允许插入。默认值允许。 updatable：是否允许更新。默认值允许。 columnDefinition：列的定义信息。</p>
<h3 id="5-具体操作-1"><a href="#5-具体操作-1" class="headerlink" title="5.具体操作"></a>5.具体操作</h3><ul>
<li>保存</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line"><span class="keyword">private</span> UserDao userDao; </span><br><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line"><span class="keyword">private</span> RoleDao roleDao; </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 需求： </span></span><br><span class="line"><span class="comment">* 保存用户和角色</span></span><br><span class="line"><span class="comment">* 要求：</span></span><br><span class="line"><span class="comment">* 创建2个用户和3个角色</span></span><br><span class="line"><span class="comment">* 让1号用户具有1号和2号角色(双向的)</span></span><br><span class="line"><span class="comment">* 让2号用户具有2号和3号角色(双向的) </span></span><br><span class="line"><span class="comment">* 保存用户和角色 </span></span><br><span class="line"><span class="comment">* 问题：</span></span><br><span class="line"><span class="comment">* 在保存时，会出现主键重复的错误，因为都是要往中间表中保存数据造成的。 </span></span><br><span class="line"><span class="comment">* 解决办法：</span></span><br><span class="line"><span class="comment">* 让任意一方放弃维护关联关系的权利 */</span></span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="meta">@Transactional</span> </span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line"><span class="meta">@Rollback(false)</span></span><br><span class="line"><span class="comment">//设置为不回滚</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="comment">//创建对象 </span></span><br><span class="line">    SysUser u1 = <span class="keyword">new</span> SysUser(); </span><br><span class="line">    u1.setUserName(<span class="string">&quot;用户1&quot;</span>); </span><br><span class="line">    SysRole r1 = <span class="keyword">new</span> SysRole(); </span><br><span class="line">    r1.setRoleName(<span class="string">&quot;角色1&quot;</span>);</span><br><span class="line">    <span class="comment">//建立关联关系 </span></span><br><span class="line">    u1.getRoles().add(r1); </span><br><span class="line">    r1.getUsers().add(u1); </span><br><span class="line">    <span class="comment">//保存</span></span><br><span class="line">    roleDao.save(r1); </span><br><span class="line">    userDao.save(u1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在多对多（保存）中，如果双向都设置关系，意味着双方都维护中间表，都会往中间表插入数据， 中间表的 2 个字段又作为联合主键，所以报错，主键重复，解决保存失败的问题：只需要在任意一 方放弃对中间表的维护权即可，推荐在被动的一方放弃</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//放弃对中间表的维护权，解决保存中主键冲突的问题 </span></span><br><span class="line"><span class="meta">@ManyToMany(mappedBy=&quot;roles&quot;)</span> </span><br><span class="line"><span class="keyword">private</span> Set&lt;SysUser&gt; users = <span class="keyword">new</span> HashSet&lt;SysUser&gt;(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>删除</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line"><span class="keyword">private</span> UserDao userDao; </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 删除操作</span></span><br><span class="line"><span class="comment">* 在多对多的删除时，双向级联删除根本不能配置 </span></span><br><span class="line"><span class="comment">* 禁用 </span></span><br><span class="line"><span class="comment">* 如果配了的话，如果数据之间有相互引用关系，可能会清空所有数据 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@Rollback(false)</span></span><br><span class="line"><span class="comment">//设置为不回滚 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    userDao.delete(<span class="number">1l</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h3 id="对象导航查询"><a href="#对象导航查询" class="headerlink" title="对象导航查询"></a>对象导航查询</h3><p>对象图导航检索方式是根据已经加载的对象，导航到他的关联对象。它利用类与类之间的关系来检索对象。 例如：我们通过 ID 查询方式查出一个客户，可以调用 Customer 类中的 getLinkMans()方法 来获取该客户的所有联系人。对象导航查询的使用要求是：两个对象之间必须存在关联关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询一个客户，获取该客户下的所有联系人</span></span><br><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line"><span class="keyword">private</span> CustomerDao customerDao; </span><br><span class="line"><span class="meta">@Test</span> </span><br><span class="line"><span class="comment">//由于是在java代码中测试，为了解决no session问题，将操作配置到同一个事务中 </span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFind</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    Customer customer = customerDao.findOne(<span class="number">5l</span>); </span><br><span class="line">    Set&lt;LinkMan&gt; linkMans = customer.getLinkMans();</span><br><span class="line">    <span class="comment">//对象导航查询 </span></span><br><span class="line">    <span class="keyword">for</span>(LinkMan linkMan : linkMans) &#123; </span><br><span class="line">        System.out.println(linkMan); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查询一个联系人，获取该联系人的所有客户</span></span><br><span class="line"><span class="meta">@Autowired</span> </span><br><span class="line"><span class="keyword">private</span> LinkManDao linkManDao; </span><br><span class="line"><span class="meta">@Test</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFind</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    LinkMan linkMan = linkManDao.findOne(<span class="number">4l</span>); </span><br><span class="line">    Customer customer = linkMan.getCustomer(); </span><br><span class="line">    <span class="comment">//对象导航查询 </span></span><br><span class="line">    System.out.println(customer); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对象导航查询的问题分析</strong></p>
<p>问题 1：我们查询客户时，要不要把联系人查询出来？</p>
<p>分析：如果我们不查的话，在用的时候还要自己写代码，调用方法去查询。如果我们查出来的，不使用时又会白白的浪费了服务器内存。</p>
<p>解决：采用延迟加载的思想。通过配置的方式来设定当我们在需要使用时，发起真正的查询。 </p>
<p>配置方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在客户对象的<span class="doctag">@OneToMany</span>注解中添加fetch属性 </span></span><br><span class="line"><span class="comment">* FetchType.EAGER ：立即加载 </span></span><br><span class="line"><span class="comment">* FetchType.LAZY ：延迟加载 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">@OneToMany(mappedBy=&quot;customer&quot;,fetch=FetchType.LAZY)</span> </span><br><span class="line"><span class="keyword">private</span> Set&lt;LinkMan&gt; linkMans = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>问题 2：我们查询联系人时，要不要把客户查询出来？</p>
<p>分析：例如：查询联系人详情时，肯定会看看该联系人的所属客户。如果我们不查的话，在用的时候还要自己写代码，调用方法去查询。如果我们查出来的话，一个对象不会消耗太多的内存。而且 多数情况下我们都是要使用的。</p>
<p>解决： 采用立即加载的思想。通过配置的方式来设定，只要查询从表实体，就把主表实体对象同时查出来</p>
<p>配置方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 在联系人对象的<span class="doctag">@ManyToOne</span>注解中添加fetch属性 </span></span><br><span class="line"><span class="comment">* FetchType.EAGER ：立即加载 </span></span><br><span class="line"><span class="comment">* FetchType.LAZY ：延迟加载 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">@ManyToOne(targetEntity=Customer.class,fetch=FetchType.EAGER)</span> </span><br><span class="line"><span class="meta">@JoinColumn(name=&quot;cst_lkm_id&quot;,referencedColumnName=&quot;cust_id&quot;)</span> </span><br><span class="line"><span class="keyword">private</span> Customer customer;</span><br></pre></td></tr></table></figure>

<h3 id="Specification查询"><a href="#Specification查询" class="headerlink" title="Specification查询"></a>Specification查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Specification的多表查询</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFind</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    Specification&lt;LinkMan&gt; spec = <span class="keyword">new</span> Specification&lt;LinkMan&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Predicate <span class="title">toPredicate</span><span class="params">(Root&lt;LinkMan&gt; root, CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//Join代表链接查询，通过root对象获取</span></span><br><span class="line">            <span class="comment">//创建的过程中，第一个参数为关联对象的属性名称，第二个参数为连接查询的方式（left， inner，right） </span></span><br><span class="line">            <span class="comment">//JoinType.LEFT : 左外连接,JoinType.INNER：内连接,JoinType.RIGHT：右外连 接 </span></span><br><span class="line">            Join&lt;LinkMan, Customer&gt; join = root.join(<span class="string">&quot;customer&quot;</span>,JoinType.INNER); </span><br><span class="line">            <span class="keyword">return</span> cb.like(join.get(<span class="string">&quot;custName&quot;</span>).as(String.class),<span class="string">&quot;传智播客1&quot;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;;</span><br><span class="line">    List&lt;LinkMan&gt; list = linkManDao.findAll(spec); </span><br><span class="line">    <span class="keyword">for</span> (LinkMan linkMan : list) &#123; </span><br><span class="line">        System.out.println(linkMan);</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringData JPA</category>
      </categories>
  </entry>
  <entry>
    <title>【转载】Java基础知识大纲</title>
    <url>/2020/05/08/202058-%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%A7%E7%BA%B2/</url>
    <content><![CDATA[<p>JavaGuide哥整理的一些基础知识问答</p>
<p><strong>全文转载自：</strong><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md</a></p>
<span id="more"></span>

<h2 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1. 面向对象和面向过程的区别"></a>1. 面向对象和面向过程的区别</h2><ul>
<li><strong>面向过程</strong> ：<strong>面向过程性能比面向对象高。</strong> 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></li>
<li><strong>面向对象</strong> ：<strong>面向对象易维护、易复用、易扩展。</strong> 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>面向对象性能比面向过程低</strong>。</li>
</ul>
<p>参见 issue : <a href="https://github.com/Snailclimb/JavaGuide/issues/431">面向过程 ：面向过程性能比面向对象高？？</a></p>
<blockquote>
<p>这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。</p>
<p>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。</p>
</blockquote>
<h2 id="2-Java-语言有哪些特点"><a href="#2-Java-语言有哪些特点" class="headerlink" title="2. Java 语言有哪些特点?"></a>2. Java 语言有哪些特点?</h2><ol>
<li>简单易学；</li>
<li>面向对象（封装，继承，多态）；</li>
<li>平台无关性（ Java 虚拟机实现平台无关性）；</li>
<li>可靠性；</li>
<li>安全性；</li>
<li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li>
<li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li>
<li>编译与解释并存；</li>
</ol>
<blockquote>
<p>修正（参见： <a href="https://github.com/Snailclimb/JavaGuide/issues/544">issue#544</a>）：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用<code>std::thread</code>和<code>std::async</code>来创建线程。参考链接：<a href="http://www.cplusplus.com/reference/thread/thread/?kw=thread">http://www.cplusplus.com/reference/thread/thread/?kw=thread</a></p>
</blockquote>
<h2 id="3-关于-JVM-JDK-和-JRE-最详细通俗的解答"><a href="#3-关于-JVM-JDK-和-JRE-最详细通俗的解答" class="headerlink" title="3. 关于 JVM JDK 和 JRE 最详细通俗的解答"></a>3. 关于 JVM JDK 和 JRE 最详细通俗的解答</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p>
<p><strong>什么是字节码?采用字节码的好处是什么?</strong></p>
<blockquote>
<p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
</blockquote>
<p><strong>Java 程序从源代码到运行一般有下面 3 步：</strong></p>
<p><img src="/images/Java/Java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="Java程序运行过程"></p>
<p>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。</p>
<blockquote>
<p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p>
</blockquote>
<p><strong>总结：</strong></p>
<p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>
<h3 id="JDK-和-JRE"><a href="#JDK-和-JRE" class="headerlink" title="JDK 和 JRE"></a>JDK 和 JRE</h3><p>JDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>
<p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>
<p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p>
<h2 id="4-Oracle-JDK-和-OpenJDK-的对比"><a href="#4-Oracle-JDK-和-OpenJDK-的对比" class="headerlink" title="4. Oracle JDK 和 OpenJDK 的对比"></a>4. Oracle JDK 和 OpenJDK 的对比</h2><p>可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么 Oracle 和 OpenJDK 之间是否存在重大差异？下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。</p>
<p>对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。关于 JVM，JDK，JRE 和 OpenJDK 之间的区别，Oracle 博客帖子在 2012 年有一个更详细的答案：</p>
<blockquote>
<p>问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？</p>
<p>答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些封闭的源代码派对组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。</p>
</blockquote>
<p><strong>总结：</strong></p>
<ol>
<li>Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处。详情参见：<a href="https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence">https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence</a> 。</li>
<li>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；</li>
<li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；</li>
<li>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；</li>
<li>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li>
<li>Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</li>
</ol>
<h2 id="5-Java-和-C-的区别"><a href="#5-Java-和-C-的区别" class="headerlink" title="5. Java 和 C++的区别?"></a>5. Java 和 C++的区别?</h2><p>我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来！</p>
<ul>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>
<li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li>
<li><strong>在 C 语言中，字符串或字符数组最后都会有一个额外的字符‘\0’来表示结束。但是，Java 语言中没有结束符这一概念。</strong> 这是一个值得深度思考的问题，具体原因推荐看这篇文章： <a href="https://blog.csdn.net/sszgg2006/article/details/49148189">https://blog.csdn.net/sszgg2006/article/details/49148189</a></li>
</ul>
<h2 id="6-什么是-Java-程序的主类-应用程序和小程序的主类有何不同"><a href="#6-什么是-Java-程序的主类-应用程序和小程序的主类有何不同" class="headerlink" title="6. 什么是 Java 程序的主类 应用程序和小程序的主类有何不同?"></a>6. 什么是 Java 程序的主类 应用程序和小程序的主类有何不同?</h2><p>一个程序中可以有多个类，但只能有一个类是主类。在 Java 应用程序中，这个主类是指包含 main（）方法的类。而在 Java 小程序中，这个主类是一个继承自系统类 JApplet 或 Applet 的子类。应用程序的主类不一定要求是 public 类，但小程序的主类要求必须是 public 类。主类是 Java 程序执行的入口点。</p>
<h2 id="7-Java-应用程序与小程序之间有哪些差别"><a href="#7-Java-应用程序与小程序之间有哪些差别" class="headerlink" title="7. Java 应用程序与小程序之间有哪些差别?"></a>7. Java 应用程序与小程序之间有哪些差别?</h2><p>简单说应用程序是从主线程启动(也就是 <code>main()</code> 方法)。applet 小程序没有 <code>main()</code> 方法，主要是嵌在浏览器页面上运行(调用<code>init()</code>或者<code>run()</code>来启动)，嵌入浏览器这点跟 flash 的小游戏类似。</p>
<h2 id="8-字符型常量和字符串常量的区别"><a href="#8-字符型常量和字符串常量的区别" class="headerlink" title="8. 字符型常量和字符串常量的区别?"></a>8. 字符型常量和字符串常量的区别?</h2><ol>
<li>形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符</li>
<li>含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</li>
<li>占内存大小 字符常量只占 2 个字节; 字符串常量占若干个字节 (<strong>注意： char 在 Java 中占两个字节</strong>)</li>
</ol>
<blockquote>
<p>java 编程思想第四版：2.2.2 节 <img src="/images/Java/Java%E5%90%84%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F.png" alt="img"></p>
</blockquote>
<h2 id="9-构造器-Constructor-是否可被-override"><a href="#9-构造器-Constructor-是否可被-override" class="headerlink" title="9. 构造器 Constructor 是否可被 override?"></a>9. 构造器 Constructor 是否可被 override?</h2><p>Constructor 不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>
<h2 id="10-重载和重写的区别"><a href="#10-重载和重写的区别" class="headerlink" title="10. 重载和重写的区别"></a>10. 重载和重写的区别</h2><blockquote>
<p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p>
<p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>
</blockquote>
<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>
<p>下面是《Java 核心技术》对重载这个概念的介绍：</p>
<p><img src="/images/Java/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E9%87%8D%E8%BD%BD.jpg" alt="img"></p>
<p><strong>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</strong></p>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
<p><strong>综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变</strong></p>
<p><strong>暖心的 Guide 哥最后再来个图标总结一下！</strong></p>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody><tr>
<td>发生范围</td>
<td>同一个类</td>
<td>子类 中</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody></table>
<h2 id="11-Java-面向对象编程三大特性-封装-继承-多态"><a href="#11-Java-面向对象编程三大特性-封装-继承-多态" class="headerlink" title="11. Java 面向对象编程三大特性: 封装 继承 多态"></a>11. Java 面向对象编程三大特性: 封装 继承 多态</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>
</ol>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<p>在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>
<h2 id="12-String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的"><a href="#12-String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的" class="headerlink" title="12. String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?"></a>12. String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</h2><p><strong>可变性</strong></p>
<p>简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以 String 对象是不可变的。</p>
<blockquote>
<p>补充（来自<a href="https://github.com/Snailclimb/JavaGuide/issues/675">issue 675</a>）：在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 <code>private final byte[] value</code>;</p>
</blockquote>
<p>而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p>
<p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractStringBuilder.java</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程安全性</strong></p>
<p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><strong>性能</strong></p>
<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<ol>
<li>操作少量的数据: 适用 String</li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder</li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</li>
</ol>
<h2 id="13-自动装箱与拆箱"><a href="#13-自动装箱与拆箱" class="headerlink" title="13. 自动装箱与拆箱"></a>13. 自动装箱与拆箱</h2><ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<p>更多内容见：<a href="https://www.cnblogs.com/dolphin0520/p/3780005.html">深入剖析 Java 中的装箱和拆箱</a></p>
<h2 id="14-在一个静态方法内调用一个非静态成员为什么是非法的"><a href="#14-在一个静态方法内调用一个非静态成员为什么是非法的" class="headerlink" title="14. 在一个静态方法内调用一个非静态成员为什么是非法的?"></a>14. 在一个静态方法内调用一个非静态成员为什么是非法的?</h2><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p>
<h2 id="15-在-Java-中定义一个不做事且没有参数的构造方法的作用"><a href="#15-在-Java-中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="15. 在 Java 中定义一个不做事且没有参数的构造方法的作用"></a>15. 在 Java 中定义一个不做事且没有参数的构造方法的作用</h2><p>Java 程序在执行子类的构造方法之前，如果没有用 <code>super()</code>来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 <code>super()</code>来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p>
<h2 id="16-import-java-和-javax-有什么区别？"><a href="#16-import-java-和-javax-有什么区别？" class="headerlink" title="16. import java 和 javax 有什么区别？"></a>16. import java 和 javax 有什么区别？</h2><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。</p>
<p>所以，实际上 java 和 javax 没有区别。这都是一个名字。</p>
<h2 id="17-接口和抽象类的区别是什么？"><a href="#17-接口和抽象类的区别是什么？" class="headerlink" title="17. 接口和抽象类的区别是什么？"></a>17. 接口和抽象类的区别是什么？</h2><ol>
<li>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li>
<li>接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。</li>
<li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。</li>
<li>接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。</li>
<li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li>
</ol>
<p>备注：</p>
<ol>
<li>在 JDK8 中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。(详见 issue:<a href="https://github.com/Snailclimb/JavaGuide/issues/146%E3%80%82">https://github.com/Snailclimb/JavaGuide/issues/146。</a></li>
<li>jdk9 的接口被允许定义私有方法 。</li>
</ol>
<p>总结一下 jdk7~jdk9 Java 中接口概念的变化（<a href="https://www.geeksforgeeks.org/private-methods-java-9-interfaces/">相关阅读</a>）：</p>
<ol>
<li>在 jdk 7 或更早版本中，接口里面只能有常量变量和抽象方法。这些接口方法必须由选择实现接口的类实现。</li>
<li>jdk8 的时候接口可以有默认方法和静态方法功能。</li>
<li>Jdk 9 在接口中引入了私有方法和私有静态方法。</li>
</ol>
<h2 id="18-成员变量与局部变量的区别有哪些？"><a href="#18-成员变量与局部变量的区别有哪些？" class="headerlink" title="18. 成员变量与局部变量的区别有哪些？"></a>18. 成员变量与局部变量的区别有哪些？</h2><ol>
<li>从语法形式上看:成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li>
<li>从变量在内存中的存储方式来看:如果成员变量是使用<code>static</code>修饰的，那么这个成员变量是属于类的，如果没有使用<code>static</code>修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li>
<li>从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li>
<li>成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li>
</ol>
<h2 id="19-创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#19-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="19. 创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>19. 创建一个对象用什么运算符?对象实体与对象引用有何不同?</h2><p>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p>
<h2 id="20-什么是方法的返回值-返回值在类的方法里的作用是什么"><a href="#20-什么是方法的返回值-返回值在类的方法里的作用是什么" class="headerlink" title="20. 什么是方法的返回值?返回值在类的方法里的作用是什么?"></a>20. 什么是方法的返回值?返回值在类的方法里的作用是什么?</h2><p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</p>
<h2 id="21-一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么"><a href="#21-一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么" class="headerlink" title="21. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?"></a>21. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?</h2><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p>
<h2 id="22-构造方法有哪些特性？"><a href="#22-构造方法有哪些特性？" class="headerlink" title="22. 构造方法有哪些特性？"></a>22. 构造方法有哪些特性？</h2><ol>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ol>
<h2 id="23-静态方法和实例方法有何不同"><a href="#23-静态方法和实例方法有何不同" class="headerlink" title="23. 静态方法和实例方法有何不同"></a>23. 静态方法和实例方法有何不同</h2><ol>
<li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li>
<li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</li>
</ol>
<h2 id="24-对象的相等与指向他们的引用相等-两者有什么不同"><a href="#24-对象的相等与指向他们的引用相等-两者有什么不同" class="headerlink" title="24. 对象的相等与指向他们的引用相等,两者有什么不同?"></a>24. 对象的相等与指向他们的引用相等,两者有什么不同?</h2><p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p>
<h2 id="25-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是"><a href="#25-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是" class="headerlink" title="25. 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?"></a>25. 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?</h2><p>帮助子类做初始化工作。</p>
<h2 id="26-与-equals-重要"><a href="#26-与-equals-重要" class="headerlink" title="26. == 与 equals(重要)"></a>26. == 与 equals(重要)</h2><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。</p>
<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>
<ul>
<li>情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li>
<li>情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li>
</ul>
<p><strong>举个例子：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aEQb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</li>
<li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li>
</ul>
<h2 id="27-hashCode-与-equals-重要"><a href="#27-hashCode-与-equals-重要" class="headerlink" title="27. hashCode 与 equals (重要)"></a>27. hashCode 与 equals (重要)</h2><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode 方法？”</p>
<h3 id="hashCode（）介绍"><a href="#hashCode（）介绍" class="headerlink" title="hashCode（）介绍"></a>hashCode（）介绍</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。</p>
<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>
<h3 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h3><p><strong>我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</strong> 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与该位置其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals()</code>方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
<p>通过我们可以看出：<code>hashCode()</code> 的作用就是<strong>获取哈希码</strong>，也称为散列码；它实际上是返回一个 int 整数。这个<strong>哈希码的作用</strong>是确定该对象在哈希表中的索引位置。**<code>hashCode()</code>在散列表中才有用，在其它情况下没用**。在散列表中 hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p>
<h3 id="hashCode（）与-equals（）的相关规定"><a href="#hashCode（）与-equals（）的相关规定" class="headerlink" title="hashCode（）与 equals（）的相关规定"></a>hashCode（）与 equals（）的相关规定</h3><ol>
<li>如果两个对象相等，则 hashcode 一定也是相同的</li>
<li>两个对象相等,对两个对象分别调用 equals 方法都返回 true</li>
<li>两个对象有相同的 hashcode 值，它们也不一定是相等的</li>
<li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li>
<li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ol>
<p>推荐阅读：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html">Java hashCode() 和 equals()的若干问题解答</a></p>
<h2 id="28-为什么-Java-中只有值传递？"><a href="#28-为什么-Java-中只有值传递？" class="headerlink" title="28. 为什么 Java 中只有值传递？"></a>28. 为什么 Java 中只有值传递？</h2><p><a href="https://juejin.im/post/5e18879e6fb9a02fc63602e2">为什么 Java 中只有值传递？</a></p>
<h2 id="29-简述线程、程序、进程的基本概念。以及他们之间关系是什么"><a href="#29-简述线程、程序、进程的基本概念。以及他们之间关系是什么" class="headerlink" title="29. 简述线程、程序、进程的基本概念。以及他们之间关系是什么?"></a>29. 简述线程、程序、进程的基本概念。以及他们之间关系是什么?</h2><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>
<p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p>
<h2 id="30-线程有哪些基本状态"><a href="#30-线程有哪些基本状态" class="headerlink" title="30. 线程有哪些基本状态?"></a>30. 线程有哪些基本状态?</h2><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。</p>
<p><img src="/images/Java/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="Java线程的状态"></p>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：</p>
<p><img src="/images/Java/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png" alt="Java线程状态变迁"></p>
<p>由上图可以看出：</p>
<p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p>
<blockquote>
<p>操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinjava.com/">HowToDoInJava</a>：<a href="https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/">Java Thread Life Cycle and Thread States</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p>
</blockquote>
<p><img src="/images/Java/RUNNABLE-VS-RUNNING.png" alt="RUNNABLE-VS-RUNNING"></p>
<p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong>状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p>
<h2 id="31-关于-final-关键字的一些总结"><a href="#31-关于-final-关键字的一些总结" class="headerlink" title="31 关于 final 关键字的一些总结"></a>31 关于 final 关键字的一些总结</h2><p>final 关键字主要用在三个地方：变量、方法、类。</p>
<ol>
<li>对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li>
<li>当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。</li>
<li>使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。类中所有的 private 方法都隐式地指定为 final。</li>
</ol>
<h2 id="32-Java-中的异常处理"><a href="#32-Java-中的异常处理" class="headerlink" title="32 Java 中的异常处理"></a>32 Java 中的异常处理</h2><h3 id="Java-异常类层次结构图"><a href="#Java-异常类层次结构图" class="headerlink" title="Java 异常类层次结构图"></a>Java 异常类层次结构图</h3><p><img src="/images/Java/java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="Java异常类层次结构图"></p>
<p>图片来自：<a href="https://simplesnippets.tech/exception-handling-in-java-part-1/">https://simplesnippets.tech/exception-handling-in-java-part-1/</a></p>
<p><img src="/images/Java/java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE%E4%BA%8C.png" alt="Java异常类层次结构图"></p>
<p>图片来自：<a href="https://chercher.tech/java-programming/exceptions-java">https://chercher.tech/java-programming/exceptions-java</a></p>
<p>在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 <strong>Throwable 类</strong>。Throwable： 有两个重要的子类：<strong>Exception（异常）</strong> 和 <strong>Error（错误）</strong> ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<p><strong>Error（错误）:是程序无法处理的错误</strong>，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java 虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p>
<p>这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如 Java 虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java 中，错误通过 Error 的子类描述。</p>
<p><strong>Exception（异常）:是程序本身可以处理的异常</strong>。Exception 类有一个重要的子类 <strong>RuntimeException</strong>。RuntimeException 异常由 Java 虚拟机抛出。<strong>NullPointerException</strong>（要访问的变量没有引用任何对象时，抛出该异常）、<strong>ArithmeticException</strong>（算术运算异常，一个整数除以 0 时，抛出该异常）和 <strong>ArrayIndexOutOfBoundsException</strong> （下标越界异常）。</p>
<p><strong>注意：异常和错误的区别：异常能被程序本身处理，错误是无法处理。</strong></p>
<h3 id="Throwable-类常用方法"><a href="#Throwable-类常用方法" class="headerlink" title="Throwable 类常用方法"></a>Throwable 类常用方法</h3><ul>
<li><strong>public string getMessage()</strong>:返回异常发生时的简要描述</li>
<li><strong>public string toString()</strong>:返回异常发生时的详细信息</li>
<li><strong>public string getLocalizedMessage()</strong>:返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage（）返回的结果相同</li>
<li><strong>public void printStackTrace()</strong>:在控制台上打印 Throwable 对象封装的异常信息</li>
</ul>
<h3 id="异常处理总结"><a href="#异常处理总结" class="headerlink" title="异常处理总结"></a>异常处理总结</h3><ul>
<li><strong>try 块：</strong> 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li>
<li><strong>catch 块：</strong> 用于处理 try 捕获到的异常。</li>
<li><strong>finally 块：</strong> 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</li>
</ul>
<p><strong>在以下 4 种特殊情况下，finally 块不会被执行：</strong></p>
<ol>
<li>在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行</li>
<li>在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ol>
<p>下面这部分内容来自 issue:<a href="https://github.com/Snailclimb/JavaGuide/issues/190%E3%80%82">https://github.com/Snailclimb/JavaGuide/issues/190。</a></p>
<p><strong>注意：</strong> 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value * value;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用 <code>f(2)</code>，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。</p>
<h2 id="33-Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#33-Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="33 Java 序列化中如果有些字段不想进行序列化，怎么办？"></a>33 Java 序列化中如果有些字段不想进行序列化，怎么办？</h2><p>对于不想进行序列化的变量，使用 transient 关键字修饰。</p>
<p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。</p>
<h2 id="34-获取用键盘输入常用的两种方法"><a href="#34-获取用键盘输入常用的两种方法" class="headerlink" title="34 获取用键盘输入常用的两种方法"></a>34 获取用键盘输入常用的两种方法</h2><p>方法 1：通过 Scanner</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s  = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>

<p>方法 2：通过 BufferedReader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();</span><br></pre></td></tr></table></figure>

<h2 id="35-Java-中-IO-流"><a href="#35-Java-中-IO-流" class="headerlink" title="35 Java 中 IO 流"></a>35 Java 中 IO 流</h2><h3 id="Java-中-IO-流分为几种"><a href="#Java-中-IO-流分为几种" class="headerlink" title="Java 中 IO 流分为几种?"></a>Java 中 IO 流分为几种?</h3><ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<p>Java Io 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<p>按操作方式分类结构图：</p>
<p><img src="/images/Java/IO-%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB.jpg" alt="IO-操作方式分类"></p>
<p>按操作对象分类结构图：</p>
<p><img src="/images/Java/IO-%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB.jpg" alt="IO-操作对象分类"></p>
<h3 id="既然有了字节流-为什么还要有字符流"><a href="#既然有了字节流-为什么还要有字符流" class="headerlink" title="既然有了字节流,为什么还要有字符流?"></a>既然有了字节流,为什么还要有字符流?</h3><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p>
<p>回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
<h3 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="BIO,NIO,AIO 有什么区别?"></a>BIO,NIO,AIO 有什么区别?</h3><ul>
<li><strong>BIO (Blocking I/O):</strong> 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li>
<li><strong>NIO (Non-blocking/New I/O):</strong> NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li>
<li><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li>
</ul>
<h2 id="36-常见关键字总结-static-final-this-super"><a href="#36-常见关键字总结-static-final-this-super" class="headerlink" title="36. 常见关键字总结:static,final,this,super"></a>36. 常见关键字总结:static,final,this,super</h2><p>详见笔主的这篇文章: <a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basic/final,static,this,super">https://snailclimb.gitee.io/javaguide/#/docs/java/basic/final,static,this,super</a></p>
<h2 id="37-Collections-工具类和-Arrays-工具类常见方法总结"><a href="#37-Collections-工具类和-Arrays-工具类常见方法总结" class="headerlink" title="37. Collections 工具类和 Arrays 工具类常见方法总结"></a>37. Collections 工具类和 Arrays 工具类常见方法总结</h2><p>详见笔主的这篇文章: <a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/basic/Arrays,CollectionsCommonMethods.md">https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/basic/Arrays,CollectionsCommonMethods.md</a></p>
<h2 id="38-深拷贝-vs-浅拷贝"><a href="#38-深拷贝-vs-浅拷贝" class="headerlink" title="38. 深拷贝 vs 浅拷贝"></a>38. 深拷贝 vs 浅拷贝</h2><ol>
<li><strong>浅拷贝</strong>：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li>
<li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li>
</ol>
<p><img src="/images/Java/java-deep-and-shallow-copy.jpg" alt="deep and shallow copy"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre">https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre</a></li>
<li><a href="https://www.educba.com/oracle-vs-openjdk/">https://www.educba.com/oracle-vs-openjdk/</a></li>
<li><a href="https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk?answertab=active#tab-top">https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk?answertab=active#tab-top</a></li>
</ul>
<h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p>
<p><strong>《Java 面试突击》:</strong> 由本文档衍生的专为面试而生的《Java 面试突击》V2.0 PDF 版本<a href="#%E5%85%AC%E4%BC%97%E5%8F%B7">公众号</a>后台回复 <strong>“Java 面试突击”</strong> 即可免费领取！</p>
<p><strong>Java 工程师必备学习资源:</strong> 一些 Java 工程师常用学习资源公众号后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。</p>
<p><img src="/images/Java/JavaGuide.jpg" alt="我的公众号"></p>
<p><strong>全文转载自：</strong><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>知识整理</category>
      </categories>
  </entry>
  <entry>
    <title>ElasticSearch(二)</title>
    <url>/2021/02/04/202124-ElasticSearch(%E4%BA%8C)/</url>
    <content><![CDATA[<p>ElasticSearch 是一个开源的高扩展的分布式全文检索引擎</p>
<span id="more"></span>

<h2 id="编程应用"><a href="#编程应用" class="headerlink" title="编程应用"></a>编程应用</h2><h3 id="1-1创建工程，导入坐标"><a href="#1-1创建工程，导入坐标" class="headerlink" title="1.1创建工程，导入坐标"></a>1.1创建工程，导入坐标</h3><p>pom.xml坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.6.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>transport<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.6.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-to-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-simple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2创建索引index"><a href="#1-2创建索引index" class="headerlink" title="1.2创建索引index"></a>1.2创建索引index</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//创建索引</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 创建Client连接对象</span></span><br><span class="line">    Settings settings = Settings.builder().put(<span class="string">&quot;cluster.name&quot;</span>, <span class="string">&quot;my-elasticsearch&quot;</span>).build();</span><br><span class="line">    TransportClient client = <span class="keyword">new</span> PreBuiltTransportClient(settings)</span><br><span class="line">        .addTransportAddress(<span class="keyword">new</span> InetSocketTransportAddress(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">9300</span>));</span><br><span class="line">    <span class="comment">//创建名称为blog2的索引</span></span><br><span class="line">    client.admin().indices().prepareCreate(<span class="string">&quot;blog2&quot;</span>).get();</span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3创建映射mapping"><a href="#1-3创建映射mapping" class="headerlink" title="1.3创建映射mapping"></a>1.3创建映射mapping</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//创建映射</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 创建Client连接对象</span></span><br><span class="line">    Settings settings = Settings.builder().put(<span class="string">&quot;cluster.name&quot;</span>, <span class="string">&quot;my-elasticsearch&quot;</span>).build();</span><br><span class="line">    TransportClient client = <span class="keyword">new</span> PreBuiltTransportClient(settings)</span><br><span class="line">        .addTransportAddress(<span class="keyword">new</span> InetSocketTransportAddress(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">9300</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加映射</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 格式：</span></span><br><span class="line"><span class="comment">         * &quot;mappings&quot; : &#123;</span></span><br><span class="line"><span class="comment">             &quot;article&quot; : &#123;</span></span><br><span class="line"><span class="comment">                &quot;dynamic&quot; : &quot;false&quot;,</span></span><br><span class="line"><span class="comment">                 &quot;properties&quot; : &#123;</span></span><br><span class="line"><span class="comment">                    &quot;id&quot; : &#123; &quot;type&quot; : &quot;string&quot; &#125;,</span></span><br><span class="line"><span class="comment">                     &quot;content&quot; : &#123; &quot;type&quot; : &quot;string&quot; &#125;,</span></span><br><span class="line"><span class="comment">                    &quot;author&quot; : &#123; &quot;type&quot; : &quot;string&quot; &#125;</span></span><br><span class="line"><span class="comment">                 &#125;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">         &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    XContentBuilder builder = XContentFactory.jsonBuilder()</span><br><span class="line">        .startObject()</span><br><span class="line">        .startObject(<span class="string">&quot;article&quot;</span>)</span><br><span class="line">        .startObject(<span class="string">&quot;properties&quot;</span>)</span><br><span class="line">        .startObject(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">        .field(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;integer&quot;</span>).field(<span class="string">&quot;store&quot;</span>, <span class="string">&quot;yes&quot;</span>)</span><br><span class="line">        .endObject()</span><br><span class="line">        .startObject(<span class="string">&quot;title&quot;</span>)</span><br><span class="line">        .field(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;string&quot;</span>).field(<span class="string">&quot;store&quot;</span>, <span class="string">&quot;yes&quot;</span>).field(<span class="string">&quot;analyzer&quot;</span>, <span class="string">&quot;ik_smart&quot;</span>)</span><br><span class="line">        .endObject()</span><br><span class="line">        .startObject(<span class="string">&quot;content&quot;</span>)</span><br><span class="line">        .field(<span class="string">&quot;type&quot;</span>, <span class="string">&quot;string&quot;</span>).field(<span class="string">&quot;store&quot;</span>, <span class="string">&quot;yes&quot;</span>).field(<span class="string">&quot;analyzer&quot;</span>, <span class="string">&quot;ik_smart&quot;</span>)</span><br><span class="line">        .endObject()</span><br><span class="line">        .endObject()</span><br><span class="line">        .endObject()</span><br><span class="line">        .endObject();</span><br><span class="line">    <span class="comment">// 创建映射</span></span><br><span class="line">    PutMappingRequest mapping = Requests.putMappingRequest(<span class="string">&quot;blog2&quot;</span>)</span><br><span class="line">        .type(<span class="string">&quot;article&quot;</span>).source(builder);</span><br><span class="line">    client.admin().indices().putMapping(mapping).get();</span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4建立文档document"><a href="#1-4建立文档document" class="headerlink" title="1.4建立文档document"></a>1.4建立文档document</h3><ul>
<li>通过XContentBuilder</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//创建文档(通过XContentBuilder)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">   <span class="comment">// 创建Client连接对象</span></span><br><span class="line">   Settings settings = Settings.builder().put(<span class="string">&quot;cluster.name&quot;</span>, <span class="string">&quot;my-elasticsearch&quot;</span>).build();</span><br><span class="line">   TransportClient client = <span class="keyword">new</span> PreBuiltTransportClient(settings)</span><br><span class="line">      .addTransportAddress(<span class="keyword">new</span> InetSocketTransportAddress(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">9300</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">//创建文档信息</span></span><br><span class="line">   XContentBuilder builder = XContentFactory.jsonBuilder()</span><br><span class="line">      .startObject()</span><br><span class="line">      .field(<span class="string">&quot;id&quot;</span>, <span class="number">1</span>)</span><br><span class="line">      .field(<span class="string">&quot;title&quot;</span>, <span class="string">&quot;ElasticSearch是一个基于Lucene的搜索服务器&quot;</span>)</span><br><span class="line">      .field(<span class="string">&quot;content&quot;</span>,</span><br><span class="line">              <span class="string">&quot;它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口。Elasticsearch是用Java开发的，并作为Apache许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。&quot;</span>)</span><br><span class="line">      .endObject();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 建立文档对象</span></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 参数一blog2：表示索引对象</span></span><br><span class="line"><span class="comment">        * 参数二article：类型</span></span><br><span class="line"><span class="comment">        * 参数三1：建立id</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">   client.prepareIndex(<span class="string">&quot;blog2&quot;</span>, <span class="string">&quot;article&quot;</span>, <span class="string">&quot;1&quot;</span>).setSource(builder).get();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//释放资源</span></span><br><span class="line">   client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>通过Jackson转换实体<br> 1）创建Article实体</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Article</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Integer id;</span><br><span class="line">   <span class="keyword">private</span> String title;</span><br><span class="line">   <span class="keyword">private</span> String content;</span><br><span class="line">   getter/setter...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）添加Jackson坐标</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3）代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//创建文档(通过实体转json)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 创建Client连接对象</span></span><br><span class="line">    Settings settings = Settings.builder().put(<span class="string">&quot;cluster.name&quot;</span>, <span class="string">&quot;my-elasticsearch&quot;</span>).build();</span><br><span class="line">    TransportClient client = <span class="keyword">new</span> PreBuiltTransportClient(settings)</span><br><span class="line">        .addTransportAddress(<span class="keyword">new</span> InetSocketTransportAddress(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">9300</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 描述json 数据</span></span><br><span class="line">    <span class="comment">//&#123;id:xxx, title:xxx, content:xxx&#125;</span></span><br><span class="line">    Article article = <span class="keyword">new</span> Article();</span><br><span class="line">    article.setId(<span class="number">2</span>);</span><br><span class="line">    article.setTitle(<span class="string">&quot;搜索工作其实很快乐&quot;</span>);</span><br><span class="line">    article.setContent(<span class="string">&quot;我们希望我们的搜索解决方案要快，我们希望有一个零配置和一个完全免费的搜索模式，我们希望能够简单地使用JSON通过HTTP的索引数据，我们希望我们的搜索服务器始终可用，我们希望能够一台开始并扩展到数百，我们要实时搜索，我们要简单的多租户，我们希望建立一个云的解决方案。Elasticsearch旨在解决所有这些问题和更多的问题。&quot;</span>);</span><br><span class="line"></span><br><span class="line">    ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立文档</span></span><br><span class="line">    client.prepareIndex(<span class="string">&quot;blog2&quot;</span>, <span class="string">&quot;article&quot;</span>, article.getId().toString())</span><br><span class="line">        <span class="comment">//.setSource(objectMapper.writeValueAsString(article)).get();</span></span><br><span class="line">        .setSource(objectMapper.writeValueAsString(article).getBytes(), XContentType.JSON).get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5查询文档操作"><a href="#1-5查询文档操作" class="headerlink" title="1.5查询文档操作"></a>1.5查询文档操作</h3><ul>
<li>关键词查询 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTermQuery</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//1.创建es客户端连接对象</span></span><br><span class="line">    Settings settings = Settings.builder().put(<span class="string">&quot;cluster.name&quot;</span>,<span class="string">&quot;my-elasticsearch&quot;</span>).build();</span><br><span class="line">    TransportClient client = <span class="keyword">new</span> PreBuiltTransportClient(settings)</span><br><span class="line">        					.addTransportAddress(<span class="keyword">new</span> InetSocketTransportAddress(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">9300</span>));</span><br><span class="line">    <span class="comment">//2.设置搜索条件</span></span><br><span class="line">    SearchResponse searchResponse = client.prepareSearch(<span class="string">&quot;blog2&quot;</span>)</span><br><span class="line">        							.setTypes(<span class="string">&quot;article&quot;</span>)</span><br><span class="line">        							.setQuery(QueryBuilders.termQuery(<span class="string">&quot;content&quot;</span>,<span class="string">&quot;搜索&quot;</span>)).get();</span><br><span class="line">    <span class="comment">//3.遍历搜索结果数据</span></span><br><span class="line">    SearchHits hits = searchResponse.getHits(); <span class="comment">//获取命中次数，查询结果有多少对象</span></span><br><span class="line">    System.out.println(<span class="string">&quot;查询结果有：&quot;</span> + hits.getTotalHits() + <span class="string">&quot;条&quot;</span>);</span><br><span class="line">    Iterator&lt;SearchHit&gt; iterator = hits.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">        SearchHit searchHit = iterator.next(); <span class="comment">//每个查询对象</span></span><br><span class="line">        System.out.println(searchHit.getSourceAsString()); <span class="comment">//获取字符串格式打印</span></span><br><span class="line">        System.out.println(<span class="string">&quot;title:&quot;</span> + searchHit.getSource().get(<span class="string">&quot;title&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.释放资源</span></span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>字符串查询 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.设置搜索条件</span></span><br><span class="line">SearchResponse searchResponse = client.prepareSearch(<span class="string">&quot;blog2&quot;</span>)</span><br><span class="line">    							.setTypes(<span class="string">&quot;article&quot;</span>)</span><br><span class="line">    							.setQuery(QueryBuilders.queryStringQuery(<span class="string">&quot;搜索&quot;</span>)).get();</span><br></pre></td></tr></table></figure>

<ul>
<li>文档ID查询 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//client对象为TransportClient对象</span></span><br><span class="line">SearchResponse response = client.prepareSearch(<span class="string">&quot;blog1&quot;</span>)</span><br><span class="line">    						.setTypes(<span class="string">&quot;article&quot;</span>)</span><br><span class="line">    						<span class="comment">//设置要查询的id</span></span><br><span class="line">    						.setQuery(QueryBuilders.idsQuery().addIds(<span class="string">&quot;test002&quot;</span>))</span><br><span class="line">    						<span class="comment">//执行查询</span></span><br><span class="line">    						.get();</span><br><span class="line"><span class="comment">//取查询结果</span></span><br><span class="line">SearchHits searchHits = response.getHits();</span><br><span class="line"><span class="comment">//取查询结果</span></span><br><span class="line">System.out.println(searchHtis.getTotalHits());</span><br><span class="line">Iterator&lt;SearchHit&gt; hitIterator = searchHits.iterator();</span><br><span class="line"><span class="keyword">while</span>(hitIterator.hasNext()) [</span><br><span class="line">    SearchHit searchHit = hitIterator.next();</span><br><span class="line">    <span class="comment">//打印整行数据</span></span><br><span class="line">    System.out.println(searchHit.getSourceAsString());</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="1-6查询文档分页操作"><a href="#1-6查询文档分页操作" class="headerlink" title="1.6查询文档分页操作"></a>1.6查询文档分页操作</h3><ul>
<li>批量插入数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//批量插入100条数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test9</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//创建Client连接对象</span></span><br><span class="line">    Settings settings = Settings.builder().put(<span class="string">&quot;cluster.name&quot;</span>, <span class="string">&quot;my-elasticsearch&quot;</span>).build();</span><br><span class="line">    TransportClient client = <span class="keyword">new</span> PreBuiltTransportClient(settings)</span><br><span class="line">    						.addTransportAddress(<span class="keyword">new</span> InetSocketTransportAddress(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>)，<span class="number">9300</span>);</span><br><span class="line">    objectMapper objectMapper = <span class="keyword">new</span> objectMapper();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)|&#123;</span><br><span class="line">        <span class="comment">//描述json数据</span></span><br><span class="line">        Article article = <span class="keyword">new</span> Article();</span><br><span class="line">        article.setId(i);</span><br><span class="line">        article.setTitle(i + <span class="string">&quot;搜索工作其实很快乐&quot;</span> );</span><br><span class="line">        article.setContent(i +<span class="string">&quot;我们希望我们的搜索解决方案要快，我们希望有一个零配置和一个完全免费的搜索模式,我们希望能够简单地使用JSON通过HTTP的索引数据，我们希望我们的搜索服务器始终可用，我们希望能够一台开始井扩展到数百，我们要实时搜索，我们要简单的多租户，我们希望建立一个云的解决方案。Elasticsearch旨在解决所有这些问题和更多的问题。&quot;</span>);</span><br><span class="line">        <span class="comment">//建立文档</span></span><br><span class="line">        client.prepareIndex(<span class="string">&quot;blog2&quot;</span>,<span class="string">&quot;article&quot;</span>,article.getId().toString())</span><br><span class="line">            	<span class="comment">//.setSource(objectMapper.writeValueAsString(article)).get();</span></span><br><span class="line">            	.setSource(objectMapper.writeValueAsString(article).getBytes(),XContentType.JSON).get();</span><br><span class="line">    &#125;</span><br><span class="line"> 	<span class="comment">//释放资源</span></span><br><span class="line"> 	client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/ES/blog2_article.png" alt="img"></p>
<ul>
<li>分页查询 </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//搜索</span></span><br><span class="line">SearchRequestBuilder searchRequestBuilder = client.prepareSearch(<span class="string">&quot;blog2&quot;</span>).setTypes(<span class="string">&quot;article&quot;</span>)</span><br><span class="line">										    	.setQuery(QueryBuilders.matchAllQuery());</span><br><span class="line"><span class="comment">//查询第2页数据，每页20条</span></span><br><span class="line"><span class="comment">//setFrom():从第几页开始检索，默认是0</span></span><br><span class="line"><span class="comment">//setSize():每页最多显示的记录数</span></span><br><span class="line">searchRequestBuilder.setFrom(<span class="number">0</span>).setSize(<span class="number">5</span>);</span><br><span class="line">SearchResponse searchResponse = searchRequestBuilder.get();</span><br><span class="line"></span><br><span class="line">SearchHits hits = searchResponse.getHits(); <span class="comment">//获取命中次数，查询结果有多少对象</span></span><br><span class="line">System.out.println(<span class="string">&quot;查询结果有:&quot;</span> + hits.getTotalHits() + <span class="string">&quot;条&quot;</span>);</span><br><span class="line">Iterator&lt;SearchHit&gt; iterator = hits.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">    SearchHit searchHit = iterator.next(); <span class="comment">//每个查询对象</span></span><br><span class="line">    System.out.println(searchHit.getSourceAsString()); <span class="comment">//获取字符串格式打印</span></span><br><span class="line">    System.out.println(<span class="string">&quot;id:&quot;</span> + searchHit.getSource().get(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;title:&quot;</span> + searchHit.getSource().get(<span class="string">&quot;title&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;content:&quot;</span> + searchHit.getSource().get(<span class="string">&quot;content&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;---------------------------------------------------&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7查询结果高亮操作"><a href="#1-7查询结果高亮操作" class="headerlink" title="1.7查询结果高亮操作"></a>1.7查询结果高亮操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//高亮查询</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test11</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">// 创建Client连接对象</span></span><br><span class="line">    Settings settings = Settings.builder().put(<span class="string">&quot;cluster.name&quot;</span>, <span class="string">&quot;my-elasticsearch&quot;</span>).build();</span><br><span class="line">    TransportClient client = <span class="keyword">new</span> PreBuiltTransportClient(settings)</span><br><span class="line">        .addTransportAddress(<span class="keyword">new</span> InetSocketTransportAddress(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>), <span class="number">9300</span>));</span><br><span class="line">	<span class="comment">//搜索数据</span></span><br><span class="line">    SearchRequestBuilder searchRequestBuilder = client</span><br><span class="line">        										.prepareSearch(<span class="string">&quot;blog2&quot;</span>).setTypes(<span class="string">&quot;article&quot;</span>)</span><br><span class="line">        										.setQuery(QueryBuilders.termQuery(<span class="string">&quot;title&quot;</span>,<span class="string">&quot;搜索&quot;</span>));</span><br><span class="line">    <span class="comment">//设置高亮数据</span></span><br><span class="line">    HighlightBuilder hiBuilder = <span class="keyword">new</span> HighlightBuilder();</span><br><span class="line">    hiBuilder.preTags(<span class="string">&quot;&lt;font style=&#x27;color:red&#x27;&gt;&quot;</span>);</span><br><span class="line">    hiBuilder.postTags(<span class="string">&quot;&lt;/font&gt;&quot;</span>);</span><br><span class="line">    hiBuilder.field(<span class="string">&quot;title&quot;</span>);</span><br><span class="line">    searchRequestBuilder.highlighter(hiBuilder);</span><br><span class="line">    <span class="comment">//获得查询结果数据</span></span><br><span class="line">    SearchResponse searchResponse = searchRequestBuilder.get();</span><br><span class="line">    <span class="comment">//获取查询结果集</span></span><br><span class="line">    SearchHits searchHits = searchResponse.getHits();</span><br><span class="line">    System.out.println(<span class="string">&quot;共搜到：&quot;</span> + searchHits.getTotalHits() + <span class="string">&quot;条结果！&quot;</span>);</span><br><span class="line">    <span class="comment">//遍历结果</span></span><br><span class="line">    <span class="keyword">for</span>(SearchHit hit : searchHits) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;String方式打印文档搜索内容：&quot;</span>);</span><br><span class="line">        System.out.println(hit.getSourceAsString());</span><br><span class="line">        System.out.println(<span class="string">&quot;Map方式打印高亮内容：&quot;</span>);</span><br><span class="line">        System.out.println(hit.getHighlightFields());</span><br><span class="line">        </span><br><span class="line">        System.out.pringln(<span class="string">&quot;遍历高亮集合，打印高亮片段:&quot;</span>);</span><br><span class="line">        Text[] text = hit.getHighlightFields().get(<span class="string">&quot;title&quot;</span>).getFragments();</span><br><span class="line">        <span class="keyword">for</span>(Text str : text) &#123;</span><br><span class="line">            System.out.println(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放资源</span></span><br><span class="line">    client.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-Data-ElasticSearch"><a href="#Spring-Data-ElasticSearch" class="headerlink" title="Spring Data ElasticSearch"></a>Spring Data ElasticSearch</h2><h3 id="what"><a href="#what" class="headerlink" title="what?"></a>what?</h3><p><strong>springdata简介</strong></p>
<p>Spring Data是一个用于简化数据库访问，并支持云服务的开源框架。其主要目标是使得对数据的访问变得方便快捷，并支持map-reduce框架和云计算数据服务。 Spring Data可以极大的简化JPA的写法，可以在几乎不用写实现的情况下，实现对数据的访问和操作。除了CRUD外，还包括如分页、排序等一些常用的功能。</p>
<p>官网：<a href="http://projects.spring.io/spring-data/">http://projects.spring.io/spring-data/</a> </p>
<p>常用功能模块： </p>
<p><img src="/images/ES/SpringDataES.png" alt="SpringDataES"></p>
<p><strong>什么是springdata elasticsearch</strong></p>
<p>Spring Data ElasticSearch 基于 spring data API 简化 elasticSearch操作，将原始操作elasticSearch的客户端API 进行封装 。Spring Data为Elasticsearch项目提供集成搜索引擎。Spring Data Elasticsearch POJO的关键功能区域为中心的模型与Elastichsearch交互文档和轻松地编写一个存储库数据访问层。<br>官网：<a href="http://projects.spring.io/spring-data-elasticsearch/">http://projects.spring.io/spring-data-elasticsearch/</a></p>
<h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>1）导入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.itheima<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itheima_elasticsearch_demo3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.6.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.client<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>transport<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.6.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-to-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.24<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-simple<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.data<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-data-elasticsearch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.elasticsearch.plugin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>transport-netty4-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2）创建applicationContext.xml配置文件，引入elasticsearch命名空间</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:elasticsearch</span>=<span class="string">&quot;http://www.springframework.org/schema/data/elasticsearch&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/data/elasticsearch</span></span></span><br><span class="line"><span class="string"><span class="tag">        http://www.springframework.org/schema/data/elasticsearch/spring-elasticsearch-1.0.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">        &quot;</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>3）编写实体article</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Article</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Article [id=&quot;</span> + id + <span class="string">&quot;, title=&quot;</span> + title + <span class="string">&quot;, content=&quot;</span> + content + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4）编写dao</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Article;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.repository.ElasticsearchRepository;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArticleRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Article</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5）编写service</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Article;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArticleService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Article article)</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.itheima.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.dao.ArticleRepository;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Article;</span><br><span class="line"><span class="keyword">import</span> com.itheima.service.ArticleService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleServiceImpl</span> <span class="keyword">implements</span> <span class="title">ArticleService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ArticleRepository articleRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Article article)</span> </span>&#123;</span><br><span class="line">        articleRepository.save(article);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6）配置applicationContext.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 扫描Dao包，自动创建实例 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">elasticsearch:repositories</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima.dao&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 扫描Service包，创建Service的实体 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.itheima.service&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置elasticSearch的连接 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">elasticsearch:transport-client</span> <span class="attr">id</span>=<span class="string">&quot;client&quot;</span> <span class="attr">cluster-nodes</span>=<span class="string">&quot;localhost:9300&quot;</span> <span class="attr">cluster-name</span>=<span class="string">&quot;my-elasticsearch&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- ElasticSearch模版对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;elasticsearchTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.data.elasticsearch.core.ElasticsearchTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;client&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;client&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>7）配置实体 基于springdataelasticsearch注解配置索引、映射和实体的关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@Document 文档对象 （索引信息、文档类型 ）</span></span><br><span class="line"><span class="meta">@Document(indexName=&quot;blog3&quot;,type=&quot;article&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Article</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@Id 文档主键 唯一标识</span></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="comment">//@Field 每个文档的字段配置（类型、是否分词、是否存储、分词器 ）</span></span><br><span class="line">    <span class="meta">@Field(store=true, index = false,type = FieldType.Integer)</span></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@Field(index=true,analyzer=&quot;ik_smart&quot;,store=true,searchAnalyzer=&quot;ik_smart&quot;,type = FieldType.text)</span></span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="meta">@Field(index=true,analyzer=&quot;ik_smart&quot;,store=true,searchAnalyzer=&quot;ik_smart&quot;,type = FieldType.text)</span></span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTitle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTitle</span><span class="params">(String title)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContent</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Article [id=&quot;</span> + id + <span class="string">&quot;, title=&quot;</span> + title + <span class="string">&quot;, content=&quot;</span> + content + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，注解解释如下：<br><strong>@Document(indexName=”blob3”,type=”article”)：</strong><br>    indexName：索引的名称（必填项）<br>    type：索引的类型<br><strong>@Id：</strong>主键的唯一标识<br><strong>@Field(index=true,analyzer=”ik_smart”,store=true,searchAnalyzer=”ik_smart”,type = FieldType.text)</strong><br>    index：是否设置分词<br>    analyzer：存储时使用的分词器<br>    searchAnalyze：搜索时使用的分词器<br>    store：是否存储<br>    type: 数据类型</p>
<p>8）创建测试类SpringDataESTest</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Article;</span><br><span class="line"><span class="keyword">import</span> com.itheima.service.ArticleService;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.transport.TransportClient;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.core.ElasticsearchTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations=&quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDataESTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ArticleService articleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TransportClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ElasticsearchTemplate elasticsearchTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**创建索引和映射*/</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        elasticsearchTemplate.createIndex(Article.class);</span><br><span class="line">        elasticsearchTemplate.putMapping(Article.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**测试保存文档*/</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveArticle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Article article = <span class="keyword">new</span> Article();</span><br><span class="line">        article.setId(<span class="number">100</span>);</span><br><span class="line">        article.setTitle(<span class="string">&quot;测试SpringData ElasticSearch&quot;</span>);</span><br><span class="line">        article.setContent(<span class="string">&quot;Spring Data ElasticSearch 基于 spring data API 简化 elasticSearch操作，将原始操作elasticSearch的客户端API 进行封装 \n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    Spring Data为Elasticsearch Elasticsearch项目提供集成搜索引擎&quot;</span>);</span><br><span class="line">        articleService.save(article);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h3><p>1.增删改查方法测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Article;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Pageable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArticleService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Article article)</span></span>;</span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Article article)</span></span>;</span><br><span class="line">    <span class="comment">//查询全部</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Article&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//分页查询</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Page&lt;Article&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.dao.ArticleRepository;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Article;</span><br><span class="line"><span class="keyword">import</span> com.itheima.service.ArticleService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Pageable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleServiceImpl</span> <span class="keyword">implements</span> <span class="title">ArticleService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ArticleRepository articleRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Article article)</span> </span>&#123;</span><br><span class="line">        articleRepository.save(article);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(Article article)</span> </span>&#123;</span><br><span class="line">        articleRepository.delete(article);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Article&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Iterable&lt;Article&gt; iter = articleRepository.findAll();</span><br><span class="line">        <span class="keyword">return</span> iter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Page&lt;Article&gt; <span class="title">findAll</span><span class="params">(Pageable pageable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> articleRepository.findAll(pageable);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> com.itheima.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Article;</span><br><span class="line"><span class="keyword">import</span> com.itheima.service.ArticleService;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.transport.TransportClient;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.PageRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Pageable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.core.ElasticsearchTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations=&quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDataESTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ArticleService articleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TransportClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ElasticsearchTemplate elasticsearchTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**创建索引和映射*/</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createIndex</span><span class="params">()</span></span>&#123;</span><br><span class="line">        elasticsearchTemplate.createIndex(Article.class);</span><br><span class="line">        elasticsearchTemplate.putMapping(Article.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**测试保存文档*/</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveArticle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Article article = <span class="keyword">new</span> Article();</span><br><span class="line">        article.setId(<span class="number">100</span>);</span><br><span class="line">        article.setTitle(<span class="string">&quot;测试SpringData ElasticSearch&quot;</span>);</span><br><span class="line">        article.setContent(<span class="string">&quot;Spring Data ElasticSearch 基于 spring data API 简化 elasticSearch操作，将原始操作elasticSearch的客户端API 进行封装 \n&quot;</span> +</span><br><span class="line">                <span class="string">&quot;    Spring Data为Elasticsearch Elasticsearch项目提供集成搜索引擎&quot;</span>);</span><br><span class="line">        articleService.save(article);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**测试保存*/</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Article article = <span class="keyword">new</span> Article();</span><br><span class="line">        article.setId(<span class="number">1001</span>);</span><br><span class="line">        article.setTitle(<span class="string">&quot;elasticSearch 3.0版本发布&quot;</span>);</span><br><span class="line">        article.setContent(<span class="string">&quot;ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口&quot;</span>);</span><br><span class="line">        articleService.save(article);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**测试更新*/</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Article article = <span class="keyword">new</span> Article();</span><br><span class="line">        article.setId(<span class="number">1001</span>);</span><br><span class="line">        article.setTitle(<span class="string">&quot;elasticSearch 3.0版本发布...更新&quot;</span>);</span><br><span class="line">        article.setContent(<span class="string">&quot;ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口&quot;</span>);</span><br><span class="line">        articleService.save(article);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**测试删除*/</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Article article = <span class="keyword">new</span> Article();</span><br><span class="line">        article.setId(<span class="number">1001</span>);</span><br><span class="line">        articleService.delete(article);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**批量插入*/</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save100</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">100</span>;i++)&#123;</span><br><span class="line">            Article article = <span class="keyword">new</span> Article();</span><br><span class="line">            article.setId(i);</span><br><span class="line">            article.setTitle(i+<span class="string">&quot;elasticSearch 3.0版本发布..，更新&quot;</span>);</span><br><span class="line">            article.setContent(i+<span class="string">&quot;ElasticSearch是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful web接口&quot;</span>);</span><br><span class="line">            articleService.save(article);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**分页查询*/</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findAllPage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Pageable pageable = PageRequest.of(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">        Page&lt;Article&gt; page = articleService.findAll(pageable);</span><br><span class="line">        <span class="keyword">for</span>(Article article:page.getContent())&#123;</span><br><span class="line">            System.out.println(article);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>2.常用查询命名规则</p>
<table>
<thead>
<tr>
<th>关键字</th>
<th>命名规则</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>and</td>
<td>findByField1AndField2</td>
<td>根据Field1和Field2获得数据</td>
<td>findByTitleAndContent</td>
</tr>
<tr>
<td>or</td>
<td>findByField1OrField2</td>
<td>根据Field1或Field2获得数据</td>
<td>findByTitleOrContent</td>
</tr>
<tr>
<td>is</td>
<td>findByField</td>
<td>根据Field获得数据</td>
<td>findByTitle</td>
</tr>
<tr>
<td>not</td>
<td>findByFieldNot</td>
<td>根据Field获得补集数据</td>
<td>findByTitleNot</td>
</tr>
<tr>
<td>between</td>
<td>findByFieldBetween</td>
<td>获得指定范围的数据</td>
<td>findByPriceBetween</td>
</tr>
<tr>
<td>lessThanEqual</td>
<td>findByFieldLessThan</td>
<td>获得小于等于指定值的数据</td>
<td>findByPriceLessThan</td>
</tr>
</tbody></table>
<p>3.查询方法测试</p>
<p>1）dao层实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Article;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Pageable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.repository.ElasticsearchRepository;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArticleRepository</span> <span class="keyword">extends</span> <span class="title">ElasticsearchRepository</span>&lt;<span class="title">Article</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//根据标题查询</span></span><br><span class="line">    <span class="function">List&lt;Article&gt; <span class="title">findByTitle</span><span class="params">(String condition)</span></span>;</span><br><span class="line">    <span class="comment">//根据标题查询(含分页)</span></span><br><span class="line">    <span class="function">Page&lt;Article&gt; <span class="title">findByTitle</span><span class="params">(String condition, Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2）service层实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ArticleService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据标题查询</span></span><br><span class="line">    <span class="function">List&lt;Article&gt; <span class="title">findByTitle</span><span class="params">(String condition)</span></span>;</span><br><span class="line">    <span class="comment">//根据标题查询(含分页)</span></span><br><span class="line">    <span class="function">Page&lt;Article&gt; <span class="title">findByTitle</span><span class="params">(String condition, Pageable pageable)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">package</span> com.itheima.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.dao.ArticleRepository;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Article;</span><br><span class="line"><span class="keyword">import</span> com.itheima.service.ArticleService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Pageable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArticleServiceImpl</span> <span class="keyword">implements</span> <span class="title">ArticleService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ArticleRepository articleRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Article&gt; <span class="title">findByTitle</span><span class="params">(String condition)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> articleRepository.findByTitle(condition);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Page&lt;Article&gt; <span class="title">findByTitle</span><span class="params">(String condition, Pageable pageable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> articleRepository.findByTitle(condition,pageable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3）测试代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Article;</span><br><span class="line"><span class="keyword">import</span> com.itheima.service.ArticleService;</span><br><span class="line"><span class="keyword">import</span> org.elasticsearch.client.transport.TransportClient;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Page;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.PageRequest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.domain.Pageable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.elasticsearch.core.ElasticsearchTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(SpringJUnit4ClassRunner.class)</span></span><br><span class="line"><span class="meta">@ContextConfiguration(locations=&quot;classpath:applicationContext.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringDataESTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ArticleService articleService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TransportClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ElasticsearchTemplate elasticsearchTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**条件查询*/</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findByTitle</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String condition = <span class="string">&quot;版本&quot;</span>;</span><br><span class="line">        List&lt;Article&gt; articleList = articleService.findByTitle(condition);</span><br><span class="line">        <span class="keyword">for</span>(Article article:articleList)&#123;</span><br><span class="line">            System.out.println(article);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**条件分页查询*/</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findByTitlePage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String condition = <span class="string">&quot;版本&quot;</span>;</span><br><span class="line">        Pageable pageable = PageRequest.of(<span class="number">2</span>,<span class="number">10</span>);</span><br><span class="line">        Page&lt;Article&gt; page = articleService.findByTitle(condition,pageable);</span><br><span class="line">        <span class="keyword">for</span>(Article article:page.getContent())&#123;</span><br><span class="line">            System.out.println(article);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>4.使用Elasticsearch的原生查询对象进行查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findByNativeQuery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个SearchQuery对象</span></span><br><span class="line">    SearchQuery searchQuery = <span class="keyword">new</span> NativeSearchQueryBuilder()</span><br><span class="line">        <span class="comment">//设置查询条件，此处可以使用QueryBuilders创建多种查询</span></span><br><span class="line">        .withQuery(QueryBuilders.queryStringQuery(<span class="string">&quot;备份节点上没有数据&quot;</span>).defaultField(<span class="string">&quot;title&quot;</span>))</span><br><span class="line">        <span class="comment">//还可以设置分页信息</span></span><br><span class="line">        .withPageable(PageRequest.of(<span class="number">1</span>, <span class="number">5</span>))</span><br><span class="line">        <span class="comment">//创建SearchQuery对象</span></span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">//使用模板对象执行查询</span></span><br><span class="line">    elasticsearchTemplate.queryForList(searchQuery, Article.class)</span><br><span class="line">        .forEach(a-&gt; System.out.println(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>搜索技术</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式——工厂模式</title>
    <url>/2021/08/06/202186-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>工厂模式包括简单工厂模式、工厂模式、抽象工厂模式</p>
<span id="more"></span>

<p>学习好 Java 的设计模式能够帮助我们写出可读性、扩展性等方面更加优良的代码，本文主要是从<a href="https://mp.weixin.qq.com/s/I9aHU8hiuI0a9bow59B3Qw">2W字详解设计模式</a>中做拆分摘录，方便我日后的二次学习。</p>
<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p><strong>只有单一工厂类</strong>，该工厂类 XxxFactory 有一个静态方法，该方法根据传递参数的不同来创建不同的对象（这些对象都来自同一父类或者实现了统一接口）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Food <span class="title">makeFood</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;noodle&quot;</span>)) &#123;</span><br><span class="line">            Food noodle = <span class="keyword">new</span> LanZhouNoodle();</span><br><span class="line">            noodle.addSpicy(<span class="string">&quot;more&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> noodle;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;chicken&quot;</span>)) &#123;</span><br><span class="line">            Food chicken = <span class="keyword">new</span> HuangMenChicken();</span><br><span class="line">            chicken.addCondiment(<span class="string">&quot;potato&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> chicken;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 LanZhouNoodle 和 HuangMenChicken 均继承自 Food</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>实际开发中，可能需要不止一个工厂来创建符合需求的类，所以<strong>工厂模式就是包含多个工厂类</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Food <span class="title">makeFood</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChineseFoodFactory</span> <span class="keyword">implements</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">makeFood</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ChineseFoodA();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ChineseFoodB();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanFoodFactory</span> <span class="keyword">implements</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">makeFood</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AmericanFoodA();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">&quot;B&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AmericanFoodB();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到上述代码中一共有两个工厂，可以分别产生不同的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        FoodFactory factory = <span class="keyword">new</span> ChineseFoodFactory();</span><br><span class="line">        Food food = factory.makeFood(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样是调用 makeFood(“A”) 方法，但是因为选取的工厂对象不同，产生的对象也就不同了。</p>
<h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>假设现在需要制造一台电脑，分别由CPU、主板进行组装，假设采用以下方法来实现制造：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CPUFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">CPU <span class="title">makeCPU</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntelCPUFactory</span> <span class="keyword">implements</span> <span class="title">CPUFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CPU <span class="title">makeCPU</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IntelCPU();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmdCPUFactory</span> <span class="keyword">implements</span> <span class="title">CPUFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CPU <span class="title">makeCPU</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AmdCPU();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MainBoardFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">MainBoard <span class="title">makeMainBoard</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntelMainBoardFactory</span> <span class="keyword">implements</span> <span class="title">MainBoardFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MainBoard <span class="title">makeMainBoard</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IntelMainBoard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmdMainBoardFactory</span> <span class="keyword">implements</span> <span class="title">MainBoardFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MainBoard <span class="title">makeMainBoard</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AmdMainBoard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不难看出，CPU和主板的工厂分别就是之前说过的工厂模式，当我们需要增加硬盘怎么办？可以之间再写一个 HardDiskFactory 即可，并不需要对现有工厂进行修改。</p>
<p>但是，如果两个工厂间产生的对象之间不匹配怎么办？例如，IntelCPUFactory 生产的 CPU 和 AmdMainBoardFactory 生产的主板并不兼容，那么组装出的电脑便会出现异常。所以，这个时候就要使用抽象工厂类，来进行统一。<strong>对多个属于同一族的对象进行抽象，形成统一的工厂类。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">CPU <span class="title">makeCPU</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">MainBoard <span class="title">makeMainBoard</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntelFactory</span> <span class="keyword">implements</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CPU <span class="title">makeCPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IntelCPU();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MainBoard <span class="title">makeMainBoard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IntelMainBoard();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HardDisk <span class="title">makeHardDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IntelHarkDisk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmdFactory</span> <span class="keyword">implements</span> <span class="title">ComputerFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> CPU <span class="title">makeCPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AmdCPU();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MainBoard <span class="title">makeMainBoard</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AmdMainBoard();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HardDisk <span class="title">makeHardDisk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AmdHarkDisk();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样只需要选择好某一个工厂就可以制造一整个族的对象，就避免了不同工厂制造出的对象中存在不兼容的问题。但是，问题也是存在的，可以看出，为了添加一个制造硬盘的功能，需要在每个工厂中都增加制造硬盘的方法。这就有所违反<strong>对修改关闭，对扩展开放</strong>的设计原则。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP中几种请求方法</title>
    <url>/2021/08/08/202188-HTTP%E4%B8%AD%E5%87%A0%E7%A7%8D%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在 HTTP 中可供使用的方法有：GET,POST,PUT,HEAD,DELETE,OPTIONS,TRACE,CONNECT</p>
<span id="more"></span>

<h2 id="请求格式"><a href="#请求格式" class="headerlink" title="请求格式"></a>请求格式</h2><p>用于 HTTP 协议交互的信息被称为 <strong>HTTP 报文</strong>。</p>
<p>请求端（客户端）的 HTTP 报文叫做<strong>请求报文</strong>，响应端（服务器端）的 HTTP 报文叫做<strong>响应报文</strong>。</p>
<p>HTTP 报文大致分为报文首部和报文主体两块，中间使用空行来划分，<strong>报文主体是非必需的</strong>。</p>
<p><img src="/images/ComputerNetworks/HTTP%E6%8A%A5%E6%96%87.jpg" alt="HTTP报文"></p>
<h2 id="GET：获取资源"><a href="#GET：获取资源" class="headerlink" title="GET：获取资源"></a>GET：获取资源</h2><p>GET 方法用来请求访问已被 URI 识别的资源，指定的资源经服务器端解析后返回响应内容。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/example.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br></pre></td></tr></table></figure>

<h2 id="POST：传输实体主体"><a href="#POST：传输实体主体" class="headerlink" title="POST：传输实体主体"></a>POST：传输实体主体</h2><p>POST 方法用来传输实体的主体，向指定资源提交数据进行处理请求（提交表单等)。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/example.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>1560(1560bytes)</span><br></pre></td></tr></table></figure>

<p><strong>GET 和 POST 方法的区别</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>GET</th>
<th>POST</th>
</tr>
</thead>
<tbody><tr>
<td>后退/刷新按钮</td>
<td>没有变化</td>
<td>数据会被重新提交</td>
</tr>
<tr>
<td>缓存</td>
<td>可以</td>
<td>不可以</td>
</tr>
<tr>
<td>参数保留</td>
<td>保留着浏览器历史记录</td>
<td>不会保留在历史记录</td>
</tr>
<tr>
<td>安全性</td>
<td>GET 的安全性较差，发送的数据将成为 URL 的一部分，对所有人可见</td>
<td>参数不会保存，并且数据不会直接显示在 URL 中，不是可见的(用于密码等敏感信息的输入)</td>
</tr>
</tbody></table>
<h2 id="PUT：传输文件"><a href="#PUT：传输文件" class="headerlink" title="PUT：传输文件"></a>PUT：传输文件</h2><p>PUT 方法要求请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PUT</span> <span class="string">/example.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>text/html</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>1560(1560bytes)</span><br></pre></td></tr></table></figure>

<h2 id="HEAD：获取报文首部"><a href="#HEAD：获取报文首部" class="headerlink" title="HEAD：获取报文首部"></a>HEAD：获取报文首部</h2><p>HEAD 方法和 GET 方法类似，不过不返回报文主体部分，只需要返回报文首部部分，一般用来确认 URI 的有效性以及资源更新的日期时间等。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">HEAD</span> <span class="string">/example.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br></pre></td></tr></table></figure>

<h2 id="DELETE：删除文件"><a href="#DELETE：删除文件" class="headerlink" title="DELETE：删除文件"></a>DELETE：删除文件</h2><p>DELETE 方法和 PUT 方法相反，用于删除文件，按请求 URI 删除指定的资源。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="string">/example.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br></pre></td></tr></table></figure>

<h2 id="OPTIONS：询问支持的方法"><a href="#OPTIONS：询问支持的方法" class="headerlink" title="OPTIONS：询问支持的方法"></a>OPTIONS：询问支持的方法</h2><p>OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">OPTIONS</span> <span class="string">/example.html</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br></pre></td></tr></table></figure>

<h2 id="TRACE：追踪路径"><a href="#TRACE：追踪路径" class="headerlink" title="TRACE：追踪路径"></a>TRACE：追踪路径</h2><p>TRACE 方法是让 Web 服务器端将之前的请求通信返回给客户端的方法，主要用于测试、诊断等。客户端可以通过此方法查询刚刚发出的请求是怎样被加工修改/篡改的。</p>
<p>发送请求时，在 Max-Forwards 首部字段中添加数值，每经过一个服务器端就将该数字减 1，当数值刚好为 0 时，停止继续传输，最后接收到请求的服务器端返回 200 OK 的响应。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TRACE</span> <span class="string">/</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br><span class="line"><span class="attribute">Max-Forwards</span><span class="punctuation">: </span>2</span><br></pre></td></tr></table></figure>

<h2 id="CONNECT：要求用隧道协议连接代理"><a href="#CONNECT：要求用隧道协议连接代理" class="headerlink" title="CONNECT：要求用隧道协议连接代理"></a>CONNECT：要求用隧道协议连接代理</h2><p>CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信，主要使用 SSL 和 TLS 协议把通信内容加密后经网络隧道传输。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> <span class="string">proxy.com:8080</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>www.example.com</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP和HTTPS的区别</title>
    <url>/2021/08/10/2021810-HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>有关 HTTP 和 HTTPS 的概念，区别，优缺点等</p>
<span id="more"></span>

<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>HTTP：</strong>超文本传输协议（HTTP，HyperText Transfer Protocol）是互联网上应用最为广泛的一种网络协议。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法，<strong>用于客户端和服务器端之间的通信</strong>。但是，HTTP 具有许多安全性的漏洞，容易遭受恶意攻击。</p>
<p><strong>HTTPS：</strong>是为了弥补 HTTP 协议的安全所提出的协议，<strong>实质是 HTTP 加上加密处理和认证以及完整性保护，身披 SSL(Secure Sockets Layer 安全套接字协议) 外壳的 HTTP</strong>。为客户端和服务器端之间的通信提供安全保障，避免黑客的攻击。</p>
<p><strong>HTTP 的缺点</strong></p>
<ul>
<li><p>通信使用明文可能会被窃听</p>
</li>
<li><p>不验证通信方的身份就可能遭遇伪装</p>
</li>
<li><p>无法证明报文完整性，可以已被篡改</p>
<p>…</p>
</li>
</ul>
<p>HTTPS 就针对以上缺陷做了弥补，一是建立了一个信息安全通道，来保证数据传输的安全；另一是使用证书来保证网站的真实性、信息的完整性等。<br>总结为三点：<strong>数据保密性；数据完整性；身份校验安全性。</strong></p>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>HTTP 是<strong>无需任何费用</strong>的；HTTPS 协议需要到数字证书认证机构（CA，Certificate Authority）申请证书，需要<strong>支付一定的费用</strong></li>
<li>HTTP 中信息采用的是<strong>明文传输</strong>；HTTPS 则是使用 SSL 协议进行<strong>加密传输</strong></li>
<li>HTTP 的端口为 <strong>80</strong>；HTTPS 的端口为 <strong>443</strong></li>
<li>HTTP 的连接较为<strong>简单</strong>，是<strong>无状态</strong>（不保存任何信息）的；HTTPS 是由 SSL + HTTP 构建的<strong>加密传输</strong>、<strong>身份认证</strong>的网络协议，比较<strong>安全</strong>。</li>
</ul>
<h2 id="HTTPS-的优点"><a href="#HTTPS-的优点" class="headerlink" title="HTTPS 的优点"></a>HTTPS 的优点</h2><p><strong>针对 HTTP 的改进</strong></p>
<ul>
<li><p>双向的身份认证<br>客户端和服务器端进行数据传输前，会通过 CA 颁发的证书来进行身份认证。</p>
<ul>
<li>客户端通过 SSL 向服务器请求连接</li>
<li>服务器将包含服务器公钥的证书发送给客户端</li>
<li>客户端通过浏览器内置的 CA 公钥判断证书的准确性，取出服务器公钥</li>
<li>客户端使用服务器公钥和客户端进行通信</li>
<li>服务器端也可以用同样的方法要求客户端发送身份证明的证书来验证客户端的身份</li>
</ul>
</li>
<li><p>数据传输的机密性</p>
<ul>
<li>客户端和服务端在开始传输数据之前，会协商传输过程需要使用的加密算法。 </li>
<li>客户端发送协商请求给服务端, 其中包含自己支持的非对成加密的密钥交换算法 ( 一般是RSA)，数据签名摘要算法 ( 一般是SHA或者MD5) ，加密传输数据的对称加密算法 ( 一般是DES)，以及加密密钥的长度。 </li>
<li>服务端接收到消息之后，选中安全性最高的算法，并将选中的算法发送给客户端，完成协商。</li>
<li>客户端生成随机的字符串，通过协商好的非对称加密算法，使用服务端的公钥对该字符串进行加密，发送给服务端。 </li>
<li>服务端接收到之后，使用自己的私钥解密得到该字符串。在随后的数据传输当中，使用这个字符串作为密钥进行对称加密。</li>
</ul>
</li>
</ul>
<p><strong>自身的优点</strong></p>
<ul>
<li>使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器</li>
<li>HTTPS 协议是由SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、修改，确保数据的完整性</li>
<li>HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本</li>
</ul>
<h2 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h2><ul>
<li>HTTPS 协议握手阶段比较费时，会使页面的加载时间延长</li>
<li>HTTPS连接缓存不如HTTP高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响</li>
<li>SSL证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用</li>
<li>SSL证书通常需要绑定IP，不能在同一IP上绑定多个域名，IPv4资源不可能支撑这个消耗</li>
<li>HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用</li>
<li>最关键的，SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行</li>
</ul>
<h2 id="HTTPS-的通信过程"><a href="#HTTPS-的通信过程" class="headerlink" title="HTTPS 的通信过程"></a>HTTPS 的通信过程</h2><p><img src="/images/ComputerNetworks/HTTPS_Process.jpg" alt="HTTPS_Process"></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>HTTP常用状态码</title>
    <url>/2021/08/09/202189-HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    <content><![CDATA[<p>HTTP 中返回结果的状态码一般有 1xx，2xx，3xx，4xx，5xx 几类</p>
<span id="more"></span>

<p>状态码的职责就是当客户端向服务器端发送请求时，描述返回的请求结果。这样，根据返回的状态码，用户就可以知道服务器端是否正常处理了发送的请求。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>类别</th>
<th>原因短语</th>
</tr>
</thead>
<tbody><tr>
<td>1XX</td>
<td>Informational（信息性状态码）</td>
<td>接收的请求正在处理</td>
</tr>
<tr>
<td>2XX</td>
<td>Success（成功状态码）</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3XX</td>
<td>Redirection（重定向状态码）</td>
<td>需要进行附加操作以完成请求</td>
</tr>
<tr>
<td>4XX</td>
<td>Client Error（客户端错误状态码）</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5XX</td>
<td>Server Error（服务器错误状态码）</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<p><img src="/images/ComputerNetworks/statusCode.jpg" alt="statuscode"></p>
<h2 id="1XX-正在处理"><a href="#1XX-正在处理" class="headerlink" title="1XX 正在处理"></a>1XX 正在处理</h2><p><strong>100 Continue</strong></p>
<p>表示服务器收到了请求的初始部分，并请客户端继续发生剩余部分。</p>
<p><strong>101 Switch Protocol</strong></p>
<p>表示当前协议更改，比如由 HTTP 变为 WS 协议保持长连接</p>
<h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h2><p><strong>200 OK</strong></p>
<p>表示从客户端发来的请求在服务器端被正常处理</p>
<p><strong>204 No Content</strong></p>
<p>表示服务器接收的请求已经成功处理，但在返回的响应报文中不含实体的主体部分，也不允许返回任何实体的主体。一般用于只需要客户端向服务器端发送信息，而对客户端不需要发送新信息内容的情况下使用。</p>
<p><strong>206 Partial Content</strong></p>
<p>表示客户端进行了范围请求，而服务器成功执行了这部分的 GET 请求，响应报文中包含由 Content-Range 指定范围的实体内容。</p>
<h2 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h2><p><strong>301 Moved Permanently</strong></p>
<p>永久重定向，表示请求的资源已经被分配了新的 URI，以后需要请求新的 URI。</p>
<p><strong>302 Found</strong></p>
<p>临时性重定向，表示请求的资源已经被分配了新的 URI，希望用户请求新的 URI，但是，该 URI可能会二次改变。</p>
<p><strong>303 See Other</strong></p>
<p>表示由于请求对应的资源存在另一个 URI，应使用 GET 方法定向获取请求的资源。</p>
<p><strong>304 Not Modified</strong></p>
<p>表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，返回该状态码。</p>
<p><strong>307 Temporary Redirect</strong></p>
<p>临时重定向，该状态码不同于之前的重定向状态码，将遵循当第一次请求为 POST 方法时，进行重定向请求时仍为 POST 方法。</p>
<h2 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h2><p><strong>400 Bad Request</strong></p>
<p>表示请求报文中存在语法错误，需要修改请求的内容后再次发送请求。（浏览器会像对待 200 OK 一样对待该状态码）</p>
<p><strong>401 Unauthorized</strong></p>
<p>表示发送的请求需要有通过 HTTP 认证（BASIC、DIGEST）的认证信息。<br>返回含有 401 状态码的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部以质询（Challenge）用户信息。</p>
<p><strong>403 Forbidden</strong></p>
<p>表示对请求资源的访问被服务器拒绝了。</p>
<p><strong>404 Not Found</strong></p>
<p>表示服务器上找不到请求的资源，或者被用于拒绝本次请求。</p>
<h2 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h2><p><strong>500 Internal Server Error</strong></p>
<p>表示服务器端在执行请求时发生了错误。</p>
<p><strong>503 Service Unavailable</strong></p>
<p>表示服务器暂时处于超负载或者正在进行停机维护，暂时无法处理请求。</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
  </entry>
  <entry>
    <title>Java三种网络编程模型</title>
    <url>/2021/08/16/2021816-Java%E4%B8%89%E7%A7%8D%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>Java 一共支持三种网络编程 I/O 模型：BIO、NIO、AIO</p>
<span id="more"></span>

<h2 id="I-O-模型"><a href="#I-O-模型" class="headerlink" title="I/O 模型"></a>I/O 模型</h2><p>I/O 模型就是用来进行数据的输出(发送)和输入(接收)，使用不同的 I/O 模型，在程序通信时发挥的性能也有所不同。</p>
<p>Java 中共支持三种网络编程 I/O 模型，即 BIO、NIO、AIO。</p>
<ul>
<li><p>Java BIO：<strong>同步并阻塞（传统阻塞型）</strong>，服务器实现模式为<strong>一个连接一个线程</strong>，即每个客户端连接请求都要启动一个线程，那么就会造成不少线程的开销。<br><strong>适用于：</strong>连接数较少且固定</p>
</li>
<li><p>Java NIO：<strong>同步非阻塞</strong>，服务器实现模式为<strong>一个线程处理多个连接</strong>，即多个客户端的请求会注册到多路复用器（selector）上，然后采用轮询的方式进行处理。</p>
<p><strong>适用于：</strong>连接数较多且连接时间比较短</p>
</li>
<li><p>Java AIO：<strong>异步</strong>，AIO 引入了异步通道的概念，采用了 Proactor 模式，<strong>有效的请求才启动线程</strong>。特点是先由操作系统完成后才<strong>通知</strong>服务器端程序启动线程去处理。</p>
<p><strong>适用于：</strong>连接数较多且连接时间较长的应用</p>
</li>
</ul>
<h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>同步阻塞</li>
<li>一个连接一个线程（可创建线程池实现线程复用）</li>
</ul>
<p><img src="/images/Java/IO/BIO.jpg" alt="BIO"></p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p>1）服务器端启动一个 ServerSocket</p>
<p>2）客户端启动 Socket 与服务器进行通信，默认情况下服务器端需要为每个连接的客户端建立一个线程来进行通信</p>
<p>3）客户端发出请求后，先咨询服务器是否有可用线程，如果没有则会等待或者被拒绝</p>
<p>4）如果有线程响应，客户端等待线程执行完毕后（阻塞状态），才进入下一步处理</p>
<h3 id="栗子🌰"><a href="#栗子🌰" class="headerlink" title="栗子🌰"></a>栗子🌰</h3><p>1）使用 BIO 模型编写一个服务器，监听 6666 端口</p>
<p>2）使用线程池实现线程服用</p>
<p>3）启动 Server 之后，可以使用 Telnet 进行连接并发送消息字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//使用线程池机制</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//思路</span></span><br><span class="line">        <span class="comment">//1.创建一个线程池</span></span><br><span class="line">        <span class="comment">//2.如果有客户端连接，就创建一个线程池，与之通讯（单独写一个方法）</span></span><br><span class="line"></span><br><span class="line">        ExecutorService threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">1000</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">6666</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Server is started!&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//监听，等待客户端连接</span></span><br><span class="line">            <span class="keyword">final</span> Socket socket = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">&quot;Client is connected!&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//创建一个线程，与之通讯</span></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    handler(socket);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义handler方法，和客户端通讯</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread info: id=&quot;</span>+Thread.currentThread().getId()+</span><br><span class="line">                    <span class="string">&quot; name=&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//通过socket获取输入流</span></span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            <span class="comment">//LoopRead</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread info: id=&quot;</span>+Thread.currentThread().getId()+</span><br><span class="line">                        <span class="string">&quot; name=&quot;</span>+Thread.currentThread().getName());</span><br><span class="line">                <span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">                <span class="keyword">if</span>(read != -<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(bytes,<span class="number">0</span>,read));</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;read is finished.&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;close connection of client&quot;</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>1）每个请求都要创建独立的与之对应的线程，虽然可用采用线程池实现线程复用。但是，当并发请求数量变大时，仍旧需要大量线程处理请求，导致系统开销过大。</p>
<p>2）连接建立后，如果当前线程无 I/O 请求，该线程将阻塞在 Read 操作，造成资源浪费。</p>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>NIO 是现在比较常用的一种 I/O 模型，Netty 框架就是基于 NIO 所编写。并且 NIO 的知识点较多，所以我开了新的一篇来着重介绍。请移步至 ☞ <a href="http://deepsea-blog.top/2021/08/24/2021824-Java-NIO/">Java-NIO</a></p>
<h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>AIO 的<strong>基本思想</strong>是允许进程发起很多 I/O 操作，而不用阻塞或等待任何操作完成，可以立刻返回去执行其他操作。稍后或在接收到 I/O 操作完成的通知时，进程再去检索 I/O 操作的结果。</p>
<h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="/images/Java/IO/AIO.jpg" alt="AIO"></p>
<p>可以看出 AIO 允许其他处理和 I/O 操作重叠进行，包括 I/O 操作完成的通知。</p>
<p>使用 AIO 就可以构建 I/O 速度更快、效率更高的 Application，提高资源利用率。</p>
<p><strong>Reference:</strong> <a href="http://www.52im.net/thread-306-1-1.html">Java新一代网络编程模型AIO原理及Linux系统AIO介绍-网络编程/专项技术区 - 即时通讯开发者社区! (52im.net)</a></p>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><table>
<thead>
<tr>
<th></th>
<th>BIO</th>
<th>NIO</th>
<th>AIO</th>
</tr>
</thead>
<tbody><tr>
<td>IO模型</td>
<td>同步阻塞</td>
<td>同步非阻塞</td>
<td>异步非阻塞</td>
</tr>
<tr>
<td>编程难度</td>
<td>简单</td>
<td>复杂</td>
<td>复杂</td>
</tr>
<tr>
<td>可靠性</td>
<td>差</td>
<td>好</td>
<td>好</td>
</tr>
<tr>
<td>吞吐量</td>
<td>低</td>
<td>高</td>
<td>高</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
        <category>网络编程</category>
      </categories>
  </entry>
  <entry>
    <title>Java-NIO</title>
    <url>/2021/08/24/2021824-Java-NIO/</url>
    <content><![CDATA[<p>NIO 是现在比较常用的一种 I/O 模型，Netty 框架就是基于 NIO 所编写</p>
<span id="more"></span>

<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>1）Java NIO 即 (Java non-blocking IO) 同步非阻塞的 IO 模型，NIO 相关类都被放在 java.nio 包及子包下，并且对原来的 java.io 包进行了改写。</p>
<p>2）<strong>NIO 三大核心部分：Channel（通道）、Buffer（缓冲区）、Selector（选择器）</strong></p>
<p>3）NIO 是面向缓冲区（块）编程，数据读取到一个缓冲区后，在需要使用时再从缓冲区取出相应的数据。增加了程序的灵活性，支持了非阻塞式的高伸缩性网络。</p>
<p>4）NIO 的同步非阻塞模式，即当客户端发起请求后，并不会阻塞直到请求结果的返回，而是立即返回然后执行其他的操作。然后通过轮询的方式，间断地查看请求结果是否返回。</p>
<h2 id="NIO-BIO"><a href="#NIO-BIO" class="headerlink" title="NIO/BIO"></a>NIO/BIO</h2><table>
<thead>
<tr>
<th>NIO</th>
<th>BIO</th>
</tr>
</thead>
<tbody><tr>
<td>块方式处理数据</td>
<td>流方式处理数据</td>
</tr>
<tr>
<td>同步非阻塞</td>
<td>同步阻塞</td>
</tr>
<tr>
<td>Channel、Buffer、Selector</td>
<td>字节流、字符流</td>
</tr>
</tbody></table>
<h2 id="结构简图"><a href="#结构简图" class="headerlink" title="结构简图"></a>结构简图</h2><p><img src="/images/Java/IO/BIO.jpg" alt="NIO"></p>
<ul>
<li>每个 Channel 对应一个 Buffer</li>
<li>一个 Selector 可以有多个 Channel 注册到上面</li>
<li>Selector 根据 Channel 发生的事件来进行切换</li>
<li>Buffer 则是暂存数据的地方，使用 flip 方法进行读写切换</li>
</ul>
<h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>缓冲区本质上是一个<strong>可以读写数据的内存块</strong>，类似于一个<strong>容器</strong>。Channel 提供了从文件、网络中读取数据的通道，但是这些数据都必须经过 Buffer。</p>
<p>根据存放数据的类型不同，<strong>Buffer 具有不同的子类</strong>：ByteBuffer, ShortBuffer, CharBuffer, IntBuffer, LongBuffer, DoubleBuffer, FloatBuffer.</p>
<p><strong>四个属性</strong>来提供数据元素的信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//标记</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> mark = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">//位置，下一个要被读/写元素的索引</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//缓冲区的当前终点，数据的可读范围</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line"><span class="comment">//容量，缓冲区的大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br></pre></td></tr></table></figure>

<p><strong>相关方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//JDK1.4</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">capacity</span><span class="params">()</span></span>; <span class="comment">//返回容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">position</span><span class="params">()</span></span>; <span class="comment">//返回当前位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">position</span><span class="params">(<span class="keyword">int</span> newPosition)</span></span>; <span class="comment">//设置位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span></span>; <span class="comment">//返回限制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">limit</span><span class="params">(<span class="keyword">int</span> newLimit)</span></span>; <span class="comment">//设置限制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span></span>; <span class="comment">//重置所有标记的值，数据保留</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span></span>; <span class="comment">//读写切换</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasRemaining</span><span class="params">()</span></span>; <span class="comment">//position和limit之间是否有元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span></span>; <span class="comment">//是否只读</span></span><br><span class="line"><span class="comment">//JDK1.6</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">hasArray</span><span class="params">()</span></span>; <span class="comment">//是否具有可访问的底层实现数组 </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">array</span><span class="params">()</span></span>; <span class="comment">//返回底层实现数组</span></span><br></pre></td></tr></table></figure>

<p>最常用的<strong>ByteBuffer</strong>的主要方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocateDirect</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>; <span class="comment">//创建直接缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title">allocate</span><span class="params">(<span class="keyword">int</span> capacity)</span></span>; <span class="comment">//设置容量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">()</span></span>; <span class="comment">//得到position，随后position+1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">byte</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>; <span class="comment">//得到绝对位置的position</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">byte</span> b)</span></span>; <span class="comment">//添加元素到当前位置，position+1</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ByteBuffer <span class="title">put</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">byte</span> b)</span></span>; <span class="comment">//指定位置添加元素</span></span><br></pre></td></tr></table></figure>

<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>单个通道可以异步地对 Buffer 进行读/写操作。</p>
<p>常用的 Channel 实现类有：</p>
<ul>
<li>FileChannel——用于文件</li>
<li>DatagramChannel——用于 UDP 的数据报</li>
<li>ServerSocketChannel、SocketChannel——用于TCP</li>
</ul>
<p><strong>FileChannel：</strong></p>
<p>主要用于对本地文件进行 IO 操作，常用方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span></span>; <span class="comment">//从通道读取数据到dst</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span></span>; <span class="comment">//把通道数据写入到src</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">transferFrom</span><span class="params">(ReadableByteChannel src, <span class="keyword">long</span> position, <span class="keyword">long</span> count)</span></span>; <span class="comment">//src通道数据复制到当前通道</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">transferTo</span><span class="params">(<span class="keyword">long</span> position, <span class="keyword">long</span> count, WritableByteChannel target)</span></span>; <span class="comment">//当前通道数据复制到target通道</span></span><br></pre></td></tr></table></figure>

<p>实现使用一个 Buffer 完成文件的读/写</p>
<p><img src="/images/Java/IO/Channel.jpg" alt="Channel"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileNotFoundException;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOFileChannel</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        FileInputStream fileInputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;File.txt&quot;</span>);</span><br><span class="line">        FileChannel fileChannel01 = fileInputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        FileOutputStream fileOutputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;File_Copy.txt&quot;</span>);</span><br><span class="line">        FileChannel fileChannel02 = fileOutputStream.getChannel();</span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">512</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            byteBuffer.clear();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> read = fileChannel01.read(byteBuffer);</span><br><span class="line">            <span class="keyword">if</span>(read == -<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            byteBuffer.flip();</span><br><span class="line">            fileChannel02.write(byteBuffer);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>特点：</strong></p>
<ul>
<li>ByteBuffer 支持类型化的 put 和 get，get 获取的类型必须和 put 放入的匹配。否则，抛出 BufferUnderflowException 异常</li>
<li>可以使用 asReadOnlyBuffer() 方法转换成只读类型的 ByteBuffer</li>
<li>NIO 提供了 MappedByteBuffer 可以让文件直接在内存中进行修改，而如何同步到文件由 NIO 来实现</li>
<li>NIO 支持多个 Buffer 构建一个 Buffer 数组一起完成读/写操作，即 Gathering(依次读) 和 Scattering(依次写)</li>
</ul>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>Selector 可以检测注册到自己身上的多个通道是否有事件发生，如果有事件发生，便获取该事件进行相应的处理。且只有发生读写事件时，才会进行读写，减少了资源的浪费。</p>
<p><strong>常用方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Selector <span class="title">open</span><span class="params">()</span></span>; <span class="comment">//得到一个选择器对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">long</span> timeout)</span></span>; <span class="comment">//监控所有注册的通道，当其中有IO操作时，获取该通道对应的SelectionKey</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;SelectionKey&gt; <span class="title">selectedKeys</span><span class="params">()</span></span>; <span class="comment">//获取所有注册的通道的SelectionKey</span></span><br></pre></td></tr></table></figure>

<p><strong>图解：</strong></p>
<p><img src="/images/Java/IO/Selector.jpg" alt="Selector"></p>
<p>1）当客户端连接时，会通过 ServerSocketChannel 得到 SocketChannel</p>
<p>2）Selector 可以通过 select 方法，返回有事件发生的通道的个数</p>
<p>3）SocketChannel 使用 register 方法将自己注册到 Selector 上，并得到一个与之对应的 SelectionKey</p>
<p>4）Selector 可以通过 selectionKeys 得到所有的通道的 SelectionKey，根据 Key 反向获取 Channel 对象</p>
<h2 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h2><p>SelectionKey 表示了 Selector 和网络通道的注册关系，共四种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_READ = <span class="number">1</span> &lt;&lt; <span class="number">0</span>; <span class="comment">//表示有读操作，值为 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_WRITE = <span class="number">1</span> &lt;&lt; <span class="number">2</span>; <span class="comment">//表示有写操作，值为 4</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_CONNECT = <span class="number">1</span> &lt;&lt; <span class="number">3</span>; <span class="comment">//表示Channel已连接，值为8</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> OP_ACCEPT = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">//表示Channel请求连接，值为16</span></span><br></pre></td></tr></table></figure>

<p><strong>常用方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Selector <span class="title">selector</span><span class="params">()</span></span>; <span class="comment">//获取所注册的Selector</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectableChannel <span class="title">channel</span><span class="params">()</span></span>; <span class="comment">//获取对应的Channel</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">attachment</span><span class="params">()</span></span>; <span class="comment">//得到关联的共享数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> SelectionKey <span class="title">interestOps</span><span class="params">(<span class="keyword">int</span> ops)</span></span>; <span class="comment">//设置或改变监听的事件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isAcceptable</span><span class="params">()</span></span>; <span class="comment">//是否可以accept</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span></span>; <span class="comment">//是否可读</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">()</span></span>; <span class="comment">//是否可写</span></span><br></pre></td></tr></table></figure>

<h2 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h2><p>ServerSocketChannel 负责在服务端监听来自客户端新的 Socket 连接</p>
<p><strong>相关方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ServerSocketChannel <span class="title">open</span><span class="params">()</span></span>; <span class="comment">//得到一个ServerSocketChannel</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ServerSocketChannel <span class="title">bind</span><span class="params">(SocketAddress local)</span></span>; <span class="comment">//设置服务器端口号</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title">configureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span></span>; <span class="comment">//设置阻塞(true)/非阻塞(flase)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SocketChannel <span class="title">accept</span><span class="params">()</span></span>; <span class="comment">//接收客户端的连接，返回给一个SocketChannel</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops)</span></span>; <span class="comment">//注册到Selector设置监听事件</span></span><br></pre></td></tr></table></figure>

<h2 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h2><p>属于客户端的网络 IO 通道，负责读写操作，NIO 把缓冲区的数据写到通道，或者把通道的数据读入到缓冲区。</p>
<p><strong>相关方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SocketChannel <span class="title">open</span><span class="params">()</span></span>; <span class="comment">//得到一个SocketChannel</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectableChannel <span class="title">configureBlocking</span><span class="params">(<span class="keyword">boolean</span> block)</span></span>; <span class="comment">//是指阻塞(true)/非阻塞(false)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">connect</span><span class="params">(SocketAddress remote)</span></span>; <span class="comment">//连接服务器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">finishConnect</span><span class="params">()</span></span>; <span class="comment">//如果connect失败，尝试该方法连接</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">write</span><span class="params">(ByteBuffer src)</span></span>; <span class="comment">//从Buffer写数据到通道</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(ByteBuffer dst)</span></span>; <span class="comment">//从通道读数据给Buffer</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> SelectionKey <span class="title">register</span><span class="params">(Selector sel, <span class="keyword">int</span> ops, Object att)</span></span>; <span class="comment">//注册到一个Selector并设置监听事件，att为共享数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>; <span class="comment">//关闭通道</span></span><br></pre></td></tr></table></figure>

<h2 id="栗子🌰"><a href="#栗子🌰" class="headerlink" title="栗子🌰"></a>栗子🌰</h2><h3 id="客户端-服务端通信demo"><a href="#客户端-服务端通信demo" class="headerlink" title="客户端/服务端通信demo"></a>客户端/服务端通信demo</h3><p>使用 NIO 来实现服务器端和客户端之间的数据通讯</p>
<p><strong>NIOServer.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建ServerSocketChannel 得到 SocketChannel</span></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">//得到一个Selector</span></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">//绑定一个端口6666，在服务器端监听</span></span><br><span class="line">        serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">6666</span>));</span><br><span class="line">        <span class="comment">//设置为非阻塞</span></span><br><span class="line">        serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//把serverSocketChannel注册到selector监听事件为OP_ACCEPT</span></span><br><span class="line">        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;The number of registered selectionkeys = &quot;</span>+selector.keys().size());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环等待客户端连接</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (selector.select(<span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//等待1秒，没有事件发生</span></span><br><span class="line">                System.out.println(<span class="string">&quot;server was waited one second, none of connection.&quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果返回值大于0，表示获取到发生的事件的集合</span></span><br><span class="line">            Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();</span><br><span class="line">            <span class="comment">//遍历集合</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; keyIterator = selectionKeys.iterator();</span><br><span class="line">            <span class="keyword">while</span> (keyIterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = keyIterator.next();</span><br><span class="line">                <span class="comment">//根据key对应的通道发生的事件做相应的处理</span></span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">//有客户端发起连接，生成 socketChannel</span></span><br><span class="line">                    SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">                    System.out.println(<span class="string">&quot;client connect successful, product a socketChannel&quot;</span>+socketChannel.hashCode());</span><br><span class="line">                    <span class="comment">//将 socketChannel设置为非阻塞</span></span><br><span class="line">                    socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                    socketChannel.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">24</span>));</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    <span class="comment">//通过key反向获取对应的channel</span></span><br><span class="line">                    SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                    <span class="comment">//获取该Channel关联的buffer</span></span><br><span class="line">                    ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">                    channel.read(buffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;send &quot;</span>+<span class="keyword">new</span> String(buffer.array())+<span class="string">&quot; from client&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//手动从集合中移除当前的selectionKey,防止重复操作</span></span><br><span class="line">                keyIterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NIOClient.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//得到一个网络通道</span></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        <span class="comment">//设置非阻塞</span></span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//提供服务器端的IP和port</span></span><br><span class="line">        InetSocketAddress inetSocketAddress = <span class="keyword">new</span> InetSocketAddress(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6666</span>);</span><br><span class="line">        <span class="comment">//连接服务器</span></span><br><span class="line">        <span class="keyword">if</span>(!socketChannel.connect(inetSocketAddress))&#123;</span><br><span class="line">            <span class="keyword">while</span>(!socketChannel.finishConnect())&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Because connection needs time, client can not blocked, and do else job&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//连接成功，就发送数据</span></span><br><span class="line">        String str = <span class="string">&quot;hello,world.&quot;</span>;</span><br><span class="line">        <span class="comment">//根据字节数组大小创建一个buffer</span></span><br><span class="line">        ByteBuffer buffer = ByteBuffer.wrap(str.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="comment">//发送数据，将buffer数据写入channel</span></span><br><span class="line">        socketChannel.write(buffer);</span><br><span class="line">        System.in.read();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="简单的群聊系统"><a href="#简单的群聊系统" class="headerlink" title="简单的群聊系统"></a>简单的群聊系统</h3><p>1）实现服务器端和客户端的简单通讯（非阻塞）</p>
<p>2）实现多人群聊（多个客户端）</p>
<p>3）服务器端可以检测用户上线、下线，对用户的消息进行广播</p>
<p>4）客户端通过 Channel 发送消息给其他用户，同时也可以接收其他用户的消息</p>
<p><strong>GroupChatServer.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ServerSocketChannel listenChannel;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6667</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//得到选择器</span></span><br><span class="line">            selector = Selector.open();</span><br><span class="line">            <span class="comment">//初始化ServerSocketChannel</span></span><br><span class="line">            listenChannel = ServerSocketChannel.open();</span><br><span class="line">            <span class="comment">//绑定端口</span></span><br><span class="line">            listenChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(PORT));</span><br><span class="line">            <span class="comment">//设置非阻塞</span></span><br><span class="line">            listenChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//将该listen Channel注册到 Selector</span></span><br><span class="line">            listenChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//监听</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//循环处理</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> count = selector.select();</span><br><span class="line">                <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//存在需要处理的事件</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        SelectionKey key = iterator.next();</span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            SocketChannel sc = listenChannel.accept();</span><br><span class="line">                            sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                            <span class="comment">//将该 sc 注册到 selector</span></span><br><span class="line">                            sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                            <span class="comment">//上线提示</span></span><br><span class="line">                            System.out.println(sc.getRemoteAddress() + <span class="string">&quot;is online.&quot;</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            <span class="comment">//处理读事件</span></span><br><span class="line">                            readData(key);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//删除当前的key，防止重复处理</span></span><br><span class="line">                        iterator.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取客户端信息</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readData</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line">        <span class="comment">//定义一个socketChannel</span></span><br><span class="line">        SocketChannel channel = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//取到关联的Channel</span></span><br><span class="line">            channel = (SocketChannel) key.channel();</span><br><span class="line">            <span class="comment">//创建buffer</span></span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> count = channel.read(buffer);</span><br><span class="line">            <span class="comment">//根据count的值做处理</span></span><br><span class="line">            <span class="keyword">if</span>(count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//把缓冲区的数据转成字符串</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                <span class="comment">//输出消息</span></span><br><span class="line">                System.out.println(<span class="string">&quot;from client:&quot;</span>+msg);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//向除了自己的其他客户端转发消息</span></span><br><span class="line">                sendInfoToOtherClients(msg,channel);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(channel.getRemoteAddress() + <span class="string">&quot;is offline.&quot;</span>);</span><br><span class="line">                <span class="comment">//取消注册</span></span><br><span class="line">                key.cancel();</span><br><span class="line">                <span class="comment">//关闭通道</span></span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioException) &#123;</span><br><span class="line">                ioException.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//转发消息给其他通道</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendInfoToOtherClients</span><span class="params">(String msg, SocketChannel self)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Server relaying message...&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历所有已注册到selector的socketchannel</span></span><br><span class="line">        <span class="keyword">for</span> (SelectionKey key : selector.keys()) &#123;</span><br><span class="line">            <span class="comment">//通过key取出通道</span></span><br><span class="line">            Channel targetChannel = key.channel();</span><br><span class="line">            <span class="comment">//排除自己</span></span><br><span class="line">            <span class="keyword">if</span>(targetChannel <span class="keyword">instanceof</span> SocketChannel &amp;&amp; targetChannel != self)&#123;</span><br><span class="line">                SocketChannel dest = (SocketChannel) targetChannel;</span><br><span class="line">                <span class="comment">//将msg存储到buffer</span></span><br><span class="line">                ByteBuffer buffer = ByteBuffer.wrap(msg.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">                <span class="comment">//将buffer的数据写入通道</span></span><br><span class="line">                dest.write(buffer);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GroupChatServer groupChatServer = <span class="keyword">new</span> GroupChatServer();</span><br><span class="line">        groupChatServer.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>GroupChatClient.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GroupChatClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义相关的属性</span></span><br><span class="line">    <span class="comment">//服务器IP</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String HOST = <span class="string">&quot;127.0.0.1&quot;</span>;</span><br><span class="line">    <span class="comment">//服务器端口</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> PORT = <span class="number">6667</span>;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> SocketChannel socketChannel;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GroupChatClient</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        selector = Selector.open();</span><br><span class="line">        socketChannel = SocketChannel.open(<span class="keyword">new</span> InetSocketAddress(HOST, PORT));</span><br><span class="line">        socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        socketChannel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">        username = socketChannel.getLocalAddress().toString().substring(<span class="number">1</span>);</span><br><span class="line">        System.out.println(username + <span class="string">&quot;is ok.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向服务器发送消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendInfo</span><span class="params">(String info)</span> </span>&#123;</span><br><span class="line">        info = username + <span class="string">&quot; say: &quot;</span> + info;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socketChannel.write(ByteBuffer.wrap(info.getBytes(StandardCharsets.UTF_8)));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取从服务器端回复的消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> readChannels = selector.select();</span><br><span class="line">            <span class="keyword">if</span> (readChannels &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//存在发生事件的通道</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                    SelectionKey key = iterator.next();</span><br><span class="line">                    <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        <span class="comment">//得到相关的通道</span></span><br><span class="line">                        SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">//得到用于存储消息的buffer</span></span><br><span class="line">                        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        <span class="comment">//将通道中的数据读入到buffer中</span></span><br><span class="line">                        sc.read(buffer);</span><br><span class="line">                        <span class="comment">//把读到的buffer中的数据转成字符串</span></span><br><span class="line">                        String msg = <span class="keyword">new</span> String(buffer.array());</span><br><span class="line">                        System.out.println(msg.trim());</span><br><span class="line">                    &#125;</span><br><span class="line">                    iterator.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//启动客户端</span></span><br><span class="line">        GroupChatClient chatClient = <span class="keyword">new</span> GroupChatClient();</span><br><span class="line">        <span class="comment">//启动一个线程</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    chatClient.readInfo();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送数据给服务器端</span></span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNextLine()) &#123;</span><br><span class="line">            String s = scanner.nextLine();</span><br><span class="line">            chatClient.sendInfo(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NIO与零拷贝"><a href="#NIO与零拷贝" class="headerlink" title="NIO与零拷贝"></a>NIO与零拷贝</h2><h3 id="传统-IO"><a href="#传统-IO" class="headerlink" title="传统 IO"></a>传统 IO</h3><p>在介绍零拷贝之前先看看传统 IO 进行数据读写的时候是怎样一个操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">RandomAccessFile raf = =<span class="keyword">new</span> RandomAccessFile(file, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>[] arr = <span class="keyword">new</span> <span class="keyword">byte</span>[(<span class="keyword">int</span>) file.length()];</span><br><span class="line">raf.read(arr);</span><br><span class="line"></span><br><span class="line">Socket socket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>).accept();</span><br><span class="line">socket.getOutputStream().write(arr);</span><br></pre></td></tr></table></figure>

<p>可以看出，首先使用 RandomAccessFile 将文件以 byte 形式写入数组，然后，再通过 Socket 将数组输出。</p>
<p><img src="/images/Java/IO/copy.jpg" alt="copy"></p>
<ul>
<li>DMA: Direct memory access 直接内存拷贝（不使用 CPU）</li>
</ul>
<h3 id="mmap-优化"><a href="#mmap-优化" class="headerlink" title="mmap 优化"></a>mmap 优化</h3><p>mmap 通过内存映射，将文件映射到内核缓冲区，同时用户空间可以共享内核空间的数据。这样，在进行网络传输的时候就可以减少内核空间到用户空间的拷贝次数。</p>
<p><img src="/images/Java/IO/mmap.jpg" alt="copy"></p>
<h3 id="sendFile-优化"><a href="#sendFile-优化" class="headerlink" title="sendFile 优化"></a>sendFile 优化</h3><p><strong>Linux 2.1</strong> 数据不经过用户态，直接从内核缓冲区进入到 Socket Buffer，同时，因为和用户态无关，减少了拷贝次数以及上下文切换。</p>
<p><img src="/images/Java/IO/sendFile.jpg" alt="copy"></p>
<p><strong>Linux 2.4</strong> 消除了 CPU copy 操作，再避免了从内核缓冲区拷贝到 Socket Buffer 的操作，直接拷贝到协议栈，从而再次减少了数据拷贝次数。</p>
<p><img src="/images/Java/IO/sendFile2.jpg" alt="copy"></p>
<p>存在一次 CPU 拷贝：kernel buffer -&gt; socket buffer 但是因为数据量较小（length、offset等）可以忽略</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>零拷贝：从操作系统的角度来说，内核缓冲区之间，没有因为拷贝造成的数据重复（只有 kernel buffer 中的“原件”）</p>
<p>零拷贝不仅减少了数据复制的次数，更能带来性能上的优势，例如更少的上下文切换、更少的 CPU 缓存伪共享以及无 CPU 校验和计算等。</p>
<p><strong>mmap 和 sendFile 的区别</strong></p>
<table>
<thead>
<tr>
<th>mmap</th>
<th>sendFile</th>
</tr>
</thead>
<tbody><tr>
<td>小数据量读写</td>
<td>大文件传输</td>
</tr>
<tr>
<td>4 次上下文切换，3 次数据拷贝</td>
<td>3 次上下文切换，2 次数据拷贝</td>
</tr>
<tr>
<td>DMA 方式减少 CPU 拷贝</td>
<td>只能从内核拷贝到 Socket 缓冲区</td>
</tr>
</tbody></table>
<h3 id="栗子🌰-1"><a href="#栗子🌰-1" class="headerlink" title="栗子🌰"></a>栗子🌰</h3><p>使用传统的 IO 方式传递大文件与零拷贝方式进行比较</p>
<p><strong>NewIOServer.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(<span class="number">7001</span>);</span><br><span class="line"></span><br><span class="line">        ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">        ServerSocket serverSocket = serverSocketChannel.socket();</span><br><span class="line">        serverSocket.bind(address);</span><br><span class="line"></span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocate(<span class="number">4096</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            SocketChannel socketChannel = serverSocketChannel.accept();</span><br><span class="line">            <span class="keyword">int</span> readCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (readCount != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    readCount = socketChannel.read(byteBuffer);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将byteBuffer的position重置为0，mark作废</span></span><br><span class="line">                byteBuffer.rewind();</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            socketChannel.configureBlocking(false);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NewIOClient.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewIOClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">        socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="number">7001</span>));</span><br><span class="line"></span><br><span class="line">        String fileName = <span class="string">&quot;1.txt&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//得到一个文件Channel</span></span><br><span class="line">        FileChannel fileChannel = <span class="keyword">new</span> FileInputStream(fileName).getChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//准备发送</span></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*在Linux下，一个TransferTo方法完成传输</span></span><br><span class="line"><span class="comment">            在Windows下，每次调用TransferTo只能发送8MB文件，需要分段传输</span></span><br><span class="line"><span class="comment">            注意 传输时的位置</span></span><br><span class="line"><span class="comment">            TransferTo是用的零拷贝实现</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">long</span> transferCount = fileChannel.transferTo(<span class="number">0</span>, fileChannel.size(), socketChannel);</span><br><span class="line">        System.out.println(<span class="string">&quot;Send total bytes = &quot;</span> + transferCount</span><br><span class="line">                + <span class="string">&quot; Spend Time: &quot;</span> + (System.currentTimeMillis() - startTime));</span><br><span class="line">        fileChannel.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>网络编程</category>
      </categories>
  </entry>
  <entry>
    <title>Netty架构设计说明</title>
    <url>/2021/08/28/2021828-Netty%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>分析 Netty 相较于传统 NIO 有什么改进</p>
<span id="more"></span>

<h2 id="NIO-存在的问题"><a href="#NIO-存在的问题" class="headerlink" title="NIO 存在的问题"></a>NIO 存在的问题</h2><p>1）NIO 的类库和 API 繁杂，使用麻烦，需要掌握 Selector、ServerSocketChannel、SocketChannel、ByteBuffer 等类的使用。</p>
<p>2）要熟悉 Java 多线程编程，因为 NIO 编程涉及到 Reactor 模式，需要熟悉多线程和网络编程。</p>
<p>3）有一定的开发工作量和难度，例如客户端断连重连、半包读写、网络拥塞等。</p>
<p>4）JDK NIO 中存在的一些 Bug。</p>
<h2 id="Netty-介绍"><a href="#Netty-介绍" class="headerlink" title="Netty 介绍"></a>Netty 介绍</h2><p>Netty是一个高性能、异步事件驱动的NIO框架，它提供了对TCP、UDP和文件传输的支持。作为当前最流行的NIO框架，Netty在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，一些业界著名的开源组件也基于Netty的NIO框架构建。</p>
<p><strong><a href="https://netty.io/">官网</a>说明：</strong></p>
<blockquote>
<p>Netty is an <strong>asynchronous</strong> <strong>event-driven</strong> network application framework<br>for rapid development of maintainable high performance protocol servers &amp; clients.</p>
</blockquote>
<p><strong>构成图：</strong></p>
<p><img src="/images/Netty/components.png" alt="components"></p>
<p><strong>优点：</strong></p>
<ul>
<li>API 使用简单且功能足够强大，预置了多种编码功能，支持多种主流协议</li>
<li>扩展性好，可以通过 ChannelHandler 对框架功能进行自定义</li>
<li>性能高，Netty 采用零拷贝等方式提升了自身的性能</li>
<li>社区活跃，版本迭代周期短，Bug 修复及时，且功能更新较快</li>
<li>已经在互联网、网游等领域成功商用</li>
</ul>
<h2 id="线程模式"><a href="#线程模式" class="headerlink" title="线程模式"></a>线程模式</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p><strong>目前存在的线程模型：</strong>传统阻塞 I/O 服务模型、Reactor 模式</p>
<p><strong>Reactor 模式实现：</strong></p>
<ul>
<li>单 Reactor 单线程</li>
<li>单 Reactor 多线程</li>
<li>主从 Reactor 多线程（Netty 主要基于该模式再进行一定改进）</li>
</ul>
<h3 id="传统阻塞-I-O-服务模型"><a href="#传统阻塞-I-O-服务模型" class="headerlink" title="传统阻塞 I/O 服务模型"></a>传统阻塞 I/O 服务模型</h3><p><img src="/images/Netty/oldIO.jpg" alt="oldIO"></p>
<p><strong>特点：</strong></p>
<p>1）采用阻塞 IO 模式获取输入的数据</p>
<p>2）每个连接都需要创建一个独立的线程，当并发数大的时候，就会创建大量的线程</p>
<p>3）连接创建后，如果当前线程暂时没用数据可读，就会阻塞在 Read 操作，造成资源浪费</p>
<h3 id="Reactor-模式"><a href="#Reactor-模式" class="headerlink" title="Reactor 模式"></a>Reactor 模式</h3><p>针对传统 IO 的缺点，可以提出以下解决方法：</p>
<p>1）基于 I/O 复用模型：多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象等待，无需阻塞等待所有连接。当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理。<br>Reactor 据此产生的是：反应器模式；分发者模式（Dispatcher）；通知者模式（notifier）</p>
<p>2）基于线程池复用线程资源：不必再为每个连接创建新的线程，而是创建一个包含一定数量线程的线程池。将连接完成后的业务处理任务分配给线程池中的线程进行处理，一个线程可以处理多个连接的业务。</p>
<p><img src="/images/Netty/reactor.jpg" alt="reactor"></p>
<ul>
<li>可以将多个请求同时传递给服务器</li>
<li>服务器端将接收到的多个请求分派到相应的处理线程</li>
<li>使用 IO 复用监听事件，分发给某个线程进行处理</li>
</ul>
<p><strong>核心构成就是：</strong></p>
<ul>
<li>Reactor：在一个单独的线程中运行，负责<strong>监听和分发</strong>事件，分发给适当的处理程序来对 IO 事件做出反应。</li>
<li>Handlers：<strong>处理</strong>程序执行 IO 事件要完成的实际事件。</li>
</ul>
<h3 id="单-Reactor-单线程"><a href="#单-Reactor-单线程" class="headerlink" title="单 Reactor 单线程"></a>单 Reactor 单线程</h3><p><img src="/images/Netty/1R1T.jpg" alt="1R1T"></p>
<p>1）Select 实现了通过一个阻塞对象监听多个连接请求</p>
<p>2）Dispatch 对收到的事件进行分发，分给对应的处理器进行处理</p>
<p>3）如果是建立连接的请求事件，则分发给 Acceptor 进行处理，然后创建一个 Handler 对象处理连接完成后的后续业务处理</p>
<p>4）如果不是建立连接的事件，则 Reactor 调用对应的 Handler 进行处理</p>
<p>5）Handler 是一个 Read -&gt; 业务处理 -&gt; Send 的处理流程</p>
<p><strong>优点：</strong></p>
<p>模型简单，没有多线程、进程通信、竞争问题，自始至终仅有一个线程负责。</p>
<p><strong>缺点：</strong></p>
<p>性能问题，仅仅一个线程无法发挥多核 CPU 的性能。当 Handler 在处理某个连接上的业务时，整个进程无法处理其他连接事件，很容易导致性能瓶颈。</p>
<p>可靠性问题，线程如果出现意外导致终止或死循环，那么整个通信模块就处在不可以状态。</p>
<p><em><strong>综上，该模型适用于客户端连接数量较少，且业务耗时不长的情况</strong></em></p>
<h3 id="单-Reactor-多线程"><a href="#单-Reactor-多线程" class="headerlink" title="单 Reactor 多线程"></a>单 Reactor 多线程</h3><p><img src="/images/Netty/1RnT.jpg" alt="1RnT"></p>
<p>1）Reactor 通过 Select 监听客户端请求，并通过 Dispatch 进行分发</p>
<p>2）如果是连接请求，则通过 Acceptor 的 accept 进行处理，然后创建一个 Handler 对象处理剩余业务</p>
<p>3）如果不是连接请求，则有分发到的 Handler 进行响应，但是不做具体的业务处理。而是在通过 read 读取数据后，交给 worker 线程池的某个线程处理业务</p>
<p>4）worker 线程池分配任务给独立线程完成业务，然后返回结果给 handler</p>
<p>5）handler 收到处理结果通过 send 将结果返回给 client</p>
<p><strong>优点：</strong></p>
<p>可以充分利用多核 CPU 的处理能力</p>
<p><strong>缺点：</strong></p>
<p>多线程数据共享和访问比较复杂，reactor 使用单线程处理所有的事件监听和响应，在高并发状态下容易出现性能瓶颈</p>
<h3 id="主从-Reactor-多线程"><a href="#主从-Reactor-多线程" class="headerlink" title="主从 Reactor 多线程"></a>主从 Reactor 多线程</h3><p><img src="/images/Netty/msRnT.jpg" alt="1RnT"></p>
<p>1）Reactor 主线程 MainReactor 对象通过 select 监听连接事件，并通过 Acceptor 处理连接事件</p>
<p>2）Acceptor 处理完连接事件后，将该连接分配给 SubReactor（一个 Main 可以对应多个 Sub）</p>
<p>3）SubReactor 将连接加入到连接队列进行监听，并创建对应的 Handler 进行事件处理</p>
<p>4）当有新事件发生时，SubReactor 就会调用对应的 Handler 进行处理</p>
<p>5）Handler 通过 read 读取数据，分发给后面的 worker 线程处理</p>
<p>6）worker 线程池分配独立的 worker 线程进行业务处理，并返回结果给 Handler</p>
<p>7）Handler 收到响应的结果后，将结果 send 给 client</p>
<p><strong>优点：</strong></p>
<p>父线程和子线程的数据交互简单、职责明确，父线程只需要接收新连接请求、子线程负责非连接的业务请求</p>
<p><strong>缺点：</strong></p>
<p>编程较为复杂</p>
<h2 id="Netty-模型"><a href="#Netty-模型" class="headerlink" title="Netty 模型"></a>Netty 模型</h2><p><img src="/images/Netty/netty_analy.jpg" alt="netty"></p>
<p>1）Netty 中有两组线程池：BossGroup 专门负责接收客户端的连接，WorkerGroup 专门负责网络的读写业务处理。这两组线程池均属于 NioEventLoopGroup。</p>
<p>2）NioEventLoopGroup 相当于一个事件循环组，组内包含多个事件循环线程 NioEventLoop 来进行不断循环执行处理任务，并使用了 selector 监听绑定在其上的 channel。</p>
<p>3）Boss 的 NioEventLoop 执行的步骤分为三步：<br>            轮循 accept 事件<br>            处理 accept 事件，与 client 建立连接，生成 NioSocketChannel，并将其注册到 worker 的 NioEventLoop 上的 selector<br>            处理任务队列的任务</p>
<p>4）worker 的 NioEventLoop 执行同样分为三步：<br>            轮循 read/write 事件<br>            处理 I/O 事件，在对应的 NioSocketChannel 处理，这时候会用到 pipeline 来获取对应的 channel，且使用其中的 handler 来执行处理任务<br>            处理任务队列的任务</p>
<p><strong>例子：</strong></p>
<p>Netty 服务器和客户端的简单通信</p>
<p><strong>NettyServer.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//创建BossGroup和WorkerGroup</span></span><br><span class="line">        <span class="comment">/*说明：</span></span><br><span class="line"><span class="comment">            1.创建两个线程组（boss，worker）</span></span><br><span class="line"><span class="comment">            2.bossGroup 只是处理连接请求，workerGroup是真正与客户端进行业务处理</span></span><br><span class="line"><span class="comment">            3.均为无限循环</span></span><br><span class="line"><span class="comment">            4.bossGroup/workerGroup含有的NioEventLoop的个数（CPU核数*2）</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//8个线程轮循分配</span></span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建服务器端的启动对象，配置参数</span></span><br><span class="line">            ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            <span class="comment">//使用链式编程进行配置</span></span><br><span class="line">            <span class="comment">//设置两个线程组</span></span><br><span class="line">            bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                    <span class="comment">//使用NioServerSocketChannel作为通道类型</span></span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    <span class="comment">//设置线程队列等待连接的个数</span></span><br><span class="line">                    .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                    <span class="comment">//设置保持活动连接状态</span></span><br><span class="line">                    .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                    <span class="comment">//创建一个通道初始化对象（匿名）</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="comment">//给pipeline设置处理器（handler）</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">//可以使用一个集合管理SocketChannel，</span></span><br><span class="line">                            <span class="comment">//Channel推送消息的时候可以将业务推至Channel对应的</span></span><br><span class="line">                            <span class="comment">//NioEventLoop的taskQueue/scheduleTaskQueue</span></span><br><span class="line">                            System.out.println(<span class="string">&quot;client&#x27;s socketChannel hashcode = &quot;</span>+ch.hashCode());</span><br><span class="line">                            <span class="comment">//addLast()向pipeline后面增加一个handler</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;); <span class="comment">//给我们的workerGroup的某一个EventLoop对应的管道(pipeline)设置处理器(handler)</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;----Server is ready----&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//绑定一个端口并且同步，生成了一个ChannelFuture对象</span></span><br><span class="line">            <span class="comment">//启动服务器</span></span><br><span class="line">            ChannelFuture cf = bootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line">            <span class="comment">//给cf注册监听器，监控我们关心的时间</span></span><br><span class="line">            cf.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture channelFuture)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(cf.isSuccess())&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Binding is success, port=6668.&quot;</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;Binding is failed, port=6668.&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对关闭的通道进行监听</span></span><br><span class="line">            cf.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NettyServerHandler.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * 1.我们自定义一个Handler需要继承netty规定好的某个HandlerAdapter</span></span><br><span class="line"><span class="comment"> * 2.这样自定义的handler才能作为handler使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取数据事件（这里我们可以读取客户端发送的消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx 上下文对象 包括pipeline(处理)、channel(I/O)、地址</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 就是客户端发送的数据，默认Object类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Current Thread = &quot;</span>+Thread.currentThread().getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;server ctx = &quot;</span> + ctx);</span><br><span class="line">        <span class="comment">//将 msg 转成一个 ByteBuffer</span></span><br><span class="line">        <span class="comment">//ByteBuf 是 Netty 提供的，并非 NIO 的 ByteBuffer</span></span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;client&#x27;s msg = &quot;</span> + buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;client address = &quot;</span> + ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据读取完毕执行此方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//write + flush 将数据写入缓冲并刷新</span></span><br><span class="line">        <span class="comment">//对发送的数据进行编码</span></span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,client.&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理异常，采用关闭通道的方式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NettyClient.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//客户端需要一个事件循环</span></span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//创建客户端启动对象</span></span><br><span class="line">            <span class="comment">//客户端使用的不是 ServerBootstrap 而是 Bootstrap</span></span><br><span class="line">            Bootstrap bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置相关参数</span></span><br><span class="line">            <span class="comment">//设置线程组</span></span><br><span class="line">            bootstrap.group(group)</span><br><span class="line">                    <span class="comment">//设置客户端通道的实现类</span></span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            <span class="comment">//加入自己的handler</span></span><br><span class="line">                            ch.pipeline().addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;====client is ok====&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//启动客户端，连接服务器端</span></span><br><span class="line">            ChannelFuture channelFuture = bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">6668</span>).sync();</span><br><span class="line">            <span class="comment">//对关闭的通道进行监听</span></span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>NettyClientHandler.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道就绪时就会触发该方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;client &quot;</span> + ctx);</span><br><span class="line">        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="string">&quot;hello,server.&quot;</span>, CharsetUtil.UTF_8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当通道有读取事件时会触发</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">        System.out.println(<span class="string">&quot;server&#x27;s response = &quot;</span>+buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        System.out.println(<span class="string">&quot;server&#x27;s address = &quot;</span>+ctx.channel().remoteAddress());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        cause.printStackTrace();</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Netty异步"><a href="#Netty异步" class="headerlink" title="Netty异步"></a>Netty异步</h2><p><strong>介绍</strong></p>
<p>1）异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的组件在完成后，通过状态、通知和回调来通知调用者。</p>
<p>2）Netty 中的I/O 操作是异步的，包括 Bind、 Write、 Connect 等操作会简单的返回一个 ChannelFuture 。</p>
<p>3）调用者并不能立刻获得结果，而是通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得 I/O 操作结果。</p>
<p>4）Netty 的异步模型是建立在 future 和 callback 之上的。callback 就是回调。重点说 Future , 它的核心思想是：假设一个方法 fun , 计算过程可能非常耗时，等待 fun 返回显然不合适。那么可以在调用 fun 的时候，立马返回一个 Future，后续可以通过 Future 去监控方法 fun 的处理过程，即 Future-Listener 机制。</p>
<p><strong>Future：</strong>表示异步的执行结果，可以通过它提供的方法查看执行是否完成</p>
<p><strong>ChannelFuture：</strong>是一个接口，继承了 Future ，可以为其添加监听器，当监听的事件发生时，就会通知监听器。</p>
<p><strong>Future-Listener 机制</strong></p>
<p>1）当 Future 对象刚刚创建的时候，处于非完成状态，调用者可以通过返回的 ChannelFuture 来获取操作执行的状态，注册监听函数来执行完成后的操作。</p>
<p>2）常用方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>; <span class="comment">//判断当前操作是否完成</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isSuccess</span><span class="params">()</span></span>; <span class="comment">//判断当前操作是否成功</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>; <span class="comment">//判断当前操作是否取消</span></span><br><span class="line"><span class="function">Throwable <span class="title">getCause</span><span class="params">()</span></span>; <span class="comment">//获取当前操作失败的原因</span></span><br><span class="line"><span class="function">ChannelFuture <span class="title">addListener</span><span class="params">()</span></span>; <span class="comment">//注册监听器，操作完成就通知该监听器</span></span><br></pre></td></tr></table></figure>

<p><strong>例子</strong></p>
<p>Netty 服务器监听 6668 端口，浏览器访问 localhost:6668，服务器回复消息</p>
<p><strong>TestServer.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br><span class="line">        EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ServerBootstrap serverBootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">            serverBootstrap.group(bossGroup,workerGroup)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)</span><br><span class="line">                    .childHandler(<span class="keyword">new</span> TestServerInitializer());</span><br><span class="line">            ChannelFuture channelFuture = serverBootstrap.bind(<span class="number">6668</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bossGroup.shutdownGracefully();</span><br><span class="line">            workerGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>TestServerInitializer.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServerInitializer</span> <span class="keyword">extends</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">SocketChannel</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel socketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//向管道加入处理器</span></span><br><span class="line">        <span class="comment">//得到管道</span></span><br><span class="line">        ChannelPipeline pipeline = socketChannel.pipeline();</span><br><span class="line">        <span class="comment">//加入netty提供的httpServerCodec,提供对HTTP的编解码</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;MyHttpServerCodec&quot;</span>,<span class="keyword">new</span> HttpServerCodec());</span><br><span class="line">        <span class="comment">//增加自定义handler</span></span><br><span class="line">        pipeline.addLast(<span class="string">&quot;MyTestHttpServerHandler&quot;</span>,<span class="keyword">new</span> TestHttpServerHandler());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>TestHttpServerHandler.java</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> * 1.SimpleChannelInboundHandler 是 ChannelInboundHandlerAdaptor的子类</span></span><br><span class="line"><span class="comment"> * 2.客户端和服务器端相互通讯的数据被封装成HttpObject</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHttpServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">HttpObject</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取客户端数据</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ctx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 客户端和服务器端相互通讯的数据被封装成HttpObject</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpObject msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//判断msg是不是httpRequest请求</span></span><br><span class="line">        <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> HttpRequest) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;pipeline hashcode = &quot;</span> + ctx.pipeline().hashCode());</span><br><span class="line">            System.out.println(<span class="string">&quot;msg type = &quot;</span> + msg.getClass());</span><br><span class="line">            System.out.println(<span class="string">&quot;client address = &quot;</span> + ctx.channel().remoteAddress());</span><br><span class="line">            <span class="comment">//过滤特定资源</span></span><br><span class="line">            HttpRequest httpRequest = (HttpRequest) msg;</span><br><span class="line">            URI uri = <span class="keyword">new</span> URI(httpRequest.uri());</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;/favicon.ico&quot;</span>.equals(uri.getPath())) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Request for favicon.ico, ignore.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//回复信息给浏览器</span></span><br><span class="line">            ByteBuf content = Unpooled.copiedBuffer(<span class="string">&quot;Hello, I am Server&quot;</span>, CharsetUtil.UTF_8);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//构造一个http的响应，httpResponse</span></span><br><span class="line">            DefaultFullHttpResponse response = <span class="keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.OK, content);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">            response.headers().set(HttpHeaderNames.CONTENT_LENGTH, content.readableBytes());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将构建好的response返回</span></span><br><span class="line">            ctx.writeAndFlush(response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
  <entry>
    <title>Netty核心模块组件</title>
    <url>/2021/09/05/202195-Netty%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>针对 Netty 中较为核心的类进行说明</p>
<span id="more"></span>

<h2 id="Bootstrap、ServerBootstrap"><a href="#Bootstrap、ServerBootstrap" class="headerlink" title="Bootstrap、ServerBootstrap"></a>Bootstrap、ServerBootstrap</h2><p>Bootstrap 的意思是引导，一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置整个 Netty 程序，串联各个组件。客户端对应的是 Bootstrap，服务端则是 ServerBootstrap。</p>
<p><strong>常用方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup parenGroup, EventLoopGroup childGroup)</span></span>; <span class="comment">//用于服务端设置两个 EventLoop</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">group</span><span class="params">(EventLoopGroup group)</span></span>; <span class="comment">//用于客户端设置一个 EventLoop</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class&lt;? extends C&gt; channelClass)</span></span>; <span class="comment">//设置一个服务端的通道实现类别</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">B <span class="title">option</span><span class="params">(ChannelOption&lt;T&gt; option, T value)</span></span>; <span class="comment">//用来给 ServerChannel 添加配置</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">ServerBootstrap <span class="title">childOption</span><span class="params">(ChannelOption&lt;T&gt; childOption, T value)</span></span>; <span class="comment">//用来给接收到的通道添加配置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">childHandler</span><span class="params">(ChannelHandler childHandler)</span></span>; <span class="comment">//设置业务处理类（可以是自定义的Handler）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">int</span> inetPort)</span></span>; <span class="comment">//用于服务端设置占用的端口号</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">connect</span><span class="params">(String inetHost, <span class="keyword">int</span> inetPort)</span></span>; <span class="comment">//用于客户端通过端口来连接服务端</span></span><br></pre></td></tr></table></figure>

<h2 id="Future、ChannelFuture"><a href="#Future、ChannelFuture" class="headerlink" title="Future、ChannelFuture"></a>Future、ChannelFuture</h2><p>Netty 中所有的 I/O 操作都是异步的，不能立刻得知消息是否被正确处理，但是可以选择等待执行完成或者注册一个监听，通过 Future 和 ChannelFuture 来注册一个监听事件，当操作完成后就会自动触发该监听事件。</p>
<p><strong>常用方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Channel <span class="title">channel</span><span class="params">()</span></span>; <span class="comment">//返回当前正在进行I/O操作的通道</span></span><br><span class="line"><span class="function">ChannelFuture <span class="title">sync</span><span class="params">()</span></span>; <span class="comment">//等待异步操作执行完毕</span></span><br></pre></td></tr></table></figure>

<h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><ul>
<li>Netty 网络通信的组件，能够用于执行网络 I/O 操作</li>
<li>通过 Channel 可获得当前网络连接的通道状态和参数配置</li>
<li>Channel 提供异步的网络 I/O 操作（如建立连接、读写、绑定端口），异步调用意味着任何 I/O 调用都可以立即返回，但不保证调用结束时操作已完成</li>
<li>调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以在 I/O 操作完成时回调通知调用方</li>
<li>支持关联 I/O 操作与对应的处理程序</li>
<li>不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应，常用的 Channel 类型：<ul>
<li>NioSocketChannel 异步的客户端 TCPSocket 连接</li>
<li>NioServerSocketChannel 异步的服务端 TCPSocket 连接</li>
<li>NioDatagramChannel 异步的 UDP 连接</li>
<li>NioSctpChannel 异步的客户端 Sctp 连接</li>
<li>NioSctpServerChannel 异步的服务端 Sctp 连接</li>
</ul>
</li>
</ul>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>Netty 基于 Selector 对象实现 I/O 多路复用，通过 Selector 一个线程可以监听多个连接的 Channel 事件。<br>当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询（Select）这些注册的 Channel 是否有已经就绪的 I/O 事件。</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
  </entry>
</search>
