<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IO流归纳</title>
    <url>/2020/05/14/2020514-IO%E6%B5%81%E5%BD%92%E7%BA%B3/</url>
    <content><![CDATA[<p>因为Java的IO流种类多，名字相似，所以本文针对Java中出现的各种IO流进行了归纳总结</p>
<span id="more"></span>

<h2 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h2><h3 id="字节输出流【OutputStream】"><a href="#字节输出流【OutputStream】" class="headerlink" title="字节输出流【OutputStream】"></a>字节输出流【OutputStream】</h3><p>java.io.OutputStream 抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。</p>
<h5 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h5><p><code>public void close()</code>：关闭此输出流并释放与此流相关联的任何系统资源。</p>
<p><code>public void flush()</code>：刷新此输出流并强制任何缓冲的输出字节被写出。</p>
<p><code>public void write(byte[] b)</code>：将 b.length字节从指定的字节数组写入此输出流。</p>
<p><code>public void write(byte[] b, int off, int len)</code>：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。</p>
<p><code>public abstract void write(int b)</code>：将指定的字节输出流。</p>
<blockquote>
<p>close方法，当完成流的操作时，必须调用此方法释放系统资源。</p>
</blockquote>
<h4 id="文件输出流【FileOutputStream类】"><a href="#文件输出流【FileOutputStream类】" class="headerlink" title="文件输出流【FileOutputStream类】"></a>文件输出流【FileOutputStream类】</h4><p><code>java.io.FileOutputStream</code> 类文件输出流，是字节输出流<code>OutputStream</code>的子类，用于将数据写出到文件。</p>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><p><code>public FileOutputStream(File file)</code>：创建文件输出流以写入由指定的 File对象表示的文件。</p>
<p><code>public FileOutputStream(String name)</code>： 创建文件输出流以指定的名称写入文件。</p>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>写出字节：<code>write(int b)</code></p>
<p>写出字节数组：<code>write(byte[] b)</code></p>
<p>写出指定长度字节数组：<code>write(byte[] b, int off, int len)</code></p>
<p>数据追加续写：<code>public FileOutputStream(File file, boolean append)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public FileOutputStream(String name, boolean append)</span><br></pre></td></tr></table></figure>

<p>写出换行：<code>\r\n</code>(windows) <code>\n</code>(linux) <code>\r</code>(mac)</p>
<h3 id="字节输入流【InputStream】"><a href="#字节输入流【InputStream】" class="headerlink" title="字节输入流【InputStream】"></a>字节输入流【InputStream】</h3><p><code>java.io.InputStream</code>抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。</p>
<h5 id="基本方法-1"><a href="#基本方法-1" class="headerlink" title="基本方法"></a>基本方法</h5><p><code>public void close()</code>：关闭此输入流并释放与此流相关联的任何系统资源。</p>
<p><code>public abstract int read()</code>： 从输入流读取数据的下一个字节。</p>
<p><code>public int read(byte[] b)</code> ： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。</p>
<blockquote>
<p>close方法，当完成流的操作时，必须调用此方法释放系统资源。</p>
</blockquote>
<h4 id="文件输入流【FileInputStream类】"><a href="#文件输入流【FileInputStream类】" class="headerlink" title="文件输入流【FileInputStream类】"></a>文件输入流【FileInputStream类】</h4><h5 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h5><p><code>FileInputStream(File file)</code> ： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的 File对象 file命名。</p>
<p><code>FileInputStream(String name)</code>： 通过打开与实际文件的连接来创建一个 FileInputStream ，该文件由文件系统中的路径名 name命名。</p>
<h5 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h5><p>读取字节：<code>read()</code></p>
<p>使用字节数组读取：<code>read(byte[] b)</code></p>
<h2 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h2><h3 id="字符输入流【Reader】"><a href="#字符输入流【Reader】" class="headerlink" title="字符输入流【Reader】"></a>字符输入流【Reader】</h3><p><code>java.io.Reader</code>抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。它定义了字符输入流的基本共性功能方法。</p>
<p><code>public void close()</code>：关闭此流并释放与此流相关联的任何系统资源。</p>
<p><code>public int read()</code>： 从输入流读取一个字符。</p>
<p><code>public int read(char[] cbuf)</code>： 从输入流中读取一些字符，并将它们存储到字符数组 cbuf中 。</p>
<h4 id="文件输入流【FileReader类】"><a href="#文件输入流【FileReader类】" class="headerlink" title="文件输入流【FileReader类】"></a>文件输入流【FileReader类】</h4><h5 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h5><p><code>FileReader(File file)</code> ： 创建一个新的 FileReader ，给定要读取的File对象。</p>
<p><code>FileReader(String fileName)</code> ： 创建一个新的 FileReader ，给定要读取的文件的名称。</p>
<h5 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h5><p>读取字符：<code>read()</code></p>
<p>使用字符数组读取：<code>read(char[] b)</code></p>
<h3 id="字符输出流【Writer】"><a href="#字符输出流【Writer】" class="headerlink" title="字符输出流【Writer】"></a>字符输出流【Writer】</h3><p><code>java.io.Writer</code>抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。它定义了字节</p>
<p>输出流的基本共性功能方法。</p>
<p><code>void write(int c)</code>写入单个字符。</p>
<p><code>void write(char[] cbuf)</code>写入字符数组。</p>
<p><code>abstract void write(char[] cbuf, int off, int len)</code>写入字符数组的某一部分,off数组的开始索引,len 写的字符个数。</p>
<p><code>void write(String str)</code> 写入字符串。</p>
<p><code>void write(String str, int off, int len)</code>写入字符串的某一部分,off字符串的开始索引,len写的字符个数。</p>
<p><code>void flush()</code> 刷新该流的缓冲。</p>
<p><code>void close()</code>关闭此流，但要先刷新它。</p>
<h4 id="文件输出流【FileWriter类】"><a href="#文件输出流【FileWriter类】" class="headerlink" title="文件输出流【FileWriter类】"></a>文件输出流【FileWriter类】</h4><h5 id="构造方法-3"><a href="#构造方法-3" class="headerlink" title="构造方法"></a>构造方法</h5><p><code>FileWriter(File file)</code>： 创建一个新的 FileWriter，给定要读取的File对象。</p>
<p><code>FileWriter(String fileName)</code>： 创建一个新的 FileWriter，给定要读取的文件的名称。</p>
<h5 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h5><p>写出字符：<code>write(int b)</code></p>
<p>写出字符数组：<code>write(char[] cbuf)</code>和 <code>write(char[] cbuf, int off, int len)</code></p>
<p>写出字符串：<code>write(String str)</code>和<code>write(String str, int off, int len)</code></p>
<p>续写和换行：操作类似于<code>FileOutputStream</code>。</p>
<h2 id="缓冲流"><a href="#缓冲流" class="headerlink" title="缓冲流"></a>缓冲流</h2><h3 id="字节缓冲流【BufferedInputStream】"><a href="#字节缓冲流【BufferedInputStream】" class="headerlink" title="字节缓冲流【BufferedInputStream】"></a>字节缓冲流【BufferedInputStream】</h3><h4 id="构造方法-4"><a href="#构造方法-4" class="headerlink" title="构造方法"></a>构造方法</h4><p><code>public BufferedInputStream(InputStream in)</code>：创建一个 新的缓冲输入流。</p>
<p><code>public BufferedOutputStream(OutputStream out)</code>：创建一个新的缓冲输出流。</p>
<h3 id="字符缓冲流-【BufferedReader】"><a href="#字符缓冲流-【BufferedReader】" class="headerlink" title="字符缓冲流 【BufferedReader】"></a>字符缓冲流 【BufferedReader】</h3><h4 id="构造方法-5"><a href="#构造方法-5" class="headerlink" title="构造方法"></a>构造方法</h4><p><code>public BufferedReader(Reader in)</code>：创建一个 新的缓冲输入流。</p>
<p><code>public BufferedWriter(Writer out)</code>： 创建一个新的缓冲输出流。</p>
<h4 id="特有方法"><a href="#特有方法" class="headerlink" title="特有方法"></a>特有方法</h4><p><strong>BufffferedReader</strong>：<code>public String readLine()</code>: 读一行文字。</p>
<p><strong>BufffferedWriter</strong>：<code>public void newLine()</code>: 写一行行分隔符,由系统属性定义符号。</p>
<h2 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h2><h3 id="InputStreamReader类"><a href="#InputStreamReader类" class="headerlink" title="InputStreamReader类"></a>InputStreamReader类</h3><p><code>InputStreamReader(InputStream in)</code>: 创建一个使用默认字符集的字符流。 <code>InputStreamReader(InputStream in, String charsetName)</code>: 创建一个指定字符集(UTF-8, UTF-16, GBK)的字符流。</p>
<h3 id="OutputStreamWriter类"><a href="#OutputStreamWriter类" class="headerlink" title="OutputStreamWriter类"></a>OutputStreamWriter类</h3><p><code>OutputStreamWriter(OutputStream in)</code>: 创建一个使用默认字符集的字符流。 <code>OutputStreamWriter(OutputStream in, String charsetName)</code>: 创建一个指定字符集(UTF-8, UTF-16, GBK)的字符流。</p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="ObjectOutputStream类"><a href="#ObjectOutputStream类" class="headerlink" title="ObjectOutputStream类"></a>ObjectOutputStream类</h3><p><code>public ObjectOutputStream(OutputStream out)</code>：创建一个指定OutputStream的ObjectOutputStream。</p>
<h4 id="序列化操作"><a href="#序列化操作" class="headerlink" title="序列化操作"></a>序列化操作</h4><p>1.一个对象要想序列化，必须满足两个条件: 该类必须实现<code>java.io.Serializable</code>接口， <code>Serializable</code> 是一个<strong>标记接口</strong>，不实现此接口的类将不会使任 何状态序列化或反序列化，会抛出 <code>NotSerializableException</code>。 该类的所有属性必须是可序列化的。如果有一个<strong>属性不需要可序列化</strong>的，则该属性必须注明是瞬态的，使用 <code>transient</code>关键字修饰。</p>
<p>2.写出对象方法<code>public final void writeObject (Object obj)</code> : 将指定的对象写出。</p>
<h3 id="ObjectInputStream类"><a href="#ObjectInputStream类" class="headerlink" title="ObjectInputStream类"></a>ObjectInputStream类</h3><p><code>public ObjectInputStream(InputStream in)</code> ： 创建一个指定InputStream的ObjectInputStream。</p>
<h4 id="反序列化操作1"><a href="#反序列化操作1" class="headerlink" title="反序列化操作1"></a>反序列化操作1</h4><p>如果能找到一个对象的class文件，我们可以进行反序列化操作，调用 ObjectInputStream 读取对象的方法：<code>public final Object readObject ()</code>: 读取一个对象。</p>
<p>对于JVM可以反序列化对象，它必须是能够找到class文件的类。如果找不到该类的class文件，则抛出一个 <code>ClassNotFoundException</code>异常。</p>
<h4 id="反序列化操作2"><a href="#反序列化操作2" class="headerlink" title="反序列化操作2"></a>反序列化操作2</h4><p>另外，当JVM反序列化对象时，能找到class文件，但是class文件在序列化对象之后发生了修改，那么反序列化操 作也会失败，抛出一个 InvalidClassException 异常。</p>
<p>发生这个异常的原因如下：</p>
<ul>
<li>该类的序列版本号与从流中读取的类描述符的版本号不匹配</li>
<li>该类包含未知数据类型</li>
<li>该类没有可访问的无参数构造方法 Serializable 接口给需要序列化的类，提供了一个序列版本号</li>
</ul>
<p>serialVersionUID 该版本号的目的在于验证序 列化的对象和对应类是否版本匹配。</p>
<h2 id="打印流"><a href="#打印流" class="headerlink" title="打印流"></a>打印流</h2><p>平时我们在控制台打印输出，是调用 <code>print</code> 方法和 <code>println</code>方法完成的，这两个方法都来自于<code>java.io.PrintStream</code> 类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</p>
<h3 id="PrintStream类"><a href="#PrintStream类" class="headerlink" title="PrintStream类"></a>PrintStream类</h3><h4 id="构造方法-6"><a href="#构造方法-6" class="headerlink" title="构造方法"></a>构造方法</h4><p><code>public PrintStream(String fileName)</code>： 使用指定的文件名创建一个新的打印流。</p>
<h4 id="改变打印流向"><a href="#改变打印流向" class="headerlink" title="改变打印流向"></a>改变打印流向</h4><p>System.out 就是 PrintStream 类型的，只不过它的流向是系统规定的，打印在控制台上。不过，既然是流对象， 我们就可以玩一个”小把戏”，改变它的流向。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintDemo</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">             <span class="comment">// 调用系统的打印流,控制台直接输出97</span></span><br><span class="line">             System.out.println(<span class="number">97</span>);</span><br><span class="line">             <span class="comment">// 创建打印流,指定文件的名称</span></span><br><span class="line">             PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">&quot;ps.txt&quot;</span>);</span><br><span class="line">             <span class="comment">// 设置系统的打印流流向,输出到ps.txt</span></span><br><span class="line">             System.setOut(ps);</span><br><span class="line">             <span class="comment">// 调用系统的打印流,ps.txt中输出97</span></span><br><span class="line">             System.out.println(<span class="number">97</span>);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>知识整理</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL基础语法</title>
    <url>/2020/05/24/2020524-MySQL%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>对数据库进行操作的基本SQL(DDL DML DQL DCL)</p>
<span id="more"></span>

<h2 id="什么是SQL"><a href="#什么是SQL" class="headerlink" title="什么是SQL"></a>什么是SQL</h2><p>Structured Query Language 结构化查询语言</p>
<h2 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h2><ol>
<li><p>Data Definition Language (DDL 数据定义语言) 如：建库，建表</p>
</li>
<li><p>Data Manipulation Language(DML 数据操纵语言)如：对表中的记录操作增删改</p>
</li>
<li><p>Data Query Language(DQL 数据查询语言)如：对表中的查询操作</p>
</li>
<li><p>Data Control Language(DCL 数据控制语言)如：对用户权限的设置</p>
</li>
</ol>
<h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><h3 id="对库操作"><a href="#对库操作" class="headerlink" title="对库操作"></a>对库操作</h3><ul>
<li><strong>创建数据库</strong><br><code>CREATE DATABASE 数据库名;</code><br><strong>判断</strong>数据库是否已经存在，不存在则创建数据库<br><code>CREATE DATABASE IF NOT EXISTS 数据库名;</code><br>创建数据库并<strong>指定字符集</strong><br><code>CREATE DATABASE 数据库名 CHARACTER SET 字符集;</code></li>
<li><strong>查看数据库</strong><br>– 查看<strong>所有</strong>的数据库 <code>show databases;</code><br>– 查看<strong>某个</strong>数据库的定义信息 <code>show create database db3;</code></li>
<li><strong>修改数据库</strong><br>修改数据库默认的<strong>字符集</strong><br><code>ALTER DATABASE 数据库名 DEFAULT CHARACTER SET 字符集;</code></li>
<li><strong>删除数据库</strong><br><code>DROP DATABASE 数据库名;</code></li>
<li><strong>使用数据库</strong><br><strong>查看</strong>正在使用的数据库 <code>SELECT DATABASE();</code><br>使用的一个 MySQL中的全局函数 <strong>使用</strong>/<strong>切换</strong>数据库 <code>USE 数据库名;</code></li>
</ul>
<h3 id="对表操作"><a href="#对表操作" class="headerlink" title="对表操作"></a>对表操作</h3><ul>
<li><strong>创建表</strong><br><code>CREATE TABLE 表名 ( 字段名 1 字段类型 1, 字段名 2 字段类型 2 --最后一个字段无分号 );</code><br>快速创建一个<strong>表结构相同</strong>的表<br><code>CREATE TABLE 新表名 LIKE 旧表名;</code></li>
<li><strong>查看表</strong><br>查看某个数据库中的<strong>所有表</strong><br><code>SHOW TABLES;</code><br>查看<strong>表结构</strong><br><code>DESC 表名;</code><br><strong>查看创建表</strong><br><code>SHOW CREATE TABLE 表名;</code></li>
<li><strong>删除表</strong><br><strong>直接</strong>删除表 <code>DROP TABLE 表名;</code><br><strong>判断</strong>表是否存在，如果存在则删除表<br><code>DROP TABLE IF EXISTS 表名;</code></li>
<li><strong>修改表</strong><br>添加<strong>表列</strong><br><code>ALTER TABLE 表名 ADD 列名 类型;</code><br>修改<strong>列类型</strong><br><code>ALTER TABLE 表名 MODIFY 列名 新的类型;</code><br>修改<strong>列名</strong><br><code>ALTER TABLE 表名 CHANGE 旧列名 新列名 类型;</code><br><strong>删除列</strong><br><code>ALTER TABLE 表名 DROP 列名;</code></li>
</ul>
<h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><h3 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h3><ul>
<li><strong>插入记录</strong><br><code>INSERT [INTO] 表名 [字段名] VALUES (字段值);</code><br><code> --INSERT INTO 表名：表示往哪张表中添加数据 (字段名 1, 字段名 2, …)：要给哪些字段设置值 VALUES (值 1, 值 2, …)：设置具体的值</code></li>
<li><strong>表的复制</strong><br>将表名 2 中的<strong>所有的列复制</strong>到表名 1 中<br><code>INSERT INTO 表名 1 SELECT * FROM 表名 2;</code><br>只复制<strong>部分列</strong><br><code>INSERT INTO 表名 1(列 1, 列 2) SELECT 列 1, 列 2 FROM student;</code></li>
<li><strong>更新表记录</strong><br><code>UPDATE 表名 SET 列名=值 [WHERE 条件表达式]; </code><br><code>--UPDATE: 需要更新的表名 SET: 修改的列值 WHERE: 符合条件的记录才更新 你可以同时更新一个或多个字段。 你可以在 WHERE 子句中指定任何条件。</code></li>
<li><strong>删除表记录</strong><br><code>DELETE FROM 表名 [WHERE 条件表达式]</code><br><code>--如果没有指定 WHERE 子句，MySQL 表中的所有记录将被删除。 你可以在 WHERE 子句中指定任何条件</code></li>
</ul>
<h2 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h2><h3 id="查询表"><a href="#查询表" class="headerlink" title="查询表"></a>查询表</h3><ul>
<li><p>查询表<strong>所有</strong>行和列的数据<br><code>使用*表示所有列</code><br><code>SELECT * FROM 表名;</code></p>
</li>
<li><p>查询<strong>指定列</strong>的数据,多个列之间以逗号分隔<br><code>SELECT 字段名 1, 字段名 2, 字段名 3, ... FROM 表名;</code></p>
</li>
<li><p>对列指定<strong>别名</strong><br><code>SELECT 字段名 1 AS 别名, 字段名 2 AS 别名... FROM 表名;</code></p>
</li>
<li><p>对列和表同时指定<strong>别名</strong><br><code>SELECT 字段名 1 AS 别名, 字段名 2 AS 别名... FROM 表名 AS 表别名;</code></p>
</li>
<li><p>查询指定列并且结果<strong>不出现重复数据</strong><br><code>SELECT DISTINCT 字段名 FROM 表名;</code></p>
</li>
<li><p>某列数据和固定值<strong>运算</strong><br><code>SELECT 列名 1 + 固定值 FROM 表名;</code></p>
</li>
<li><p>某列数据和其他列数据参与<strong>运算</strong><br> <code>SELECT 列名 1 + 列名 2 FROM 表名;</code></p>
</li>
<li><p>条件查询</p>
<p>的语法 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 字段名 FROM 表名 WHERE 条件;</span><br></pre></td></tr></table></figure>

<p>流程：取出表中的每条数据，满足条件的记录就返回，不满足条件的记录不返回</p>
<ul>
<li><strong>in</strong> 关键字<br><code>SELECT 字段名 FROM 表名 WHERE 字段 in (数据 1, 数据 2...);</code><br>in 里面的每个数据都会作为一次条件，只要满足条件的就会显示</li>
<li><strong>between</strong> 关键字<br><code>BETWEEN 值 1 AND 值 2;</code><br>表示从值 1 到值 2 范围，包头又包尾 比如：age BETWEEN 80 AND 100 相当于： age&gt;=80 &amp;&amp; age&lt;=100</li>
<li><strong>like</strong> 关键字<br>LIKE 表示模糊查询<br><code>SELECT * FROM 表名 WHERE 字段名 LIKE &#39;通配符字符串&#39;;</code></li>
<li>MySQL <strong>通配符</strong><br> <strong>‘%’</strong> 匹配任意<strong>多</strong>个字符串<br><strong>‘_’</strong> 匹配<strong>一</strong>个字符</li>
</ul>
</li>
</ul>
<h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2><h3 id="操作用户"><a href="#操作用户" class="headerlink" title="操作用户"></a>操作用户</h3><ul>
<li><p><strong>创建</strong><br><code>CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</code></p>
</li>
<li><p><strong>授权</strong><br><code>GRANT 权限 1, 权限 2... ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;</code><br><img src="/images/MySQL-Grant.png" alt="MySQL-Grant"></p>
</li>
<li><p><strong>撤销授权</strong><br><code>REVOKE 权限 1, 权限 2... ON 数据库.表名 revoke all on test.* from &#39;user1&#39;@&#39;localhost&#39;; </code><br><code>&#39;用户名&#39;@&#39;主机名&#39;;</code></p>
</li>
<li><p><strong>查看权限</strong><br><code>SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;</code></p>
</li>
<li><p><strong>删除用户</strong><br><code>DROP USER &#39;用户名&#39;@&#39;主机名&#39;;</code></p>
</li>
<li><p><strong>修改管理员密码</strong><br><code>mysqladmin -uroot -p password 新密码;</code></p>
</li>
<li><p><strong>修改普通用户密码</strong><br><code>set password for &#39;用户名&#39;@&#39;主机名&#39; = password(&#39;新密码&#39;);</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>博客搭建第一天</title>
    <url>/2020/05/07/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><img src="/images/Frist.gif"></p>
]]></content>
      <categories>
        <category>随心</category>
      </categories>
  </entry>
  <entry>
    <title>【转载】Java基础知识大纲</title>
    <url>/2020/05/08/202058-%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%A4%A7%E7%BA%B2/</url>
    <content><![CDATA[<p>JavaGuide哥整理的一些基础知识问答</p>
<p><strong>全文转载自：</strong><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md</a></p>
<span id="more"></span>

<h2 id="1-面向对象和面向过程的区别"><a href="#1-面向对象和面向过程的区别" class="headerlink" title="1. 面向对象和面向过程的区别"></a>1. 面向对象和面向过程的区别</h2><ul>
<li><strong>面向过程</strong> ：<strong>面向过程性能比面向对象高。</strong> 因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，<strong>面向过程没有面向对象易维护、易复用、易扩展。</strong></li>
<li><strong>面向对象</strong> ：<strong>面向对象易维护、易复用、易扩展。</strong> 因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。但是，<strong>面向对象性能比面向过程低</strong>。</li>
</ul>
<p>参见 issue : <a href="https://github.com/Snailclimb/JavaGuide/issues/431">面向过程 ：面向过程性能比面向对象高？？</a></p>
<blockquote>
<p>这个并不是根本原因，面向过程也需要分配内存，计算内存偏移量，Java 性能差的主要原因并不是因为它是面向对象语言，而是 Java 是半编译语言，最终的执行代码并不是可以直接被 CPU 执行的二进制机械码。</p>
<p>而面向过程语言大多都是直接编译成机械码在电脑上执行，并且其它一些面向过程的脚本语言性能也并不一定比 Java 好。</p>
</blockquote>
<h2 id="2-Java-语言有哪些特点"><a href="#2-Java-语言有哪些特点" class="headerlink" title="2. Java 语言有哪些特点?"></a>2. Java 语言有哪些特点?</h2><ol>
<li>简单易学；</li>
<li>面向对象（封装，继承，多态）；</li>
<li>平台无关性（ Java 虚拟机实现平台无关性）；</li>
<li>可靠性；</li>
<li>安全性；</li>
<li>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</li>
<li>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</li>
<li>编译与解释并存；</li>
</ol>
<blockquote>
<p>修正（参见： <a href="https://github.com/Snailclimb/JavaGuide/issues/544">issue#544</a>）：C++11 开始（2011 年的时候）,C++就引入了多线程库，在 windows、linux、macos 都可以使用<code>std::thread</code>和<code>std::async</code>来创建线程。参考链接：<a href="http://www.cplusplus.com/reference/thread/thread/?kw=thread">http://www.cplusplus.com/reference/thread/thread/?kw=thread</a></p>
</blockquote>
<h2 id="3-关于-JVM-JDK-和-JRE-最详细通俗的解答"><a href="#3-关于-JVM-JDK-和-JRE-最详细通俗的解答" class="headerlink" title="3. 关于 JVM JDK 和 JRE 最详细通俗的解答"></a>3. 关于 JVM JDK 和 JRE 最详细通俗的解答</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p>
<p><strong>什么是字节码?采用字节码的好处是什么?</strong></p>
<blockquote>
<p>在 Java 中，JVM 可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
</blockquote>
<p><strong>Java 程序从源代码到运行一般有下面 3 步：</strong></p>
<p><img src="/images/Java%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="Java程序运行过程"></p>
<p>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。</p>
<blockquote>
<p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9 引入了一种新的编译模式 AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了 JIT 预热等各方面的开销。JDK 支持分层编译和 AOT 协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p>
</blockquote>
<p><strong>总结：</strong></p>
<p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p>
<h3 id="JDK-和-JRE"><a href="#JDK-和-JRE" class="headerlink" title="JDK 和 JRE"></a>JDK 和 JRE</h3><p>JDK 是 Java Development Kit，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p>
<p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p>
<p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p>
<h2 id="4-Oracle-JDK-和-OpenJDK-的对比"><a href="#4-Oracle-JDK-和-OpenJDK-的对比" class="headerlink" title="4. Oracle JDK 和 OpenJDK 的对比"></a>4. Oracle JDK 和 OpenJDK 的对比</h2><p>可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么 Oracle 和 OpenJDK 之间是否存在重大差异？下面我通过收集到的一些资料，为你解答这个被很多人忽视的问题。</p>
<p>对于 Java 7，没什么关键的地方。OpenJDK 项目主要基于 Sun 捐赠的 HotSpot 源代码。此外，OpenJDK 被选为 Java 7 的参考实现，由 Oracle 工程师维护。关于 JVM，JDK，JRE 和 OpenJDK 之间的区别，Oracle 博客帖子在 2012 年有一个更详细的答案：</p>
<blockquote>
<p>问：OpenJDK 存储库中的源代码与用于构建 Oracle JDK 的代码之间有什么区别？</p>
<p>答：非常接近 - 我们的 Oracle JDK 版本构建过程基于 OpenJDK 7 构建，只添加了几个部分，例如部署代码，其中包括 Oracle 的 Java 插件和 Java WebStart 的实现，以及一些封闭的源代码派对组件，如图形光栅化器，一些开源的第三方组件，如 Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源 Oracle JDK 的所有部分，除了我们考虑商业功能的部分。</p>
</blockquote>
<p><strong>总结：</strong></p>
<ol>
<li>Oracle JDK 大概每 6 个月发一次主要版本，而 OpenJDK 版本大概每三个月发布一次。但这不是固定的，我觉得了解这个没啥用处。详情参见：<a href="https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence">https://blogs.oracle.com/java-platform-group/update-and-faq-on-the-java-se-release-cadence</a> 。</li>
<li>OpenJDK 是一个参考模型并且是完全开源的，而 Oracle JDK 是 OpenJDK 的一个实现，并不是完全开源的；</li>
<li>Oracle JDK 比 OpenJDK 更稳定。OpenJDK 和 Oracle JDK 的代码几乎相同，但 Oracle JDK 有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择 Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用 OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到 Oracle JDK 就可以解决问题；</li>
<li>在响应性和 JVM 性能方面，Oracle JDK 与 OpenJDK 相比提供了更好的性能；</li>
<li>Oracle JDK 不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本；</li>
<li>Oracle JDK 根据二进制代码许可协议获得许可，而 OpenJDK 根据 GPL v2 许可获得许可。</li>
</ol>
<h2 id="5-Java-和-C-的区别"><a href="#5-Java-和-C-的区别" class="headerlink" title="5. Java 和 C++的区别?"></a>5. Java 和 C++的区别?</h2><p>我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过 C++，也要记下来！</p>
<ul>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
<li>Java 不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li>
<li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li>
<li><strong>在 C 语言中，字符串或字符数组最后都会有一个额外的字符‘\0’来表示结束。但是，Java 语言中没有结束符这一概念。</strong> 这是一个值得深度思考的问题，具体原因推荐看这篇文章： <a href="https://blog.csdn.net/sszgg2006/article/details/49148189">https://blog.csdn.net/sszgg2006/article/details/49148189</a></li>
</ul>
<h2 id="6-什么是-Java-程序的主类-应用程序和小程序的主类有何不同"><a href="#6-什么是-Java-程序的主类-应用程序和小程序的主类有何不同" class="headerlink" title="6. 什么是 Java 程序的主类 应用程序和小程序的主类有何不同?"></a>6. 什么是 Java 程序的主类 应用程序和小程序的主类有何不同?</h2><p>一个程序中可以有多个类，但只能有一个类是主类。在 Java 应用程序中，这个主类是指包含 main（）方法的类。而在 Java 小程序中，这个主类是一个继承自系统类 JApplet 或 Applet 的子类。应用程序的主类不一定要求是 public 类，但小程序的主类要求必须是 public 类。主类是 Java 程序执行的入口点。</p>
<h2 id="7-Java-应用程序与小程序之间有哪些差别"><a href="#7-Java-应用程序与小程序之间有哪些差别" class="headerlink" title="7. Java 应用程序与小程序之间有哪些差别?"></a>7. Java 应用程序与小程序之间有哪些差别?</h2><p>简单说应用程序是从主线程启动(也就是 <code>main()</code> 方法)。applet 小程序没有 <code>main()</code> 方法，主要是嵌在浏览器页面上运行(调用<code>init()</code>或者<code>run()</code>来启动)，嵌入浏览器这点跟 flash 的小游戏类似。</p>
<h2 id="8-字符型常量和字符串常量的区别"><a href="#8-字符型常量和字符串常量的区别" class="headerlink" title="8. 字符型常量和字符串常量的区别?"></a>8. 字符型常量和字符串常量的区别?</h2><ol>
<li>形式上: 字符常量是单引号引起的一个字符; 字符串常量是双引号引起的若干个字符</li>
<li>含义上: 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)</li>
<li>占内存大小 字符常量只占 2 个字节; 字符串常量占若干个字节 (<strong>注意： char 在 Java 中占两个字节</strong>)</li>
</ol>
<blockquote>
<p>java 编程思想第四版：2.2.2 节 <img src="/images/Java%E5%90%84%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F.png" alt="img"></p>
</blockquote>
<h2 id="9-构造器-Constructor-是否可被-override"><a href="#9-构造器-Constructor-是否可被-override" class="headerlink" title="9. 构造器 Constructor 是否可被 override?"></a>9. 构造器 Constructor 是否可被 override?</h2><p>Constructor 不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>
<h2 id="10-重载和重写的区别"><a href="#10-重载和重写的区别" class="headerlink" title="10. 重载和重写的区别"></a>10. 重载和重写的区别</h2><blockquote>
<p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p>
<p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>
</blockquote>
<h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>
<p>下面是《Java 核心技术》对重载这个概念的介绍：</p>
<p><img src="/images/java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF-%E9%87%8D%E8%BD%BD.jpg" alt="img"></p>
<p><strong>综上：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</strong></p>
<h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 private/final/static 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
<p><strong>综上：重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变</strong></p>
<p><strong>暖心的 Guide 哥最后再来个图标总结一下！</strong></p>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载方法</th>
<th>重写方法</th>
</tr>
</thead>
<tbody><tr>
<td>发生范围</td>
<td>同一个类</td>
<td>子类 中</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>一定不能修改</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>可以减少或删除，一定不能抛出新的或者更广的异常</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译期</td>
<td>运行期</td>
</tr>
</tbody></table>
<h2 id="11-Java-面向对象编程三大特性-封装-继承-多态"><a href="#11-Java-面向对象编程三大特性-封装-继承-多态" class="headerlink" title="11. Java 面向对象编程三大特性: 封装 继承 多态"></a>11. Java 面向对象编程三大特性: 封装 继承 多态</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。</p>
<p><strong>关于继承如下 3 点请记住：</strong></p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。（以后介绍）。</li>
</ol>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>所谓多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<p>在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>
<h2 id="12-String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的"><a href="#12-String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的" class="headerlink" title="12. String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?"></a>12. String StringBuffer 和 StringBuilder 的区别是什么? String 为什么是不可变的?</h2><p><strong>可变性</strong></p>
<p>简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，<code>private final char value[]</code>，所以 String 对象是不可变的。</p>
<blockquote>
<p>补充（来自<a href="https://github.com/Snailclimb/JavaGuide/issues/675">issue 675</a>）：在 Java 9 之后，String 类的实现改用 byte 数组存储字符串 <code>private final byte[] value</code>;</p>
</blockquote>
<p>而 StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p>
<p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的，大家可以自行查阅源码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractStringBuilder.java</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The value is used for character storage.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The count is the number of characters used.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>线程安全性</strong></p>
<p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><strong>性能</strong></p>
<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><strong>对于三者使用的总结：</strong></p>
<ol>
<li>操作少量的数据: 适用 String</li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder</li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</li>
</ol>
<h2 id="13-自动装箱与拆箱"><a href="#13-自动装箱与拆箱" class="headerlink" title="13. 自动装箱与拆箱"></a>13. 自动装箱与拆箱</h2><ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<p>更多内容见：<a href="https://www.cnblogs.com/dolphin0520/p/3780005.html">深入剖析 Java 中的装箱和拆箱</a></p>
<h2 id="14-在一个静态方法内调用一个非静态成员为什么是非法的"><a href="#14-在一个静态方法内调用一个非静态成员为什么是非法的" class="headerlink" title="14. 在一个静态方法内调用一个非静态成员为什么是非法的?"></a>14. 在一个静态方法内调用一个非静态成员为什么是非法的?</h2><p>由于静态方法可以不通过对象进行调用，因此在静态方法里，不能调用其他非静态变量，也不可以访问非静态变量成员。</p>
<h2 id="15-在-Java-中定义一个不做事且没有参数的构造方法的作用"><a href="#15-在-Java-中定义一个不做事且没有参数的构造方法的作用" class="headerlink" title="15. 在 Java 中定义一个不做事且没有参数的构造方法的作用"></a>15. 在 Java 中定义一个不做事且没有参数的构造方法的作用</h2><p>Java 程序在执行子类的构造方法之前，如果没有用 <code>super()</code>来调用父类特定的构造方法，则会调用父类中“没有参数的构造方法”。因此，如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 <code>super()</code>来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。解决办法是在父类里加上一个不做事且没有参数的构造方法。</p>
<h2 id="16-import-java-和-javax-有什么区别？"><a href="#16-import-java-和-javax-有什么区别？" class="headerlink" title="16. import java 和 javax 有什么区别？"></a>16. import java 和 javax 有什么区别？</h2><p>刚开始的时候 JavaAPI 所必需的包是 java 开头的包，javax 当时只是扩展 API 包来使用。然而随着时间的推移，javax 逐渐地扩展成为 Java API 的组成部分。但是，将扩展从 javax 包移动到 java 包确实太麻烦了，最终会破坏一堆现有的代码。因此，最终决定 javax 包将成为标准 API 的一部分。</p>
<p>所以，实际上 java 和 javax 没有区别。这都是一个名字。</p>
<h2 id="17-接口和抽象类的区别是什么？"><a href="#17-接口和抽象类的区别是什么？" class="headerlink" title="17. 接口和抽象类的区别是什么？"></a>17. 接口和抽象类的区别是什么？</h2><ol>
<li>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li>
<li>接口中除了 static、final 变量，不能有其他变量，而抽象类中则不一定。</li>
<li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过 extends 关键字扩展多个接口。</li>
<li>接口方法默认修饰符是 public，抽象方法可以有 public、protected 和 default 这些修饰符（抽象方法就是为了被重写所以不能使用 private 关键字修饰！）。</li>
<li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li>
</ol>
<p>备注：</p>
<ol>
<li>在 JDK8 中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。(详见 issue:<a href="https://github.com/Snailclimb/JavaGuide/issues/146%E3%80%82">https://github.com/Snailclimb/JavaGuide/issues/146。</a></li>
<li>jdk9 的接口被允许定义私有方法 。</li>
</ol>
<p>总结一下 jdk7~jdk9 Java 中接口概念的变化（<a href="https://www.geeksforgeeks.org/private-methods-java-9-interfaces/">相关阅读</a>）：</p>
<ol>
<li>在 jdk 7 或更早版本中，接口里面只能有常量变量和抽象方法。这些接口方法必须由选择实现接口的类实现。</li>
<li>jdk8 的时候接口可以有默认方法和静态方法功能。</li>
<li>Jdk 9 在接口中引入了私有方法和私有静态方法。</li>
</ol>
<h2 id="18-成员变量与局部变量的区别有哪些？"><a href="#18-成员变量与局部变量的区别有哪些？" class="headerlink" title="18. 成员变量与局部变量的区别有哪些？"></a>18. 成员变量与局部变量的区别有哪些？</h2><ol>
<li>从语法形式上看:成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被 public,private,static 等修饰符所修饰，而局部变量不能被访问控制修饰符及 static 所修饰；但是，成员变量和局部变量都能被 final 所修饰。</li>
<li>从变量在内存中的存储方式来看:如果成员变量是使用<code>static</code>修饰的，那么这个成员变量是属于类的，如果没有使用<code>static</code>修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li>
<li>从变量在内存中的生存时间上看:成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动消失。</li>
<li>成员变量如果没有被赋初值:则会自动以类型的默认值而赋值（一种情况例外:被 final 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li>
</ol>
<h2 id="19-创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#19-创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="19. 创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>19. 创建一个对象用什么运算符?对象实体与对象引用有何不同?</h2><p>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p>
<h2 id="20-什么是方法的返回值-返回值在类的方法里的作用是什么"><a href="#20-什么是方法的返回值-返回值在类的方法里的作用是什么" class="headerlink" title="20. 什么是方法的返回值?返回值在类的方法里的作用是什么?"></a>20. 什么是方法的返回值?返回值在类的方法里的作用是什么?</h2><p>方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用:接收出结果，使得它可以用于其他的操作！</p>
<h2 id="21-一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么"><a href="#21-一个类的构造方法的作用是什么-若一个类没有声明构造方法，该程序能正确执行吗-为什么" class="headerlink" title="21. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?"></a>21. 一个类的构造方法的作用是什么? 若一个类没有声明构造方法，该程序能正确执行吗? 为什么?</h2><p>主要作用是完成对类对象的初始化工作。可以执行。因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。</p>
<h2 id="22-构造方法有哪些特性？"><a href="#22-构造方法有哪些特性？" class="headerlink" title="22. 构造方法有哪些特性？"></a>22. 构造方法有哪些特性？</h2><ol>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ol>
<h2 id="23-静态方法和实例方法有何不同"><a href="#23-静态方法和实例方法有何不同" class="headerlink" title="23. 静态方法和实例方法有何不同"></a>23. 静态方法和实例方法有何不同</h2><ol>
<li>在外部调用静态方法时，可以使用”类名.方法名”的方式，也可以使用”对象名.方法名”的方式。而实例方法只有后面这种方式。也就是说，调用静态方法可以无需创建对象。</li>
<li>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法则无此限制。</li>
</ol>
<h2 id="24-对象的相等与指向他们的引用相等-两者有什么不同"><a href="#24-对象的相等与指向他们的引用相等-两者有什么不同" class="headerlink" title="24. 对象的相等与指向他们的引用相等,两者有什么不同?"></a>24. 对象的相等与指向他们的引用相等,两者有什么不同?</h2><p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p>
<h2 id="25-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是"><a href="#25-在调用子类构造方法之前会先调用父类没有参数的构造方法-其目的是" class="headerlink" title="25. 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?"></a>25. 在调用子类构造方法之前会先调用父类没有参数的构造方法,其目的是?</h2><p>帮助子类做初始化工作。</p>
<h2 id="26-与-equals-重要"><a href="#26-与-equals-重要" class="headerlink" title="26. == 与 equals(重要)"></a>26. == 与 equals(重要)</h2><p><strong>==</strong> : 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象(基本数据类型==比较的是值，引用数据类型==比较的是内存地址)。</p>
<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>
<ul>
<li>情况 1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li>
<li>情况 2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li>
</ul>
<p><strong>举个例子：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String a = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// a 为一个引用</span></span><br><span class="line">        String b = <span class="keyword">new</span> String(<span class="string">&quot;ab&quot;</span>); <span class="comment">// b为另一个引用,对象的内容一样</span></span><br><span class="line">        String aa = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 放在常量池中</span></span><br><span class="line">        String bb = <span class="string">&quot;ab&quot;</span>; <span class="comment">// 从常量池中查找</span></span><br><span class="line">        <span class="keyword">if</span> (aa == bb) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aa==bb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a == b) <span class="comment">// false，非同一对象</span></span><br><span class="line">            System.out.println(<span class="string">&quot;a==b&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (a.equals(b)) <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;aEQb&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">42</span> == <span class="number">42.0</span>) &#123; <span class="comment">// true</span></span><br><span class="line">            System.out.println(<span class="string">&quot;true&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<ul>
<li>String 中的 equals 方法是被重写过的，因为 object 的 equals 方法是比较的对象的内存地址，而 String 的 equals 方法比较的是对象的值。</li>
<li>当创建 String 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 String 对象。</li>
</ul>
<h2 id="27-hashCode-与-equals-重要"><a href="#27-hashCode-与-equals-重要" class="headerlink" title="27. hashCode 与 equals (重要)"></a>27. hashCode 与 equals (重要)</h2><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写 equals 时必须重写 hashCode 方法？”</p>
<h3 id="hashCode（）介绍"><a href="#hashCode（）介绍" class="headerlink" title="hashCode（）介绍"></a>hashCode（）介绍</h3><p>hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode() 定义在 JDK 的 Object.java 中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。</p>
<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>
<h3 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h3><p><strong>我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</strong> 当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与该位置其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet 会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 <code>equals()</code>方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。（摘自我的 Java 启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
<p>通过我们可以看出：<code>hashCode()</code> 的作用就是<strong>获取哈希码</strong>，也称为散列码；它实际上是返回一个 int 整数。这个<strong>哈希码的作用</strong>是确定该对象在哈希表中的索引位置。**<code>hashCode()</code>在散列表中才有用，在其它情况下没用**。在散列表中 hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p>
<h3 id="hashCode（）与-equals（）的相关规定"><a href="#hashCode（）与-equals（）的相关规定" class="headerlink" title="hashCode（）与 equals（）的相关规定"></a>hashCode（）与 equals（）的相关规定</h3><ol>
<li>如果两个对象相等，则 hashcode 一定也是相同的</li>
<li>两个对象相等,对两个对象分别调用 equals 方法都返回 true</li>
<li>两个对象有相同的 hashcode 值，它们也不一定是相等的</li>
<li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li>
<li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ol>
<p>推荐阅读：<a href="https://www.cnblogs.com/skywang12345/p/3324958.html">Java hashCode() 和 equals()的若干问题解答</a></p>
<h2 id="28-为什么-Java-中只有值传递？"><a href="#28-为什么-Java-中只有值传递？" class="headerlink" title="28. 为什么 Java 中只有值传递？"></a>28. 为什么 Java 中只有值传递？</h2><p><a href="https://juejin.im/post/5e18879e6fb9a02fc63602e2">为什么 Java 中只有值传递？</a></p>
<h2 id="29-简述线程、程序、进程的基本概念。以及他们之间关系是什么"><a href="#29-简述线程、程序、进程的基本概念。以及他们之间关系是什么" class="headerlink" title="29. 简述线程、程序、进程的基本概念。以及他们之间关系是什么?"></a>29. 简述线程、程序、进程的基本概念。以及他们之间关系是什么?</h2><p><strong>线程</strong>与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<p><strong>程序</strong>是含有指令和数据的文件，被存储在磁盘或其他的数据存储设备中，也就是说程序是静态的代码。</p>
<p><strong>进程</strong>是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。</p>
<h2 id="30-线程有哪些基本状态"><a href="#30-线程有哪些基本状态" class="headerlink" title="30. 线程有哪些基本状态?"></a>30. 线程有哪些基本状态?</h2><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。</p>
<p><img src="/images/Java%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81.png" alt="Java线程的状态"></p>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：</p>
<p><img src="/images/Java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%8F%98%E8%BF%81.png" alt="Java线程状态变迁"></p>
<p>由上图可以看出：</p>
<p>线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 cpu 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p>
<blockquote>
<p>操作系统隐藏 Java 虚拟机（JVM）中的 READY 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinjava.com/">HowToDoInJava</a>：<a href="https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/">Java Thread Life Cycle and Thread States</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p>
</blockquote>
<p><img src="/images/RUNNABLE-VS-RUNNING.png" alt="RUNNABLE-VS-RUNNING"></p>
<p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong>状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的<code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p>
<h2 id="31-关于-final-关键字的一些总结"><a href="#31-关于-final-关键字的一些总结" class="headerlink" title="31 关于 final 关键字的一些总结"></a>31 关于 final 关键字的一些总结</h2><p>final 关键字主要用在三个地方：变量、方法、类。</p>
<ol>
<li>对于一个 final 变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li>
<li>当用 final 修饰一个类时，表明这个类不能被继承。final 类中的所有成员方法都会被隐式地指定为 final 方法。</li>
<li>使用 final 方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义；第二个原因是效率。在早期的 Java 实现版本中，会将 final 方法转为内嵌调用。但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（现在的 Java 版本已经不需要使用 final 方法进行这些优化了）。类中所有的 private 方法都隐式地指定为 final。</li>
</ol>
<h2 id="32-Java-中的异常处理"><a href="#32-Java-中的异常处理" class="headerlink" title="32 Java 中的异常处理"></a>32 Java 中的异常处理</h2><h3 id="Java-异常类层次结构图"><a href="#Java-异常类层次结构图" class="headerlink" title="Java 异常类层次结构图"></a>Java 异常类层次结构图</h3><p><img src="/images/java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="Java异常类层次结构图"></p>
<p>图片来自：<a href="https://simplesnippets.tech/exception-handling-in-java-part-1/">https://simplesnippets.tech/exception-handling-in-java-part-1/</a></p>
<p><img src="/images/java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE%E4%BA%8C.png" alt="Java异常类层次结构图"></p>
<p>图片来自：<a href="https://chercher.tech/java-programming/exceptions-java">https://chercher.tech/java-programming/exceptions-java</a></p>
<p>在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 <strong>Throwable 类</strong>。Throwable： 有两个重要的子类：<strong>Exception（异常）</strong> 和 <strong>Error（错误）</strong> ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。</p>
<p><strong>Error（错误）:是程序无法处理的错误</strong>，表示运行应用程序中较严重问题。大多数错误与代码编写者执行的操作无关，而表示代码运行时 JVM（Java 虚拟机）出现的问题。例如，Java 虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p>
<p>这些错误表示故障发生于虚拟机自身、或者发生在虚拟机试图执行应用时，如 Java 虚拟机运行错误（Virtual MachineError）、类定义错误（NoClassDefFoundError）等。这些错误是不可查的，因为它们在应用程序的控制和处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。对于设计合理的应用程序来说，即使确实发生了错误，本质上也不应该试图去处理它所引起的异常状况。在 Java 中，错误通过 Error 的子类描述。</p>
<p><strong>Exception（异常）:是程序本身可以处理的异常</strong>。Exception 类有一个重要的子类 <strong>RuntimeException</strong>。RuntimeException 异常由 Java 虚拟机抛出。<strong>NullPointerException</strong>（要访问的变量没有引用任何对象时，抛出该异常）、<strong>ArithmeticException</strong>（算术运算异常，一个整数除以 0 时，抛出该异常）和 <strong>ArrayIndexOutOfBoundsException</strong> （下标越界异常）。</p>
<p><strong>注意：异常和错误的区别：异常能被程序本身处理，错误是无法处理。</strong></p>
<h3 id="Throwable-类常用方法"><a href="#Throwable-类常用方法" class="headerlink" title="Throwable 类常用方法"></a>Throwable 类常用方法</h3><ul>
<li><strong>public string getMessage()</strong>:返回异常发生时的简要描述</li>
<li><strong>public string toString()</strong>:返回异常发生时的详细信息</li>
<li><strong>public string getLocalizedMessage()</strong>:返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage（）返回的结果相同</li>
<li><strong>public void printStackTrace()</strong>:在控制台上打印 Throwable 对象封装的异常信息</li>
</ul>
<h3 id="异常处理总结"><a href="#异常处理总结" class="headerlink" title="异常处理总结"></a>异常处理总结</h3><ul>
<li><strong>try 块：</strong> 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</li>
<li><strong>catch 块：</strong> 用于处理 try 捕获到的异常。</li>
<li><strong>finally 块：</strong> 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</li>
</ul>
<p><strong>在以下 4 种特殊情况下，finally 块不会被执行：</strong></p>
<ol>
<li>在 finally 语句块第一行发生了异常。 因为在其他行，finally 块还是会得到执行</li>
<li>在前面的代码中用了 System.exit(int)已退出程序。 exit 是带参函数 ；若该语句在异常语句之后，finally 会执行</li>
<li>程序所在的线程死亡。</li>
<li>关闭 CPU。</li>
</ol>
<p>下面这部分内容来自 issue:<a href="https://github.com/Snailclimb/JavaGuide/issues/190%E3%80%82">https://github.com/Snailclimb/JavaGuide/issues/190。</a></p>
<p><strong>注意：</strong> 当 try 语句和 finally 语句中都有 return 语句时，在方法返回之前，finally 语句的内容将被执行，并且 finally 语句的返回值将会覆盖原始的返回值。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value * value;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果调用 <code>f(2)</code>，返回值将是 0，因为 finally 语句的返回值覆盖了 try 语句块的返回值。</p>
<h2 id="33-Java-序列化中如果有些字段不想进行序列化，怎么办？"><a href="#33-Java-序列化中如果有些字段不想进行序列化，怎么办？" class="headerlink" title="33 Java 序列化中如果有些字段不想进行序列化，怎么办？"></a>33 Java 序列化中如果有些字段不想进行序列化，怎么办？</h2><p>对于不想进行序列化的变量，使用 transient 关键字修饰。</p>
<p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方法。</p>
<h2 id="34-获取用键盘输入常用的两种方法"><a href="#34-获取用键盘输入常用的两种方法" class="headerlink" title="34 获取用键盘输入常用的两种方法"></a>34 获取用键盘输入常用的两种方法</h2><p>方法 1：通过 Scanner</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s  = input.nextLine();</span><br><span class="line">input.close();</span><br></pre></td></tr></table></figure>

<p>方法 2：通过 BufferedReader</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();</span><br></pre></td></tr></table></figure>

<h2 id="35-Java-中-IO-流"><a href="#35-Java-中-IO-流" class="headerlink" title="35 Java 中 IO 流"></a>35 Java 中 IO 流</h2><h3 id="Java-中-IO-流分为几种"><a href="#Java-中-IO-流分为几种" class="headerlink" title="Java 中 IO 流分为几种?"></a>Java 中 IO 流分为几种?</h3><ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流。</li>
</ul>
<p>Java Io 流共涉及 40 多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p>
<ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<p>按操作方式分类结构图：</p>
<p><img src="/images/IO-%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F%E5%88%86%E7%B1%BB.jpg" alt="IO-操作方式分类"></p>
<p>按操作对象分类结构图：</p>
<p><img src="/images/IO-%E6%93%8D%E4%BD%9C%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB.jpg" alt="IO-操作对象分类"></p>
<h3 id="既然有了字节流-为什么还要有字符流"><a href="#既然有了字节流-为什么还要有字符流" class="headerlink" title="既然有了字节流,为什么还要有字符流?"></a>既然有了字节流,为什么还要有字符流?</h3><p>问题本质想问：<strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p>
<p>回答：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
<h3 id="BIO-NIO-AIO-有什么区别"><a href="#BIO-NIO-AIO-有什么区别" class="headerlink" title="BIO,NIO,AIO 有什么区别?"></a>BIO,NIO,AIO 有什么区别?</h3><ul>
<li><strong>BIO (Blocking I/O):</strong> 同步阻塞 I/O 模式，数据的读取写入必须阻塞在一个线程内等待其完成。在活动连接数不是特别高（小于单机 1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li>
<li><strong>NIO (Non-blocking/New I/O):</strong> NIO 是一种同步非阻塞的 I/O 模型，在 Java 1.4 中引入了 NIO 框架，对应 java.nio 包，提供了 Channel , Selector，Buffer 等抽象。NIO 中的 N 可以理解为 Non-blocking，不单纯是 New。它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 <code>Socket</code> 和 <code>ServerSocket</code> 相对应的 <code>SocketChannel</code> 和 <code>ServerSocketChannel</code> 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞 I/O 来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</li>
<li><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,它是异步非阻塞的 IO 模型。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。AIO 是异步 IO 的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li>
</ul>
<h2 id="36-常见关键字总结-static-final-this-super"><a href="#36-常见关键字总结-static-final-this-super" class="headerlink" title="36. 常见关键字总结:static,final,this,super"></a>36. 常见关键字总结:static,final,this,super</h2><p>详见笔主的这篇文章: <a href="https://snailclimb.gitee.io/javaguide/#/docs/java/basic/final,static,this,super">https://snailclimb.gitee.io/javaguide/#/docs/java/basic/final,static,this,super</a></p>
<h2 id="37-Collections-工具类和-Arrays-工具类常见方法总结"><a href="#37-Collections-工具类和-Arrays-工具类常见方法总结" class="headerlink" title="37. Collections 工具类和 Arrays 工具类常见方法总结"></a>37. Collections 工具类和 Arrays 工具类常见方法总结</h2><p>详见笔主的这篇文章: <a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/basic/Arrays,CollectionsCommonMethods.md">https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/basic/Arrays,CollectionsCommonMethods.md</a></p>
<h2 id="38-深拷贝-vs-浅拷贝"><a href="#38-深拷贝-vs-浅拷贝" class="headerlink" title="38. 深拷贝 vs 浅拷贝"></a>38. 深拷贝 vs 浅拷贝</h2><ol>
<li><strong>浅拷贝</strong>：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</li>
<li><strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</li>
</ol>
<p><img src="/images/java-deep-and-shallow-copy.jpg" alt="deep and shallow copy"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre">https://stackoverflow.com/questions/1906445/what-is-the-difference-between-jdk-and-jre</a></li>
<li><a href="https://www.educba.com/oracle-vs-openjdk/">https://www.educba.com/oracle-vs-openjdk/</a></li>
<li><a href="https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk?answertab=active#tab-top">https://stackoverflow.com/questions/22358071/differences-between-oracle-jdk-and-openjdk?answertab=active#tab-top</a></li>
</ul>
<h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p>如果大家想要实时关注我更新的文章以及分享的干货的话，可以关注我的公众号。</p>
<p><strong>《Java 面试突击》:</strong> 由本文档衍生的专为面试而生的《Java 面试突击》V2.0 PDF 版本<a href="#%E5%85%AC%E4%BC%97%E5%8F%B7">公众号</a>后台回复 <strong>“Java 面试突击”</strong> 即可免费领取！</p>
<p><strong>Java 工程师必备学习资源:</strong> 一些 Java 工程师常用学习资源公众号后台回复关键字 <strong>“1”</strong> 即可免费无套路获取。</p>
<p><img src="/images/JavaGuide.jpg" alt="我的公众号"></p>
<p><strong>全文转载自：</strong><a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md">https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>知识整理</category>
      </categories>
  </entry>
  <entry>
    <title>Java内存划分</title>
    <url>/2020/05/29/2020529-Java%E5%86%85%E5%AD%98%E5%88%92%E5%88%86/</url>
    <content><![CDATA[<p>简要的指明Java中内存有哪些区域</p>
<span id="more"></span>

<h2 id="1-栈（Stack）"><a href="#1-栈（Stack）" class="headerlink" title="1. 栈（Stack）"></a>1. 栈（Stack）</h2><p><strong>存放的都是方法中的<code>局部变量</code></strong></p>
<p><strong>方法的运行一定要在栈中运行</strong></p>
<p>局部变量：方法的参数，或者是方法 {方法体} 内部的变量。</p>
<p>作用域：一旦超出作用域，立刻从栈内存中消失。</p>
<h2 id="2-堆（Heap）"><a href="#2-堆（Heap）" class="headerlink" title="2. 堆（Heap）"></a>2. 堆（Heap）</h2><p><strong>凡是 new 出来的<code>对象实例</code>，均存放在堆中</strong></p>
<p>堆内存里面的东西都有一个地址值：以 16 进制编写</p>
<p>堆内存里面的数据，都有默认值：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>整数</td>
<td>0</td>
</tr>
<tr>
<td>浮点数</td>
<td>0.0</td>
</tr>
<tr>
<td>字符</td>
<td>‘\u0000’</td>
</tr>
<tr>
<td>布尔</td>
<td>false</td>
</tr>
<tr>
<td>引用类型</td>
<td>null</td>
</tr>
</tbody></table>
<h2 id="3-方法区（Method-Area）"><a href="#3-方法区（Method-Area）" class="headerlink" title="3. 方法区（Method Area）"></a>3. 方法区（Method Area）</h2><p><strong>存储 <code>.class</code> 相关信息，包含<code>方法</code>的信息</strong></p>
<p>即为 JVM 加载的<strong>类</strong>、<strong>常量</strong>及<strong>静态变量</strong>等信息</p>
<h2 id="4-本地方法栈（Native-Method-Stack）"><a href="#4-本地方法栈（Native-Method-Stack）" class="headerlink" title="4. 本地方法栈（Native Method Stack）"></a>4. 本地方法栈（Native Method Stack）</h2><p><strong>与<code>操作系统</code>相关</strong></p>
<h2 id="5-寄存器（PC-Register）"><a href="#5-寄存器（PC-Register）" class="headerlink" title="5. 寄存器（PC Register）"></a>5. 寄存器（PC Register）</h2><p><strong>与<code>CPU</code>相关</strong></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>知识整理</category>
      </categories>
  </entry>
  <entry>
    <title>HTML基础知识</title>
    <url>/2020/05/30/2020530-HTML%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>HTML的快速入门</p>
<span id="more"></span>

<h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a><strong>概念</strong>：</h2><p><strong>是最基础的网页开发语言</strong></p>
<ul>
<li>Hyper Text Markup Language 超文本标记语言<ul>
<li>超文本:<ul>
<li>超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本.</li>
</ul>
</li>
<li>标记语言:<ul>
<li>由标签构成的语言。&lt;标签名称&gt; 如 html，xml</li>
<li>标记语言不是编程语言</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="快速入门："><a href="#快速入门：" class="headerlink" title="快速入门："></a>快速入门：</h2><ul>
<li>语法：<ol>
<li>html文档后缀名 .html 或者 .htm</li>
<li>标签分为<ol>
<li><strong>围堵</strong>标签：有开始标签和结束标签。如 <html> </html></li>
<li><strong>自闭和</strong>标签：开始标签和结束标签在一起。如</li>
</ol>
</li>
<li>标签可以嵌套： 需要正确嵌套，不能你中有我，我中有你<br>错误：<b></b> 正确：<b></b></li>
<li>在开始标签中可以定义属性。<br>属性是由键值对构成，值需要用引号(单双都可)引起</li>
<li>html的标签不区分大小写，但是建议使用小写。</li>
</ol>
</li>
<li>代码：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">title</span>&gt;</span>title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">FONT</span> <span class="attr">color</span>=<span class="string">&#x27;red&#x27;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&#x27;green&#x27;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="标签学习："><a href="#标签学习：" class="headerlink" title="标签学习："></a>标签学习：</h2><ol>
<li><p>文件标签</p>
<p>：构成html最基本的标签</p>
<ul>
<li>html:html文档的根标签</li>
<li>head：头标签。用于指定html文档的一些属性。引入外部的资源</li>
<li>title：标题标签。</li>
<li>body：体标签</li>
<li><? DOCTYPE html>：html5中定义该文档是html文档</li>
</ul>
</li>
<li><p>文本标签</p>
<p>：和文本有关的标签</p>
<ul>
<li>注释：<!-- 注释内容 --></li>
<li><h1> ~ <h6>：标题标签 * h1~h6:字体大小逐渐递减</li>
<li><p>：段落标签</li>
<li><br>：换行标签</li>
<li><hr>：展示一条水平线
 \* 属性：
            \* color：颜色 
            \* width：宽度 
            \* size：高度 
            \* align：对其方式
            \* center：居中 
            \* left：左对齐 
            \* right：右对齐​</li>
<li><b>：字体加粗</li>
<li><i>：字体斜体</li>
<li><font>:字体标签</li>
<li><center>:文本居中 
\* 属性： 
    \* color：颜色 
    \* size：大小 
    \* face：字体​</li>
<li>属性定义：<ul>
<li>color：<ol>
<li>英文单词：red,green,blue</li>
<li>rgb(值1，值2，值3)：值的范围：0~255 如 rgb(0,0,255)</li>
<li>#值1值2值3：值的范围：00~FF(十六进制)之间。如： #FF00FF</li>
</ol>
</li>
<li>width：<ol>
<li>数值：width=’20’ ,数值的单位，默认是 px(像素)</li>
<li>数值%：占比相对于父元素的比例</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>图片标签：</p>
<ul>
<li>img：展示图片<ul>
<li>属性：<ul>
<li>src：指定图片的位置</li>
</ul>
</li>
<li>代码： <!--展示一张图片 img--> <!-- 相对路径 
       \* 以.开头的路径 ：
             \* ./：代表当前目录
             \* ../:代表上一级目录 --></li>
</ul>
</li>
</ul>
</li>
<li><p>列表标签：</p>
<ul>
<li>有序列表：<ol><li>内容<li></ol></li>
<li>无序列表：<ul><li>内容<li></ul></li>
</ul>
</li>
<li><p>链接标签：</p>
<ul>
<li><a>:定义一个超链接</li>
</ul>
</li>
<li><p>div和span：</p>
<ul>
<li>div: 每一个div占满一整行（有换行）。块级标签</li>
<li>span: 文本信息在一行展示（无换行）。行内标签 内联标签</li>
</ul>
</li>
<li><p>语义化标签：</p>
<p> html5中为了提高程序的可读性，提供了一些标签。</p>
<ol>
<li>：<header>页眉</li>
<li>：<footer>页脚</li>
</ol>
</li>
<li><p>表格标签：</p>
<ul>
<li><p>table：定义表格</p>
<ul>
<li><p>width：宽度</p>
</li>
<li><p>border：边框</p>
</li>
<li><p>cellpadding：定义内容和单元格的距离</p>
</li>
<li><p>cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、</p>
</li>
<li><p>bgcolor：背景色</p>
</li>
<li><p>align：对齐方式</p>
</li>
</ul>
</li>
<li><p>tr：定义行</p>
<ul>
<li>bgcolor：背景色</li>
<li>align：对齐方式</li>
</ul>
</li>
<li><p>td：定义单元格</p>
<ul>
<li>colspan：合并列</li>
<li>rowspan：合并行</li>
</ul>
</li>
<li><p>th：定义表头单元格</p>
</li>
<li><caption>：表格标题</li>
<li><thead>：表示表格的头部分</li>
<li><tbody>：表示表格的体部分</li>
<li><tfoot>：表示表格的脚部分</li>
</ul>
</li>
<li><p><strong>表单标签</strong></p>
</li>
</ol>
<ul>
<li><p>表单：</p>
<ul>
<li><p>概念：用于<strong>采集用户输入的数据</strong>。用于和服务器进行交互。</p>
</li>
<li><p>form：用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围</p>
<ul>
<li><p>属性：</p>
<ul>
<li><p>action：指定提交数据的URL</p>
</li>
<li><p>method: 指定提交方式</p>
<ul>
<li><p>分类：一共7种，2种比较常用</p>
</li>
<li><p>get：</p>
<ol>
<li><p>请求参数会在地址栏中<strong>显示</strong>。会封装到请求行中(HTTP协议后讲解)。</p>
</li>
<li><p>请求参数大小是有限制的。</p>
</li>
<li><p><strong>不太安全</strong>。</p>
</li>
</ol>
</li>
<li><p>post：</p>
<ol>
<li><p>请求参数不会再地址栏中显示。会<strong>封装</strong>在请求体中(HTTP协议后讲解)</p>
</li>
<li><p>请求参数的大小没有限制。</p>
</li>
<li><p>较为<strong>安全</strong>。</p>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li><p>表单项中的数据要想被提交：<strong>必须指定其name属性</strong></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>表单项标签：<br>* input：可以通过type属性值，改变元素展示的样式</p>
<pre><code>    \* type属性：
                 \* text：文本输入框，默认值
                           \* placeholder：指定输入框的提示信息，当输入框的内容发生变化，会自动清空提示信息
                 \* password：密码输入框
                 \* radio:单选框
                 \* checkbox：复选框
</code></pre>
<p>* 注意：</p>
<ol>
<li><p>要想让多个单选框实现单选的效果，则多个单选框的name属性值必须一样。</p>
</li>
<li><p>一般会给每一个单选框提供value属性，指定其被选中后提交的值</p>
</li>
<li><p>checked属性，可以指定默认值<br>* checkbox：复选框<br>* 注意：</p>
</li>
<li><p>一般会给每一个单选框提供value属性，指定其被选中后提交的值</p>
</li>
<li><p>checked属性，可以指定默认值<br><code>* file：文件选择框 </code><br><code>* hidden：隐藏域，用于提交一些信息。 </code><br><code>* 按钮： </code></p>
<pre><code>           `* submit：提交按钮。可以提交表单 `
           `* button：普通按钮 `
</code></pre>
<p><code>* image：图片提交按钮 </code></p>
<pre><code>           `* src属性指定图片的路径 `
</code></pre>
<p><code>* label：指定输入项的文字描述信息 </code></p>
<pre><code>           `* 注意： * label的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点。 `
</code></pre>
<p><code>* select: 下拉列表 </code></p>
<pre><code>            `* 子元素：option，指定列表项 `
</code></pre>
<p><code>* textarea：文本域 </code></p>
<pre><code>           `* cols：指定列数，每一行有多少个字符 `
           `* rows：默认多少行。`
</code></pre>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>HTML</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript基础</title>
    <url>/2020/06/12/2020612-JavaScript%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>JavaScript是一种用来开发Web页面的脚本语言</p>
<span id="more"></span>

<h2 id="概念：-一门客户端脚本语言"><a href="#概念：-一门客户端脚本语言" class="headerlink" title="概念： 一门客户端脚本语言"></a>概念： 一门客户端脚本语言</h2><ul>
<li>运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎</li>
<li>脚本语言：不需要编译，直接就可以被浏览器解析执行了</li>
</ul>
<h2 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h2><ul>
<li>可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。</li>
</ul>
<h2 id="ECMAScript：客户端脚本语言的标准"><a href="#ECMAScript：客户端脚本语言的标准" class="headerlink" title="ECMAScript：客户端脚本语言的标准"></a>ECMAScript：客户端脚本语言的标准</h2><ol>
<li><p>基本语法：</p>
<ol>
<li><p>与html结合方式</p>
<ol>
<li>内部JS：<ul>
<li>定义<script>，标签体内容就是js代码</li>
</ul>
</li>
<li>外部JS：<ul>
<li>定义<script>，通过src属性引入外部的js文件</li>
</ul>
</li>
</ol>
<ul>
<li>注意：<ol>
<li><script>可以定义在html页面的任何地方。但是定义的位置会影响执行顺序。</li>
<li><script>可以定义多个。</li>
</ol>
</li>
</ul>
</li>
<li><p>数据类型：</p>
<ol>
<li>原始数据类型(基本数据类型)：<ol>
<li>number：数字。 整数/小数/NaN(not a number 一个不是数字的数字类型)</li>
<li>string：字符串。 字符串 “abc” “a” ‘abc’</li>
<li>boolean: true和false</li>
<li>null：一个对象为空的占位符</li>
<li>undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined</li>
</ol>
</li>
<li>引用数据类型：对象</li>
</ol>
</li>
<li><p>变量</p>
<ul>
<li>变量：一小块存储数据的内存空间</li>
<li>Java语言是强类型语言，而JavaScript是弱类型语言。<ul>
<li>强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据</li>
<li>弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放<strong>任意类型的数据</strong>。</li>
</ul>
</li>
<li>语法：<ul>
<li>var 变量名 = 初始化值;</li>
</ul>
</li>
<li>typeof 运算符：获取变量的类型。<ul>
<li>注：null运算后得到的是object</li>
</ul>
</li>
</ul>
</li>
<li><p>运算符</p>
<ol>
<li><p>一元运算符：只有一个运算数的运算符</p>
<ul>
<li>++ –: 自增(自减)<ul>
<li>++(–) 在前，先自增(自减)，再运算</li>
<li>++(–) 在后，先运算，再自增(自减)</li>
</ul>
</li>
<li>+(-)：正负号</li>
<li>注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换<ul>
<li>其他类型转number：<ul>
<li>string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字）</li>
<li>boolean转number：true转为1，false转为0</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>算数运算符**” + - * / % …”**</p>
</li>
<li><p>赋值运算符 <strong>“ = += -= ….”</strong></p>
</li>
<li><p>比较运算符</p>
<p>“ &lt; &gt;= &lt;= == ===(全等于)”</p>
<ul>
<li>比较方式<ol>
<li>类型相同：直接比较<ul>
<li>字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。<ol>
<li>类型不同：先进行类型转换，再比较</li>
</ol>
</li>
<li><strong>===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false</strong></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>逻辑运算符&amp;&amp; || ！</p>
<ul>
<li>其他类型转 boolean ：<ol>
<li>number：0或NaN为假，其他为真</li>
<li>string：除了空字符串(“”)，其他都是true</li>
<li>null&amp;undefined:都是false<ol>
<li>对象：所有对象都为true</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
<li><p>流程控制语句 都与 Java 类似，其中 switch 语句可以接受任意的原始数据类型</p>
</li>
<li><p>JS特殊语法：</p>
<ol>
<li>语句以;结尾，如果一行只有一条语句则 ;可以省略 (不建议)<ol>
<li>变量的定义使用var关键字，也可以不使用<ul>
<li>用： 定义的变量是局部变量</li>
<li>不用：定义的变量是全局变量(不建议)</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="基本对象"><a href="#基本对象" class="headerlink" title="基本对象"></a>基本对象</h2><h3 id="Function：函数-方法-对象"><a href="#Function：函数-方法-对象" class="headerlink" title="Function：函数(方法)对象"></a>Function：函数(方法)对象</h3><ol>
<li>创建：<ol>
<li>var fun = new Function(形式参数列表,方法体); //忘掉吧</li>
<li>function 方法名称(形式参数列表){ 方法体 }<ol start="3">
<li>var 方法名 = function(形式参数列表){<pre><code>      方法体
</code></pre>
   }</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>2.特点：</p>
<ol>
<li>方法定义是，形参的类型不用写,返回值类型也不写。 果定义名称相同的方法，会覆盖<ol>
<li>在JS中，方法的调用只与方法的名称有关，和参数列表无关 隐藏的内置对象（数组），arguments,封装所有的实际参数</li>
</ol>
</li>
</ol>
<h3 id="Array-数组对象"><a href="#Array-数组对象" class="headerlink" title="Array:数组对象"></a>Array:数组对象</h3><ol>
<li>创建：<ol>
<li>var arr = new Array(元素列表);</li>
<li>var arr = new Array(默认长度);</li>
<li>var arr = [元素列表];</li>
</ol>
</li>
<li>方法 join(参数):将数组中的元素按照指定的分隔符拼接为字符串 push() 向数组的末尾添加一个或更多元素，并返回新的长度。</li>
<li>属性 length:数组的长度</li>
<li>特点：<ol>
<li>JS中，数组元素的类型可变的。</li>
<li>JS中，数组长度可变的。</li>
</ol>
</li>
</ol>
<h3 id="Date：日期对象"><a href="#Date：日期对象" class="headerlink" title="Date：日期对象"></a>Date：日期对象</h3><ol>
<li><p>创建： var date = new Date();</p>
</li>
<li><p>方法：<br> toLocaleString()：返回当前date对象对应的时间本地字符串格式<br> getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差</p>
</li>
</ol>
<h3 id="Math：数学对象"><a href="#Math：数学对象" class="headerlink" title="Math：数学对象"></a>Math：数学对象</h3><ol>
<li><p>创建：</p>
<ul>
<li>特点：Math对象不用创建，直接使用。 Math.方法名();</li>
</ul>
</li>
<li><p>方法：<br> random():返回 0 ~ 1 之间的随机数。 含0不含1<br> ceil(x)：对数进行上舍入。<br> floor(x)：对数进行下舍入。<br> round(x)：把数四舍五入为最接近的整数。</p>
</li>
<li><p>属性：<br> PI</p>
</li>
</ol>
<h3 id="RegExp：正则表达式对象"><a href="#RegExp：正则表达式对象" class="headerlink" title="RegExp：正则表达式对象"></a>RegExp：正则表达式对象</h3><ol>
<li><p>正则表达式：定义字符串的组成规则。 </p>
<ol>
<li>单个字符:[] 如： [a] [ab] [a-zA-Z0-9*] * 特殊符号代表特殊含义的单个字符: \d:单个数字字符 [0-9] \w:单个单词字符[a-zA-Z0-9*] </li>
<li> 量词符号： ?：表示出现0次或1次 *：表示出现0次或多次 +：出现1次或多次 {m,n}:表示 m&lt;= 数量 &lt;= n * m如果缺省： {,n}:最多n次 * n如果缺省：{m,} 最少m次 </li>
<li> 开始结束符号 * ^:开始 * $:结束</li>
</ol>
</li>
<li><p>正则对象：</p>
<ol>
<li>创建<ol>
<li>var reg = new RegExp(“正则表达式”);</li>
<li>var reg = /正则表达式/;</li>
</ol>
</li>
<li>方法<ol>
<li>test(参数):验证指定的字符串是否符合正则定义的规范</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="Global-全局对象"><a href="#Global-全局对象" class="headerlink" title="Global: 全局对象"></a>Global: 全局对象</h3><ol>
<li>特点：全局对象，这个Global中封装的方法不需要对象就可以直接调用。 方法名();</li>
<li>方法：<br>encodeURI():url编码<br>decodeURI():url解码<br>encodeURIComponent():url编码,编码的字符更多<br>decodeURIComponent():url解码<br>parseInt():将字符串转为数字 * 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number<br>isNaN():判断一个值是否是NaN * NaN六亲不认，连自己都不认。NaN参与的==比较全部问false<br>eval():将 JavaScript 字符串，并把它作为脚本代码来执行。</li>
<li>URL编码 传智播客 = %E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2</li>
</ol>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM:"></a>BOM:</h2><ol>
<li>概念：Browser Object Model 浏览器对象模型<ul>
<li>将浏览器的<strong>各个组成部分封装成对象</strong>。</li>
</ul>
</li>
<li>组成：<ul>
<li>Window：窗口对象</li>
<li>Navigator：浏览器对象</li>
<li>Screen：显示器屏幕对象</li>
<li>History：历史记录对象</li>
<li>Location：地址栏对象</li>
</ul>
</li>
<li>Window：窗口对象<ol>
<li>创建</li>
<li>方法<ol>
<li>与弹出框有关的方法： alert() 显示带有一段消息和一个确认按钮的警告框。 confirm() 显示带有一段消息以及确认按钮和取消按钮的对话框。<ul>
<li>如果用户点击确定按钮，则方法返回true<ul>
<li>如果用户点击取消按钮，则方法返回false prompt() 显示可提示用户输入的对话框。<ul>
<li>返回值：获取用户输入的值</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>与打开关闭有关的方法： close() 关闭浏览器窗口。<ul>
<li>谁调用我 ，我关谁 open() 打开一个新的浏览器窗口<ul>
<li>返回新的Window对象</li>
</ul>
</li>
</ul>
</li>
<li>与定时器有关的方式 setTimeout() 在指定的毫秒数后调用函数或计算表达式。<ul>
<li>参数：<ol>
<li>js代码或者方法对象</li>
<li>毫秒值<ul>
<li>返回值：唯一标识，用于取消定时器 clearTimeout() 取消由 setTimeout() 方法设置的 timeout。setInterval() 按照指定的周期（以毫秒计）来调用函数或计算表达式。 clearInterval() 取消由 setInterval() 设置的 timeout。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
<li>属性：<ol>
<li>获取其他BOM对象： history location Navigator Screen:</li>
<li>获取DOM对象 document</li>
</ol>
</li>
<li>特点<ul>
<li>Window对象不需要创建可以直接使用 window使用。 window.方法名();</li>
<li>window引用可以省略。 方法名();</li>
</ul>
</li>
</ol>
</li>
<li>Location：地址栏对象<ol>
<li>创建(获取)：<ol>
<li>window.location</li>
<li>location</li>
</ol>
</li>
<li>方法：<ul>
<li>reload() 重新加载当前文档。刷新</li>
</ul>
</li>
<li>属性<ul>
<li>href 设置或返回完整的 URL。</li>
</ul>
</li>
</ol>
</li>
<li>History：历史记录对象<ol>
<li>创建(获取)：<ol>
<li>window.history</li>
<li>history</li>
</ol>
</li>
<li>方法：<ul>
<li>back() 加载 history 列表中的前一个 URL。</li>
<li>forward() 加载 history 列表中的下一个 URL。</li>
<li>go(参数) 加载 history 列表中的某个具体页面。<ul>
<li>参数：<ul>
<li>正数：前进几个历史记录</li>
<li>负数：后退几个历史记录</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>属性：<ul>
<li>length 返回当前窗口历史列表中的 URL 数量。</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="DOM："><a href="#DOM：" class="headerlink" title="DOM："></a>DOM：</h2><ul>
<li><p>概念： Document Object Model 文档对象模型</p>
<ul>
<li>将<strong>标记语言文档的各个组成部分封装为对象</strong>。可以使用这些对象，对标记语言文档进行<strong>CRUD</strong>的动态操作</li>
</ul>
</li>
<li><p>W3C DOM 标准被分为 3 个不同的部分：</p>
<ul>
<li>核心 DOM - 针对任何结构化文档的标准模型<ul>
<li>Document：文档对象</li>
<li>Element：元素对象</li>
<li>Attribute：属性对象</li>
<li>Text：文本对象</li>
<li>Comment:注释对象</li>
<li>Node：节点对象，其他5个的父对象</li>
</ul>
</li>
<li>XML DOM - 针对 XML 文档的标准模型</li>
<li>HTML DOM - 针对 HTML 文档的标准模型</li>
</ul>
</li>
<li><p>核心DOM模型：</p>
<ul>
<li>Document：文档对象<ol>
<li>创建(获取)：在html dom模型中可以使用window对象来获取<ol>
<li>window.document</li>
<li>document</li>
</ol>
</li>
<li>方法：<ol>
<li>获取Element对象：<ol>
<li>getElementById() ： 根据id属性值获取元素对象。id属性值一般唯一</li>
<li>getElementsByTagName()：根据元素名称获取元素对象们。返回值是一个数组</li>
<li>getElementsByClassName():根据Class属性值获取元素对象们。返回值是一个数组</li>
<li>getElementsByName(): 根据name属性值获取元素对象们。返回值是一个数组</li>
</ol>
</li>
<li>创建其他DOM对象： createAttribute(name) createComment() createElement() createTextNode()</li>
</ol>
</li>
<li>属性</li>
</ol>
</li>
<li>Element：元素对象<ol>
<li>获取/创建：通过document来获取和创建</li>
<li>方法：<ol>
<li>removeAttribute()：删除属性</li>
<li>setAttribute()：设置属性</li>
</ol>
</li>
</ol>
</li>
<li>Node：节点对象，其他5个的父对象<ul>
<li>特点：所有dom对象都可以被认为是一个节点</li>
<li>方法：<ul>
<li>CRUD dom树：<ul>
<li>appendChild()：向节点的子节点列表的结尾添加新的子节点。</li>
<li>removeChild() ：删除（并返回）当前节点的指定子节点。</li>
<li>replaceChild()：用新节点替换一个子节点。</li>
</ul>
</li>
</ul>
</li>
<li>属性：<ul>
<li>parentNode 返回节点的父节点。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>HTML DOM</p>
<ol>
<li>标签体的设置和获取：innerHTML</li>
<li>使用html元素对象的属性</li>
<li>控制元素样式<ol>
<li>使用元素的style属性来设置 如： //修改样式方式1 div1.style.border = “1px solid red”; div1.style.width = “200px”; //font-size–&gt; fontSize div1.style.fontSize = “20px”;</li>
<li>提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="事件监听机制："><a href="#事件监听机制：" class="headerlink" title="事件监听机制："></a>事件监听机制：</h2><ul>
<li>概念：某些组件被执行了某些操作后，触发某些代码的执行<ul>
<li>事件：某些操作。如： 单击，双击，键盘按下了，鼠标移动了</li>
<li>事件源：组件。如： 按钮 文本输入框…</li>
<li>监听器：代码。</li>
<li>注册监听：将事件，事件源，监听器结合在一起。 当事件源上发生了某个事件，则触发执行某个监听器代码。</li>
</ul>
</li>
<li>常见的事件：<ol>
<li>点击事件：<ol>
<li>onclick：单击事件</li>
<li>ondblclick：双击事件</li>
</ol>
</li>
<li>焦点事件<ol>
<li>onblur：失去焦点</li>
<li>onfocus:  元素获得焦点。</li>
</ol>
</li>
<li>加载事件：<ol>
<li>onload：一张页面或一幅图像完成加载。</li>
</ol>
</li>
<li>鼠标事件：<ol>
<li>onmousedown 鼠标按钮被按下。</li>
<li>onmouseup 鼠标按键被松开。</li>
<li>onmousemove 鼠标被移动。</li>
<li>onmouseover 鼠标移到某元素之上。</li>
<li>onmouseout 鼠标从某元素移开。</li>
</ol>
</li>
<li>键盘事件：<ol>
<li>onkeydown 某个键盘按键被按下。<ol>
<li>onkeyup 某个键盘按键被松开。</li>
<li>onkeypress 某个键盘按键被按下并松开。</li>
</ol>
</li>
<li>选择和改变<ol>
<li>onchange 域的内容被改变。</li>
<li>onselect 文本被选中。</li>
</ol>
</li>
<li>表单事件：<ol>
<li>onsubmit 确认按钮被点击。</li>
<li>onreset 重置按钮被点击。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
  </entry>
  <entry>
    <title>CSS基础知识</title>
    <url>/2020/06/04/202064-CSS%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>CSS基础入门</p>
<span id="more"></span>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>美化HTML页面</p>
<p>多个样式可以作用在同一个HTML的元素上，同时生效</p>
<p><strong>好处：</strong></p>
<ol>
<li>功能强大</li>
<li>将内容展示和样式控制分离<ul>
<li>降低耦合度 —— 解耦</li>
<li>让分工协作更容易</li>
<li>提高开发效率</li>
</ul>
</li>
</ol>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ol>
<li>内联样式<ul>
<li>在标签内使用style属性指定css代码</li>
<li>eg：</li>
</ul>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> style=&quot;<span class="attribute">color</span>:red;&quot;&gt;hello css&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>内部样式<ul>
<li>在head标签内，定义style标签，style标签的标签体内容就是css代码</li>
<li>eg：</li>
</ul>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">       <span class="selector-tag">div</span>&#123;</span><br><span class="line">           <span class="attribute">color</span>:blue;</span><br><span class="line">      &#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">   &lt;<span class="selector-tag">div</span>&gt;hello css&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>外部样式<ol>
<li>定义 css 资源文件。</li>
<li>在 head 标签内，定义 link 标签，引入外部的资源文件。eg：<ul>
<li>a.css文件：</li>
</ul>
</li>
</ol>
</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;</span><br><span class="line"><span class="attribute">color</span>:green;</span><br><span class="line">&#125;</span><br><span class="line">&lt;link rel=&quot;stylesheet&quot; href=&quot;css/<span class="selector-tag">a</span><span class="selector-class">.css</span>&quot;&gt; &lt;<span class="selector-tag">div</span>&gt;hello css&lt;/<span class="selector-tag">div</span>&gt; </span><br><span class="line">&lt;!--也可以写为：--&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line"> <span class="keyword">@import</span> <span class="string">&quot;css/a.css&quot;</span>;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ul>
<li><p>格式：<br>选择器{ </p>
<pre><code>    属性名 1 ：属性值 1 ； 
    属性名 2 ：属性值 2 ；
     . . .
</code></pre>
<p>}</p>
</li>
<li><p>注意： 每一对属性都用 ； 分开，最后一对不用</p>
</li>
</ul>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p><strong>筛选具有相似特征的元素</strong></p>
<ul>
<li>分类：</li>
</ul>
<ol>
<li>基础选择器<ol>
<li>id 选择器：选择具体的id属性值的元素.建议在一个html页面中id值唯一<ul>
<li>语法：#id属性值{}</li>
</ul>
</li>
<li>元素选择器：选择具有相同标签名称的元素<ul>
<li>语法： 标签名称{}</li>
<li>注意：id选择器优先级高于元素选择器</li>
</ul>
</li>
<li>类选择器：选择具有相同的class属性值的元素。<ul>
<li>语法：.class属性值{}</li>
<li>注意：类选择器选择器优先级高于元素选择器</li>
</ul>
</li>
</ol>
</li>
<li>扩展选择器<ol>
<li>选择所有元素：<ul>
<li>语法： *{}</li>
</ul>
</li>
<li>并集选择器：<ul>
<li>选择器1,选择器2{}</li>
</ul>
</li>
<li>子选择器：筛选选择器1元素下的选择器2元素<ul>
<li>语法： 选择器1 选择器2{}</li>
</ul>
</li>
<li>父选择器：筛选选择器2的父元素选择器1<ul>
<li>语法： 选择器1 &gt; 选择器2{}</li>
</ul>
</li>
<li>属性选择器：选择元素名称，属性名=属性值的元素<ul>
<li>语法： 元素名称[属性名=”属性值”]{}</li>
</ul>
</li>
<li>伪类选择器：选择一些元素具有的状态<ul>
<li>语法： 元素:状态{}</li>
<li>如： <a><ul>
<li>状态：<ul>
<li>link：初始化的状态</li>
<li>visited：被访问过的状态</li>
<li>active：正在访问状态</li>
<li>hover：鼠标悬浮状态</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><ol>
<li>字体、文本<ul>
<li>font-size：字体大小<ul>
<li>color：文本颜色</li>
<li>text-align：对其方式</li>
<li>line-height：行高</li>
</ul>
</li>
</ul>
</li>
<li>背景<ul>
<li>background：设置背景样式属性等</li>
</ul>
</li>
<li>边框<ul>
<li>border：设置边框，符合属性</li>
</ul>
</li>
<li>尺寸<ul>
<li>width：宽度</li>
<li>height：高度</li>
</ul>
</li>
<li>盒子模型：控制布局<ul>
<li>margin：外边距</li>
<li>padding：内边距<ul>
<li>默认情况下内边距会影响整个盒子的大小</li>
<li>box-sizing: border-box; 设置盒子的属性，让width和height就是最终盒子的大小</li>
</ul>
</li>
<li>float：浮动<ul>
<li>left</li>
<li>right</li>
</ul>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>JavaWeb</category>
        <category>CSS</category>
      </categories>
  </entry>
  <entry>
    <title>黑马旅游网（案例）</title>
    <url>/2020/06/24/2020624-%E9%BB%91%E9%A9%AC%E6%97%85%E6%B8%B8%E7%BD%91%EF%BC%88%E6%A1%88%E4%BE%8B%EF%BC%89/</url>
    <content><![CDATA[<p>基于 tomcat 的简单 JavaWeb 项目(学习用)</p>
<span id="more"></span>

<h2 id="一、前期准备工作（环境搭建）"><a href="#一、前期准备工作（环境搭建）" class="headerlink" title="一、前期准备工作（环境搭建）"></a>一、前期准备工作（环境搭建）</h2><h3 id="1-导入已有maven项目"><a href="#1-导入已有maven项目" class="headerlink" title="1.导入已有maven项目"></a>1.导入已有maven项目</h3><p><img src="/images/hmTravel/hmTravel1.png" alt="image-20200619084400775"></p>
<p><img src="/images/hmTravel/hmTravel2.png" alt="image-20200619084434510"></p>
<p><img src="/images/hmTravel/hmTravel3.png" alt="image-20200619084526823"></p>
<ul>
<li>如果依赖部分导入失败可以使用本地 jar 包导入</li>
</ul>
<p>右键项目名称，打开如下 OMS</p>
<p><img src="/images/hmTravel/hmTravel4.png" alt="image-20200619084649260"></p>
<p>将 jar 包移入对应本地仓库</p>
<p><img src="/images/hmTravel/hmTravel5.png" alt="image-20200619084841084"></p>
<p>出现资源载入错误：</p>
<p>引入bootstrap..min.css的时候出现了URL：bootstrap.min.css.map 404的错误。</p>
<p>解决方法： 将bootstrap.min.css里的最后一行 /*#sourceMappingURL=bootstrap.min.css.map */删除即可</p>
<p>把chorme文件的工具–&gt;开发者工具–&gt;设置–&gt;Enable source maps勾去掉，去掉这个勾，jquery就不会去下载source map文件了！</p>
<h3 id="2-配置tomcat启动方式"><a href="#2-配置tomcat启动方式" class="headerlink" title="2.配置tomcat启动方式"></a>2.配置tomcat启动方式</h3><p><img src="/images/hmTravel/tomcatConf1.png" alt="image-20200619085624762"></p>
<p><img src="/images/hmTravel/tomcatConf2.png" alt="image-20200619085649754"></p>
<p><img src="/images/hmTravel/tomcatConf3.png" alt="image-20200619085709027"></p>
<p>配置完成后，就可以不通过右侧的 maven 点击 plugins 的 tomcat7:run 来启动tomcat服务。右上角可以直接启动 tomcat7:run 。</p>
<p><img src="/images/hmTravel/tomcatConf4.png" alt="image-20200619085847305"></p>
<p>异常一：</p>
<p><img src="/images/hmTravel/tomcatException1.png" alt="image-20200619181104638"></p>
<p>原因：</p>
<p>未指定plugin版本号</p>
<p>解决：</p>
<p>增加一行<version>x.x.x</version>即可</p>
<p>异常二：</p>
<p><img src="/images/hmTravel/tomcatException2.png" alt="image-20200619181256487"></p>
<p>原因：</p>
<p>未指定编码方式</p>
<p>解决：</p>
<p>在pom.xml文件中添加 <code>&lt;properties&gt;</code> <code>&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;&lt;/properties&gt;</code></p>
<h3 id="3-所用技术"><a href="#3-所用技术" class="headerlink" title="3.所用技术"></a>3.所用技术</h3><h4 id="1）-Web层"><a href="#1）-Web层" class="headerlink" title="1） Web层"></a>1） Web层</h4><p>a) Servlet：前端控制器</p>
<p>b) html：视图</p>
<p>c) Filter：过滤器</p>
<p>d) BeanUtils：数据封装</p>
<p>e) Jackson：json序列化工具</p>
<h4 id="2）-service层"><a href="#2）-service层" class="headerlink" title="2） service层"></a>2） service层</h4><p>f) Javamail：java发送邮件工具</p>
<p>g) Redis：nosql内存数据库</p>
<p>h) Jedis：java的redis客户端</p>
<h4 id="3）-Dao层"><a href="#3）-Dao层" class="headerlink" title="3） Dao层"></a>3） Dao层</h4><p>i) Mysql：数据库</p>
<p>j) Druid：数据库连接池</p>
<p>k)JdbcTemplate：jdbc的工具</p>
<h3 id="4-创建数据库"><a href="#4-创建数据库" class="headerlink" title="4.创建数据库"></a>4.创建数据库</h3><p><img src="/images/hmTravel/dbTravel1.png" alt="image-20200619092747729"></p>
<p>tab_user：</p>
<p><img src="/images/hmTravel/dbTravel2.png" alt="image-20200619092853537"></p>
<h2 id="二、功能实现"><a href="#二、功能实现" class="headerlink" title="二、功能实现"></a>二、功能实现</h2><h3 id="1-注册功能"><a href="#1-注册功能" class="headerlink" title="1.注册功能"></a>1.注册功能</h3><h4 id="基本注册"><a href="#基本注册" class="headerlink" title="基本注册"></a>基本注册</h4><p><img src="/images/hmTravel/register1.png" alt="image-20200619095200842"></p>
<p>导入数据库失败，检查JDBCUtils工具类的properties的路径是否正确</p>
<p><img src="/images/hmTravel/register2.png" alt="image-20200619220726172"></p>
<h4 id="邮箱认证激活"><a href="#邮箱认证激活" class="headerlink" title="邮箱认证激活"></a>邮箱认证激活</h4><p><img src="/images/hmTravel/mailActive1.png" alt="image-20200619222039161"></p>
<p>发送认证邮件的配置：</p>
<p>USER是发件人的邮箱地址；PASSWORD是授权码，不是登录密码；</p>
<p><img src="/images/hmTravel/mailActive2.png" alt="image-20200619220838419"></p>
<p><img src="/images/hmTravel/mailActive3.png" alt="image-20200619220938541"></p>
<p>收件人的邮箱地址:</p>
<p><img src="/images/hmTravel/mailActive4.png" alt="image-20200619221025469"></p>
<h3 id="2-登录功能"><a href="#2-登录功能" class="headerlink" title="2.登录功能"></a>2.登录功能</h3><p><img src="/images/hmTravel/login1.png" alt="image-20200620105756465"></p>
<p>通过登录界面提供的数据，在数据库中查找对应的数据，如果找到，则将数据存在session中，并通过session在登录界面展示姓名</p>
<p><img src="/images/hmTravel/login2.png" alt="image-20200620110022489"></p>
<p><img src="/images/hmTravel/login3.png" alt="image-20200620105947460"></p>
<p><img src="/images/hmTravel/login4.png" alt="img"></p>
<p><img src="/images/hmTravel/login5.png" alt="image-20200620110131191"></p>
<p><img src="/images/hmTravel/login6.png" alt="image-20200620110157059"></p>
<p><img src="/images/hmTravel/login7.png" alt="image-20200620110230663"></p>
<p><img src="/images/hmTravel/login8.png" alt="image-20200620110308011"></p>
<p><img src="/images/hmTravel/login9.png" alt="image-20200620110332755"></p>
<h3 id="3-退出功能"><a href="#3-退出功能" class="headerlink" title="3.退出功能"></a>3.退出功能</h3><p>点击退出，调用exitServlet销毁session记录，重定向到登陆界面</p>
<p><img src="/images/hmTravel/logout1.png" alt="image-20200620112050048"></p>
<p><img src="/images/hmTravel/logout2.png" alt="image-20200620112108194"></p>
<h3 id="4-优化Servlet"><a href="#4-优化Servlet" class="headerlink" title="4.优化Servlet"></a>4.优化Servlet</h3><p>将不同功能但是同一类别的servlet放在同一个servlet中，较少servlet的数量</p>
<p><img src="/images/hmTravel/servlet.png" alt="image-20200620150505337"></p>
<h3 id="5-分类栏功能"><a href="#5-分类栏功能" class="headerlink" title="5.分类栏功能"></a>5.分类栏功能</h3><p><img src="/images/hmTravel/category.png" alt="image-20200620211341003"></p>
<p>使用template从数据库读取数据，写入html页面</p>
<p>小问题：</p>
<p>分类的内容不经常改变，所以可以存在缓存中，这样每次页面加载时就不会再次发出请求。减少加载时间的消耗和数据库的压力。</p>
<p>解决方法：</p>
<p>通过jedis使用redis</p>
<p><img src="/images/hmTravel/category2.png" alt="image-20200620221543104"></p>
<p><img src="/images/hmTravel/category3.png" alt="image-20200620223700926"></p>
<p>要和服务器一起启动redis程序</p>
<p><img src="/images/hmTravel/category4.png" alt="image-20200620223922760"></p>
<p><img src="/images/hmTravel/category5.png" alt="image-20200620223827928"></p>
<h3 id="6-分页展示功能"><a href="#6-分页展示功能" class="headerlink" title="6.分页展示功能"></a>6.分页展示功能</h3><p>分类和线路是一对多的关系，一个类别下有多个线路。</p>
<p><img src="/images/hmTravel/page1.png" alt="image-20200621085917484"></p>
<p>利用分类和线路共有的cid，实现分类</p>
<p><img src="/images/hmTravel/page2.png" alt="image-20200621093955475"></p>
<p><img src="/images/hmTravel/page3.png" alt="image-20200621094011588"></p>
<h3 id="7-查询功能"><a href="#7-查询功能" class="headerlink" title="7.查询功能"></a>7.查询功能</h3><p>更改sql语句查询方式，如果没有查询条件就查询全部</p>
<p><img src="/images/hmTravel/query1.png" alt="image-20200621172802357"></p>
<p>利用拼接的方式</p>
<p>在html页面的load函数，以及每次调用函数都要添加查询条件参数rname</p>
<p><img src="/images/hmTravel/query2.png" alt="image-20200621174116495"></p>
<p><img src="/images/hmTravel/query3.png" alt="image-20200621174146362"></p>
<h3 id="8-线路详情功能"><a href="#8-线路详情功能" class="headerlink" title="8.线路详情功能"></a>8.线路详情功能</h3><p><img src="/images/hmTravel/route1.png" alt="image-20200622091824618"></p>
<p><img src="/images/hmTravel/route2.png" alt="image-20200622091829391"></p>
<p>查询一个完整的route对象，有三部分，自身的route对象，img对象，seller对象。分别使用三个对象对应的dao查询并返回给service，再返回给servlet，最终到html。</p>
<h3 id="9-收藏功能"><a href="#9-收藏功能" class="headerlink" title="9.收藏功能"></a>9.收藏功能</h3><h4 id="判断收藏状态"><a href="#判断收藏状态" class="headerlink" title="判断收藏状态"></a>判断收藏状态</h4><p><img src="/images/hmTravel/favo1.png" alt="image-20200622203734332"></p>
<p><img src="/images/hmTravel/favo2.png" alt="image-20200622203804745"></p>
<p>根据收藏与否，改变html上收藏按钮的样式</p>
<h4 id="添加收藏"><a href="#添加收藏" class="headerlink" title="添加收藏"></a>添加收藏</h4><p><img src="/images/hmTravel/favo3.png" alt="img"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>案例</category>
      </categories>
  </entry>
  <entry>
    <title>数据库中的事务</title>
    <url>/2020/06/26/2020626-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>有关事务的四大特性(ACID)，以及隔离级别</p>
<span id="more"></span>

<h2 id="1、事务是什么"><a href="#1、事务是什么" class="headerlink" title="1、事务是什么"></a>1、事务是什么</h2><p>​    事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。</p>
<h2 id="2、事务的四大特性（ACID）"><a href="#2、事务的四大特性（ACID）" class="headerlink" title="2、事务的四大特性（ACID）"></a>2、事务的四大特性（ACID）</h2><p>   数据库事务 transaction 正确执行的四个基本要素。ACID,原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)。</p>
<p>   （1）<strong>原子性</strong>：整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。<br>   （2）<strong>一致性</strong>：在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。<br>   （3）<strong>隔离性</strong>：隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，  必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。<br>   （4）<strong>持久性</strong>：在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p>
<h2 id="3-不考虑隔离性会产生的-3-个问题"><a href="#3-不考虑隔离性会产生的-3-个问题" class="headerlink" title="3.不考虑隔离性会产生的 3 个问题"></a>3.不考虑隔离性会产生的 3 个问题</h2><p>1）脏读：读取了<strong>未提交</strong>的新数据，然后新数据如果被回滚了，则读取了错误的不存在的数据。</p>
<p>2）不可重复读：在读取的过程中，一个事务范围内多次查询却返回了不同的数据值，因为被其他的事务所<strong>修改并提交</strong>了。</p>
<p>不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</p>
<p>3）幻读：在读取的过程中，被其他事务对数据进行了<strong>新增</strong>操作，导致多次读取返回值不一致。</p>
<p><strong>幻读和不可重复读的区别</strong>在于，不可重复是针对记录的 update 操作，只要在记录上加写锁，就可避免；幻读是对记录的 insert 操作，要禁止幻读必须加上全局的写锁(比如在表上加写锁)。</p>
<h2 id="4-事务的四个隔离级别"><a href="#4-事务的四个隔离级别" class="headerlink" title="4.事务的四个隔离级别"></a>4.事务的四个隔离级别</h2><p><strong>（从低到高，安全性和耗能增加）</strong></p>
<p><strong>第一类事务丢失：（称为回滚丢失）</strong>A 回滚了 B 读的数据</p>
<p><strong>第二类事务丢失：（提交覆盖丢失）</strong>A 覆盖了 B 写的数据</p>
<p><strong>1） 未提交读(Read uncommitted)。 （写加锁，读不加锁）</strong><br>写操作加写锁，读操作不加读锁。禁止第一类丢失更新，但是会出现所有其他数据并发问题。</p>
<p><strong>2）提交读(Read committed)。（写加锁，读加锁）</strong></p>
<p>写操作加写锁，读操作加读锁。禁止第一类丢失更新和脏读。</p>
<p>就是你已经开始读了数据，然后一个事务开始写，然后写的事务不提交的话，是不能进行读的事务，避免了脏读。</p>
<p><strong>3）可重复读(Read repeatable)。（写加锁，读加锁）</strong><br>对于读操作加读锁到<strong>事务结束</strong>，其他事务的更新操作只能等到事务结束之后进行。</p>
<p><strong>这是大部分关系数据库的默认隔离级别。</strong></p>
<p>和提交读的区别在于，提交读的读操作是加读锁到本次读操作结束，可重复读的锁粒度(一个锁实例所保护的共享数据的数量大小就称为该锁的粒度（Granularity))更大。禁止两类丢失更新，禁止脏读和不可 重复度，但是可能出现幻读。</p>
<p>一个事物读的时候，我们把两次读看成整体，在读的过程中，不允许写的操作，这样就可以禁止不可重复读。就是两次读操作不允许其他事物事务。</p>
<p><strong>4）序列化(Serializable)。（对表级的读写加锁）</strong></p>
<p>读操作加<strong>表级读写锁</strong>至事务结束。可以禁止幻读。</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式——单例模式</title>
    <url>/2021/06/04/202164-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。</p>
<span id="more"></span>

<h2 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于<strong>创建型模式</strong>，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时<strong>确保只有单个对象被创建</strong>。这个类<strong>提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象</strong>。</p>
<p>单例模式分为<strong>饿汉式</strong>和<strong>懒汉式</strong></p>
<h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><ul>
<li>单例类<strong>只能有一个实例</strong></li>
<li>单例类必须<strong>自己创建</strong>自己的唯一实例</li>
<li>单例类必须<strong>给所有其他对象提供</strong>这一实例</li>
</ul>
<h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><ul>
<li>在内存里只有<strong>一个实例</strong>，减少了内存的开销，尤其是频繁的创建和销毁实例。</li>
<li>避免对资源的多重占用</li>
</ul>
<h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><ul>
<li>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外部的实例化方法。</li>
</ul>
<h2 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h2><ul>
<li>要求生产<strong>唯一序列号</strong>。 </li>
<li>WEB 中的<strong>计数器</strong>，不用每次刷新都在数据库里加一次，用单例先缓存起来。 </li>
<li>创建的一个对象需要<strong>消耗的资源过多</strong>，比如 I/O 与数据库的连接等。 </li>
</ul>
<h2 id="饿汉式："><a href="#饿汉式：" class="headerlink" title="饿汉式："></a>饿汉式：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">//首先不能让外部可以对该类进行实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//自己创建一个私有的静态的实例对象，当类被加载的时候就创建出对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">//外部只能通过该方法获取对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//缺陷：如果有一个静态方法，但是即使只调用静态方法的时候，也会自动创建出对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="懒汉式："><a href="#懒汉式：" class="headerlink" title="懒汉式："></a>懒汉式：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先不能让外部可以对该类进行实例化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">//和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里使用了双重检查</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">//这一次判断也是必须的，不然会有并发问题</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="嵌套类："><a href="#嵌套类：" class="headerlink" title="嵌套类："></a>嵌套类：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="枚举："><a href="#枚举：" class="headerlink" title="枚举："></a>枚举：</h2><p>最后，我们说一下枚举，枚举很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。</p>
<p>虽然我们平时很少看到用枚举来实现单例，但是在 RxJava 的源码中，有很多地方都用了枚举来实现单例。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>MyBatis入门搭建</title>
    <url>/2020/07/04/202074-MyBatis%E5%85%A5%E9%97%A8%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>在Maven中配置一个对MySQL进行CRUD的简单例子</p>
<span id="more"></span>

<h2 id="一、创建maven工程并导入坐标"><a href="#一、创建maven工程并导入坐标" class="headerlink" title="一、创建maven工程并导入坐标"></a>一、创建maven工程并导入坐标</h2><p>Maven创建时出现：</p>
<p>Cannot resolve plugin org.apache.maven.plugins:maven-clean-plugin:2.5</p>
<p>出现插件无法加载，是maven的配置出现问题</p>
<p><img src="/images/MyBatis/mavenConfig.png" alt="image-20200623100242831"></p>
<p>导入坐标（依赖）：</p>
<p><img src="/images/MyBatis/dependence.png" alt="image-20200623103757129"></p>
<h3 id="二、创建实体类和dao接口"><a href="#二、创建实体类和dao接口" class="headerlink" title="二、创建实体类和dao接口"></a>二、创建实体类和dao接口</h3><p><img src="/images/MyBatis/construction.png" alt="image-20200623103839205"></p>
<p>实体类中的变量名称和数据库中的保持一致</p>
<p><img src="/images/MyBatis/attribute.png" alt="image-20200623103907554"></p>
<p><img src="/images/MyBatis/dbColumn.png" alt="image-20200623103944899"></p>
<h3 id="三、创建mybatis主配置文件"><a href="#三、创建mybatis主配置文件" class="headerlink" title="三、创建mybatis主配置文件"></a>三、创建mybatis主配置文件</h3><p>SqlMapConfig.xml</p>
<p><img src="/images/MyBatis/SqlMapConfig.png" alt="image-20200623104114826"></p>
<p>以及下一步需要的映射配置文件位置</p>
<p><img src="/images/MyBatis/resource.png" alt="image-20200623104202619"></p>
<h3 id="四、创建映射配置文件"><a href="#四、创建映射配置文件" class="headerlink" title="四、创建映射配置文件"></a>四、创建映射配置文件</h3><p>IUserDao.xml</p>
<p><img src="/images/MyBatis/IUserDao.png" alt="image-20200623104244095"></p>
<p>配置对应的IUserDao中方法于select中</p>
<p><img src="/images/MyBatis/Sql.png" alt="image-20200623104253901"></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>环境搭建的注意事项：<br>第一个：创建IUserDao.xml 和 IUserDao.java时名称是为了和我们之前的知识保持一致。 在Mybatis中它把持久层的操作接口名称和映射文件也叫做：Mapper，所以：IUserDao 和 IUserMapper是一样的<br>第二个：在idea中创建目录的时候，它和包是不一样的 包在创建时：com.itheima.dao它是三级结构 目录在创建时：com.itheima.dao是一级目录<br>第三个：mybatis的映射配置文件位置必须和dao接口的包结构相同<br>第四个：映射配置文件的mapper标签namespace属性的取值必须是dao接口的全限定类名<br>第五个：映射配置文件的操作配置（select），id属性的取值必须是dao接口的方法名</p>
<ul>
<li>当我们遵从了第三，四，五点之后，我们在开发中就<strong>无须再写dao的实现类。</strong></li>
</ul>
<h2 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h2><p><img src="/images/MyBatis/error1.png" alt="image-20200623150326980"></p>
<p>IUserDao.xml 未指定返回类型</p>
<p><img src="/images/MyBatis/resultType.png" alt="image-20200623150421533"></p>
<p>指定后返回User类型</p>
<p><img src="/images/MyBatis/returnResult.png" alt="image-20200623151000236"></p>
<p><img src="/images/MyBatis/analyze1.png" alt="img"></p>
<p><img src="/images/MyBatis/analyze2.png" alt="入门案例的分析"></p>
<h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><h3 id="使用-xml-方式"><a href="#使用-xml-方式" class="headerlink" title="使用 xml 方式"></a>使用 xml 方式</h3><p>在IUserDao接口中写出方法</p>
<p><img src="/images/MyBatis/IUserDaoClass.png" alt="image-20200625091223684"></p>
<p>在IUserDao.xml中配置方法</p>
<p><img src="/images/MyBatis/IUserDaoXml.png" alt="image-20200625091318129"></p>
<p>在MyBatisTest测试类方法实现</p>
<p><img src="/images/MyBatis/testSave.png" alt="image-20200625091551914"></p>
<h3 id="使用注解方式"><a href="#使用注解方式" class="headerlink" title="使用注解方式"></a>使用注解方式</h3><p>在接口方法上标注注解（Select , Insert , Update , Delete）</p>
<p><img src="/images/MyBatis/explain.png" alt="image-20200628094307199"></p>
<p>在Test类中编写方法实现</p>
<p><img src="/images/MyBatis/test.png" alt="image-20200628094431365"></p>
<p><img src="/images/MyBatis/test2.png" alt="image-20200628094446934"></p>
<h2 id="出现的问题"><a href="#出现的问题" class="headerlink" title="出现的问题"></a>出现的问题</h2><h3 id="Error-java-不支持发行版本xxx-的问题"><a href="#Error-java-不支持发行版本xxx-的问题" class="headerlink" title="Error : java 不支持发行版本xxx 的问题"></a>Error : java 不支持发行版本xxx 的问题</h3><ol>
<li><p>配置一 在 Setting-&gt;Java Compiler 中将 Project bytecode version 与 target bytecode version 全部设为与本地版本相同的 version 13。</p>
</li>
<li><p>配置二 在 Project Structure-&gt;Modules-&gt;Language level 也设置成 13，与上面配置的版本一致。</p>
</li>
<li><p>配置三 我是先根据博客上面说的前面两个步骤来配置，发现还是有问题。其实在进行第二处配置之后，idea 会弹出一个警告：jdk的版本可能会被maven项目覆盖了。于是在 pom.xml 文件中，我们指定编译器的jdk版本： </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span>                         <span class="tag">&lt;<span class="name">version</span>&gt;</span>x.x.x<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="name">configuration</span>&gt;</span> <span class="comment">&lt;!--让编译器使用本地的xx版本jdk--&gt;</span> </span><br><span class="line">		<span class="tag">&lt;<span class="name">source</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">source</span>&gt;</span> 	</span><br><span class="line">		<span class="tag">&lt;<span class="name">target</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">target</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>把上面这一串代码直接丢到</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="实体类名和数据库的列名不匹配"><a href="#实体类名和数据库的列名不匹配" class="headerlink" title="实体类名和数据库的列名不匹配"></a>实体类名和数据库的列名不匹配</h3><h4 id="xml配置中的问题"><a href="#xml配置中的问题" class="headerlink" title="xml配置中的问题"></a>xml配置中的问题</h4><p>第一种方法（起别名，让数据库别名和实体类匹配）</p>
<p>效率高（直接运行改后的sql），但是麻烦</p>
<p><img src="/images/MyBatis/%E8%B5%B7%E5%88%AB%E5%90%8D.png" alt="image-20200625095654969"></p>
<p>第二种方法（配置返回值结果和实体类的关系）</p>
<p>效率低（二次解析resultMap配置），但是省事可复用</p>
<p><img src="/images/MyBatis/resultMap.png" alt="image-20200625100006550"></p>
<h4 id="注解配置中的问题"><a href="#注解配置中的问题" class="headerlink" title="注解配置中的问题"></a>注解配置中的问题</h4><p>第一种方法（起别名，让数据库别名和实体类匹配）</p>
<p>效率高（直接运行改后的sql），但是麻烦</p>
<p><img src="/images/MyBatis/%E8%B5%B7%E5%88%AB%E5%90%8D2.png" alt="image-20200625095654969"></p>
<p>第二种方法在 dao 中加注释</p>
<p><img src="/images/MyBatis/daoAnotation.png" alt="image-20200628094658908"></p>
<p><img src="/images/MyBatis/daoAnotation2.png" alt="image-20200628094852512"></p>
<p><img src="/images/MyBatis/daoAnotation3.png" alt="image-20200628095535721"></p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
  </entry>
  <entry>
    <title>有关线程的知识点</title>
    <url>/2020/07/04/202074-%E6%9C%89%E5%85%B3%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>认识线程的创建、以及可用的方法</p>
<span id="more"></span>

<h1 id="创建线程的三种方法"><a href="#创建线程的三种方法" class="headerlink" title="创建线程的三种方法"></a>创建线程的三种方法</h1><h2 id="1-继承-Thread-类"><a href="#1-继承-Thread-类" class="headerlink" title="1. 继承 Thread 类"></a>1. 继承 Thread 类</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　 System.out.println(<span class="string">&quot;MyThread is run.&quot;</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么，调用该类的 start 方法就可以启动一个线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">myThread.start();</span><br></pre></td></tr></table></figure>

<p>该方法方便、快捷，但是用继承的方法实现就会有一定限制。如果是一个子类，那么，它就不能通过继承的方法来创建线程。</p>
<h2 id="2-实现-Runnable-接口-无返回值"><a href="#2-实现-Runnable-接口-无返回值" class="headerlink" title="2. 实现 Runnable 接口(无返回值)"></a>2. 实现 Runnable 接口(无返回值)</h2><p>通过实现接口的方式就可以有效避免 Java 单继承的情况</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">OtherClass</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">　　<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　 System.out.println(<span class="string">&quot;MyThread is run.&quot;</span>);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了启动MyThread，需要首先实例化一个Thread，并传入自己的MyThread实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MyThread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(myThread);</span><br><span class="line">thread.start();</span><br></pre></td></tr></table></figure>

<p>当传入一个实现了 Runnable 接口的类给 Thread 后，Thread的run()方法就会调用target.run()：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">　　 target.run();</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-实现-Callable-接口-有返回值"><a href="#3-实现-Callable-接口-有返回值" class="headerlink" title="3. 实现 Callable 接口(有返回值)"></a>3. 实现 Callable 接口(有返回值)</h2><p>执行Callable任务后，可以获取一个Future的对象，在该对象上调用get就可以获取到Callable任务返回的Object了，再结合线程池接口ExecutorService就可以实现传说中有返回结果的多线程了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 有返回值的线程</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException,</span></span><br><span class="line"><span class="function">    InterruptedException </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;----程序开始运行----&quot;</span>);</span><br><span class="line">   Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">int</span> taskSize = <span class="number">5</span>;</span><br><span class="line">   <span class="comment">// 创建一个线程池</span></span><br><span class="line">   ExecutorService pool = Executors.newFixedThreadPool(taskSize);</span><br><span class="line">   <span class="comment">// 创建多个有返回值的任务</span></span><br><span class="line">   List&lt;Future&gt; list = <span class="keyword">new</span> ArrayList&lt;Future&gt;();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; taskSize; i++) &#123;</span><br><span class="line">    Callable c = <span class="keyword">new</span> MyCallable(i + <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="comment">// 执行任务并获取Future对象</span></span><br><span class="line">    Future f = pool.submit(c);</span><br><span class="line">    <span class="comment">// System.out.println(&quot;&gt;&gt;&gt;&quot; + f.get().toString());</span></span><br><span class="line">    list.add(f);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 关闭线程池</span></span><br><span class="line">   pool.shutdown();</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 获取所有并发任务的运行结果</span></span><br><span class="line">   <span class="keyword">for</span> (Future f : list) &#123;</span><br><span class="line">    <span class="comment">// 从Future对象上获取任务的返回值，并输出到控制台</span></span><br><span class="line">    System.out.println(<span class="string">&quot;&gt;&gt;&gt;&quot;</span> + f.get().toString());</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   Date date2 = <span class="keyword">new</span> Date();</span><br><span class="line">   System.out.println(<span class="string">&quot;----程序结束运行----，程序运行时间【&quot;</span></span><br><span class="line">     + (date2.getTime() - date1.getTime()) + <span class="string">&quot;毫秒】&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String taskNum;</span><br><span class="line"> </span><br><span class="line">MyCallable(String taskNum) &#123;</span><br><span class="line">   <span class="keyword">this</span>.taskNum = taskNum;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;&gt;&gt;&gt;&quot;</span> + taskNum + <span class="string">&quot;任务启动&quot;</span>);</span><br><span class="line">   Date dateTmp1 = <span class="keyword">new</span> Date();</span><br><span class="line">   Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">   Date dateTmp2 = <span class="keyword">new</span> Date();</span><br><span class="line">   <span class="keyword">long</span> time = dateTmp2.getTime() - dateTmp1.getTime();</span><br><span class="line">   System.out.println(<span class="string">&quot;&gt;&gt;&gt;&quot;</span> + taskNum + <span class="string">&quot;任务终止&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> taskNum + <span class="string">&quot;任务返回运行结果,当前任务时间【&quot;</span> + time + <span class="string">&quot;毫秒】&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="sleep和yield的区别"><a href="#sleep和yield的区别" class="headerlink" title="sleep和yield的区别"></a>sleep和yield的区别</h1><p>①<strong>sleep方法</strong>给其他线程运行机会时不考虑线程的优先级,因此会给低线程优先级运行的机会,而<strong>yield方法</strong>只会给相同优先级或者更高优先级线程运行的机会</p>
<p>②线程执行<strong>sleep()方法</strong>后转入阻塞状态,所以,执行sleep()方法的线程在指定的时间内不会被执行,而<strong>yield()方法</strong>只是使当前线程重新回到可执行状态,所以执行yield()方法的线程可能在进入可执行状态后马上又被执行</p>
<p>③<strong>sleep()方法</strong>声明抛出InterruptedException,而<strong>yield()方法</strong>没有声明任何异常</p>
<p>④<strong>sleep()方法</strong>比yield()方法(跟操作系统相关)有<strong>更好的可移植性</strong></p>
<h1 id="start-和-run-的区别"><a href="#start-和-run-的区别" class="headerlink" title="start() 和 run() 的区别"></a>start() 和 run() 的区别</h1><p><strong>一：Java中Thread.start和Thread.run是什么？</strong></p>
<p>1.Java中的start()方法是什么？</p>
<p>线程类的start()方法可以用来启动线程；该方法会在内部调用Runnable接口的run()方法，以在<strong>单独的线程</strong>中执行run()方法中指定的代码。</p>
<p>start()方法启动线程执行以下任务：</p>
<p>1.1 它统计了一个<strong>新线程</strong></p>
<p>1.2线程从New State移动到<strong>Runnable状态</strong>。</p>
<p>1.3 当线程有机会执行时，它的目标run()方法将运行。</p>
<p>2.Java中的run()方法是什么？</p>
<p>线程类的run()方法是Runnable接口的一个<strong>抽象方法</strong>，由<strong>java虚拟机直接调用</strong>的，不会创建的新线程。</p>
<p><strong>二：start()方法和run()方法的区别有哪些</strong></p>
<p><strong>1、方法的定义</strong></p>
<p>start()方法在<strong>java.lang.Thread类</strong>中定义；而，run()方法在<strong>java.lang.Runnable接口</strong>中定义，必须在实现类中重写。</p>
<p><strong>2、新线程创建</strong></p>
<p>当程序调用start()方法时，会创建一个新线程，然后执行run()方法。但是如果我们直接调用run()方法，则不会创建新的线程，run()方法将作为当前调用线程本身的常规方法调用执行，并且不会发生多线程。</p>
<p><strong>3、多次调用</strong></p>
<p><strong>start()方法不能多次调用</strong>，否则抛出java.lang.IllegalStateException；而，<strong>run()方法可以进行多次调用</strong>，因为它只是一种正常的方法调用。</p>
<h1 id="脏读、幻读、不可重复读"><a href="#脏读、幻读、不可重复读" class="headerlink" title="脏读、幻读、不可重复读"></a>脏读、幻读、不可重复读</h1><ul>
<li>脏读</li>
</ul>
<p>（<strong>针对未提交数据</strong>）如果一个事务中对数据进行了更新，但事务还没有提交，另一个事务可以“看到”该事务没有提交的更新结果，这样造成的问题就是，如果第一个事务回滚，那么，第二个事务在此之前所“看到”的数据就是一笔脏数据。</p>
<ul>
<li>幻读—修改</li>
</ul>
<p>（<strong>针对其他提交前后，读取数据条数的对比</strong>） 幻读是指同样一笔查询在整个事务过程中多次执行后，查询所得的结果集是不一样的。幻读针对的是多笔记录。在Read Uncommitted隔离级别下， 不管事务2的插入操作是否提交，事务1在插入操作之前和之后执行相同的查询，取得的结果集是不同的，所以，Read Uncommitted同样无法避免幻读的问题。</p>
<ul>
<li>不可重复读—增加或删除</li>
</ul>
<p>（<strong>针对其他提交前后，读取数据本身的对比</strong>）不可重复读取是指同一个事务在整个事务过程中对同一笔数据进行读取，每次读取结果都不同。如果事务1在事务2的更新操作之前读取一次数据，在事务2的更新操作之后再读取同一笔数据一次，两次结果是不同的，所以，Read Uncommitted也无法避免不可重复读取的问题。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>线程</category>
      </categories>
  </entry>
  <entry>
    <title>MyBatis连接池</title>
    <url>/2020/07/11/2020711-MyBatis%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    <content><![CDATA[<h2 id="1-分类"><a href="#1-分类" class="headerlink" title="1. 分类"></a>1. 分类</h2><p>UNPOOLED 不使用连接池的数据源</p>
<p>POOLED 使用连接池的数据源 （常用）</p>
<p>JNDI 使用 JNDI 实现的数据源</p>
<h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2. 配置"></a>2. 配置</h2><p>在 SqlMapConfig.xml 中进行配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>MyBatis在初始化时，根据<dataSource>的 type属性来创建相应类型的的数据源DataSource,即:<br>type=”POOLED”: MyBatis 会创建 PooledDataSource 实例<br>type=”UNPOOLED” : MyBatis 会创建 UnpooledDataSource 实例<br>type=” JNDI”: MyBatis 会从 JNDI 服务上查找 DataSource 实例，然后返回使用</p>
<h2 id="3-动态SQL"><a href="#3-动态SQL" class="headerlink" title="3. 动态SQL"></a>3. 动态SQL</h2><ul>
<li><if>标签 判断条件是否成立，然后选择是否执行 sql 语句</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user &quot;</span>&gt;</span></span><br><span class="line">	select * from user where 1=1</span><br><span class="line">	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null and username != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">	and username like #&#123;username&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;address != null&quot;</span>&gt;</span></span><br><span class="line">    and address like #&#123;address&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意: <if>标签的test属性中写的是对象的属性名，如果是包装类的对象要使用OGNL表达式的写法。<br>另外要注意 where 1=1 的作用!</p>
<ul>
<li><where>标签 可以替代 where 1 = 1 的条件用法</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--根据用户信息查询--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findByUser&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;user &quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--select * from user--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;defaultSql&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;username != null and username != &#x27;&#x27; &quot;</span>&gt;</span></span><br><span class="line">        and username like #&#123;username&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;address != null&quot;</span>&gt;</span></span><br><span class="line">        and address like #&#123;address&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span>	</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><foreach>标签 用来遍历集合以及它的属性</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--查询所有用户在 id 的集合之中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findInIds&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;queryvo&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--select * from user where id in (1,2,3,4,5);--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;defaultSql&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">&quot;ids != null and ids.size() &gt; 0&quot;</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">&quot;ids&quot;</span> <span class="attr">open</span>=<span class="string">&quot;id in (&quot;</span> <span class="attr">close</span>=<span class="string">&quot;)&quot;</span> <span class="attr">item</span>=<span class="string">&quot;uid&quot;</span> <span class="attr">separator</span>=<span class="string">&quot;,&quot;</span>&gt;</span></span><br><span class="line">            	#&#123;uid&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>SQL语句:<br>    select 字段 from user where id in (?)<br><foreach>标签用于遍历集合，它的属性:<br>    collection :代表要遍历的集合元素，注意编写时不要写#{}<br>    open:代表语句的开始部分<br>    close:代表结束部分</p>
<h2 id="4-抽取重复代码"><a href="#4-抽取重复代码" class="headerlink" title="4. 抽取重复代码"></a>4. 抽取重复代码</h2><p>使用 <sql></sql> 标签，将重复的语句写在其中，然后可以使用 <include></include> 加上 sql 标签的 id 使用。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--抽取重复的语句代码片段--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">&quot;defaultSql&quot;</span>&gt;</span></span><br><span class="line">	select * from user</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置查询所有操作--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--引用--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">&quot;defaultSql&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
  </entry>
  <entry>
    <title>MyBatis多表查询之一对多</title>
    <url>/2020/07/14/2020714-MyBatis%E5%A4%9A%E8%A1%A8%E6%9F%A5%E8%AF%A2%E4%B9%8B%E4%B8%80%E5%AF%B9%E5%A4%9A/</url>
    <content><![CDATA[<p><img src="/images/MyBatis/user_account.png" alt="user_account"></p>
<h2 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h2><h3 id="定义账户信息的实体类"><a href="#定义账户信息的实体类" class="headerlink" title="定义账户信息的实体类"></a>定义账户信息的实体类</h3><p>用于存储数据库的账户信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> Integer uid;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line">    <span class="comment">//getter/setter</span></span><br><span class="line">    <span class="comment">//toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及 getter and setter 、toString 方法</p>
<h3 id="编写-Sql-语句"><a href="#编写-Sql-语句" class="headerlink" title="编写 Sql 语句"></a>编写 Sql 语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">	account.<span class="operator">*</span>,</span><br><span class="line">	user.username,</span><br><span class="line">	user.address</span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">	account,</span><br><span class="line">	<span class="keyword">user</span></span><br><span class="line"><span class="keyword">where</span> account.uid <span class="operator">=</span> user.id;</span><br></pre></td></tr></table></figure>

<h3 id="定义-AccountUser-类"><a href="#定义-AccountUser-类" class="headerlink" title="定义 AccountUser 类"></a>定义 AccountUser 类</h3><p>用于存储与账户对应的用户信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountUser</span> <span class="keyword">extends</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getUsername</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以及 getter and setter 、toString 方法</p>
<h3 id="定义账户的持久层-Dao-接口"><a href="#定义账户的持久层-Dao-接口" class="headerlink" title="定义账户的持久层 Dao 接口"></a><strong>定义账户的持久层</strong> <strong>Dao</strong> <strong>接口</strong></h3><p>用于定义各种操作数据库的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询所有账户，同时获取账户的所属用户名称以及它的地址信息</span></span><br><span class="line">    <span class="function">List&lt;AccountUser&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义-AccountDao-xml-文件中的查询配置信息"><a href="#定义-AccountDao-xml-文件中的查询配置信息" class="headerlink" title="定义 AccountDao.xml 文件中的查询配置信息"></a>定义 <strong>AccountDao.xml</strong> <strong>文件中的查询配置信息</strong></h3><p>用于实现 Dao 中的具体方法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.itheima.dao.IAccountDao&quot;</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--配置查询所有操作--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;findAll&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;accountuser&quot;</span>&gt;</span></span><br><span class="line">    	select a.*,u.username,u.address from account a, user u where a.uid = u.id;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意：上述  SQL 语句的查询结果包含了 User 以及 Account 的数据，所以返回值类型就设置成 accountuser</p>
<h3 id="创建-AccountTest-测试类"><a href="#创建-AccountTest-测试类" class="headerlink" title="创建 AccountTest 测试类"></a><strong>创建</strong> <strong>AccountTest</strong> <strong>测试类</strong></h3><p>测试具体的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> InputStream in ;</span><br><span class="line">    <span class="keyword">private</span> SqlSessionFactory factory;</span><br><span class="line">    <span class="keyword">private</span> SqlSession session;</span><br><span class="line">    <span class="keyword">private</span> IAccountDao accountDao;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">//执行操作</span></span><br><span class="line">		List&lt;AccountUser&gt; accountusers = accountDao.findAll();</span><br><span class="line">		<span class="keyword">for</span> (AccountUser au : accountusers) &#123;</span><br><span class="line">			System.out.println(au);</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>以及初始化方法、和结束方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before</span><span class="comment">//在测试方法执行之前执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//1.读取配置文件</span></span><br><span class="line">    in = Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml&quot;</span>);</span><br><span class="line">    <span class="comment">//2.创建构建者对象</span></span><br><span class="line">    SqlSessionFactoryBuilder builder = <span class="keyword">new</span> SqlSessionFactoryBuilder();</span><br><span class="line">    <span class="comment">//3.创建Sq1Session工厂对象</span></span><br><span class="line">    factory = builder.build(in);</span><br><span class="line">    <span class="comment">//4.创建SqlSession对象</span></span><br><span class="line">    session = factory.openSession();</span><br><span class="line">    <span class="comment">//5.创建Dao的代理对象</span></span><br><span class="line">    accountDao = session.getMapper(IAccountDao.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@After</span><span class="comment">//在测试方法执行完成之后执行</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	<span class="comment">//6.事务的提交</span></span><br><span class="line">    session. commit();</span><br><span class="line">	<span class="comment">//7.释放资源</span></span><br><span class="line">    session.close();</span><br><span class="line">    in.close() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h2><h3 id="修改-Account-类"><a href="#修改-Account-类" class="headerlink" title="修改 Account 类"></a>修改 Account 类</h3><p>加入 User 变量，标记该 Account 属于哪个 User</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> Integer uid;</span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//getter/setter</span></span><br><span class="line">    <span class="comment">//toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改-AccountDao-接口中的方法"><a href="#修改-AccountDao-接口中的方法" class="headerlink" title="修改 AccountDao 接口中的方法"></a>修改 AccountDao 接口中的方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//查询所有账户，同时获取账户的所属用户名称以及它的地址信息</span></span><br><span class="line">    <span class="function">List&lt;Account&gt; <span class="title">findAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 List 中的类型设置成 Account ，因为当前的 Account 类中包含了一个 User 类对象，所以可以直接封装账户对应的用户信息。</p>
<h3 id="重新定义-AccountDao-xml-文件"><a href="#重新定义-AccountDao-xml-文件" class="headerlink" title="重新定义 AccountDao.xml 文件"></a><strong>重新定义</strong> <strong>AccountDao.xml</strong> <strong>文件</strong></h3><p><img src="/images/MyBatis/AccountDao_xml.png" alt="image-20200711220339746"></p>
<h3 id="测试类相同"><a href="#测试类相同" class="headerlink" title="测试类相同"></a>测试类相同</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFindAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//执行操作</span></span><br><span class="line">    List&lt;AccountUser&gt; accountusers = accountDao.findAll();</span><br><span class="line">    <span class="keyword">for</span> (AccountUser au : accountusers) &#123;</span><br><span class="line">        System.out.println(au);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
  </entry>
</search>
